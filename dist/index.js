"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issue = exports2.issueCommand = void 0;
    var os = __importStar2(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports2.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareKeyValueMessage = exports2.issueFileCommand = void 0;
    var fs = __importStar2(require("fs"));
    var os = __importStar2(require("os"));
    var uuid_1 = (init_esm_node(), __toCommonJS(esm_node_exports));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${uuid_1.v4()}`;
      const convertedValue = utils_1.toCommandValue(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports2.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new URL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new URL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports2.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self = this;
      self.options = options || {};
      self.proxyOptions = self.options.proxy || {};
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
      self.requests = [];
      self.sockets = [];
      self.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self = this;
      var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
      if (self.sockets.length >= this.maxSockets) {
        self.requests.push(options);
        return;
      }
      self.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this;
      var placeholder = {};
      self.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
          return;
        }
        debug("tunneling connection has established");
        self.sockets[self.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self = this;
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self.sockets[self.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.debug = debug;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require("http");
    var stream = require("stream");
    var net = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require("buffer");
    var nodeUtil = require("util");
    var { stringify: stringify2 } = require("querystring");
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify2(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(origin + path);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1)
        return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers))
        return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "")
        return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var inherits = require("util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var ReadableStream = require("stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module2.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var inherits = require("util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter.call(this);
      cfg = cfg || {};
      const self = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self.maxed) {
          if (self.nread + end - start >= self.maxHeaderSize) {
            end = self.maxHeaderSize - self.nread + start;
            self.nread = self.maxHeaderSize;
            self.maxed = true;
          } else {
            self.nread += end - start;
          }
          self.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("stream").Writable;
    var inherits = require("util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self._inHeader = false;
        self._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self = this;
          process.nextTick(function() {
            self.emit("error", new Error("Unexpected end of multipart data"));
            if (self._part && !self._ignoreData) {
              const type = self._isPreamble ? "Preamble" : "Part";
              self._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self._part.push(null);
              process.nextTick(function() {
                self._realFinish = true;
                self.emit("finish");
                self._realFinish = false;
              });
              return;
            }
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this._events.preamble) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this._events.trailer) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self._parts === 0) {
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self._unpause();
        };
        if (this._isPreamble && this._events.preamble) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this._events.part) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self._parts === 0) {
                if (self._finished) {
                  self._realFinish = true;
                  self.emit("finish");
                  self._realFinish = false;
                } else {
                  self._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports2.toString())) {
          try {
            return textDecoders.get(exports2).decode(data);
          } catch (e) {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module2.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("stream");
    var { inherits } = require("util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self._needDrain = false;
        if (self._cb && !self._pause) {
          const cb = self._cb;
          self._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self._nparts > partsLimit) {
          self.parser.removeListener("part", onPart);
          self.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (!boy._events.file) {
              self.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self._pause = false;
              checkFinished();
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self._pause) {
                return;
              }
              self._pause = false;
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self = this;
      if (self.parser.writable) {
        self.parser.end();
      } else if (!self._boy._done) {
        process.nextTick(function() {
          self._boy._done = true;
          self._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n) {
    };
    module2.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module2.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("stream").Writable;
    var { inherits } = require("util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      var _a;
      if (ev === "finish") {
        if (!this._done) {
          (_a = this._parser) == null ? void 0 : _a.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var _a;
    var DOMException2 = (_a = globalThis.DOMException) != null ? _a : (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var _a2;
    var structuredClone = (_a2 = globalThis.structuredClone) != null ? _a2 : (
      // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
      // structuredClone was added in v17.0.0, but fetch supports v16.8
      function structuredClone2(value, options = void 0) {
        if (arguments.length === 0) {
          throw new TypeError("missing argument");
        }
        if (!channel) {
          channel = new MessageChannel();
        }
        channel.port1.unref();
        channel.port2.unref();
        channel.port1.postMessage(value, options == null ? void 0 : options.transfer);
        return receiveMessageOnPort(channel.port2).message;
      }
    );
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = require("assert");
    var { isUint8Array } = require("util/types");
    var crypto5;
    try {
      crypto5 = require("crypto");
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      var _a, _b;
      return object instanceof Error || (((_a = object == null ? void 0 : object.constructor) == null ? void 0 : _a.name) === "Error" || ((_b = object == null ? void 0 : object.constructor) == null ? void 0 : _b.name) === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      var _a;
      const { headersList } = actualResponse;
      const policyHeader = ((_a = headersList.get("referrer-policy")) != null ? _a : "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      var _a, _b;
      return {
        startTime: (_a = timingInfo.startTime) != null ? _a : 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: (_b = timingInfo.startTime) != null ? _b : 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:")
        return true;
      if (url.protocol === "file:")
        return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null")
          return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto5 === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
      const strongest = list[0].algo;
      const metadata = list.filter((item) => item.algo === strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        let expectedValue = item.hash;
        if (expectedValue.endsWith("==")) {
          expectedValue = expectedValue.slice(0, -2);
        }
        let actualValue = crypto5.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue.endsWith("==")) {
          actualValue = actualValue.slice(0, -2);
        }
        if (actualValue === expectedValue) {
          return true;
        }
        let actualBase64URL = crypto5.createHash(algorithm).update(bytes).digest("base64url");
        if (actualBase64URL.endsWith("==")) {
          actualBase64URL = actualBase64URL.slice(0, -2);
        }
        if (actualBase64URL === expectedValue) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      const supportedHashes = crypto5.getHashes();
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo;
        if (supportedHashes.includes(algorithm.toLowerCase())) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      var _a;
      return (_a = normalizeMethodRecord[method.toLowerCase()]) != null ? _a : method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types: types3 } = require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if ((opts == null ? void 0 : opts.strict) !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return (V == null ? void 0 : V[Symbol.toStringTag]) === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        var _a;
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = (_a = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a.call(V);
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types3.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc == null ? void 0 : desc.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value != null ? value : defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types3.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types3.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types3.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types3.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types3.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types3.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types3.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types3.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types3.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
          ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
          ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++)
          ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--)
          ;
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { types: types3 } = require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        var _a;
        const n = fileName;
        const t = options.type;
        const d = (_a = options.lastModified) != null ? _a : Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types3.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types3.isAnyArrayBuffer(element) || types3.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var File = NativeFile != null ? NativeFile : UndiciFile;
    var FormData = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile != null ? NativeFile : UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers)
              headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null)
              for await (const chunk of consumeBody(this[kState].body))
                busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class _Request {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0)
            continue;
          if (headers[key])
            headers[key] += `,${value}`;
          else
            headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val, skipAppend);
        else
          request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key])
                request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else
                request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend)
            request.headers[key] = processHeaderValue(key, val, skipAppend);
          else
            request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var assert = require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var net = require("net");
    var http = require("http");
    var { pipeline } = require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http2;
    try {
      http2 = require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants = require_constants2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string")
        headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else
        headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0)
            session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0)
        return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { Readable } = require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    var noop = () => {
    };
    module2.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self) {
      return self[kBody] && self[kBody].locked === true || self[kConsume];
    }
    function isUnusable(self) {
      return util.isDisturbed(self) || isLocked(self);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require("buffer").Blob;
          }
          resolve(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert = require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self) {
      if (self.abort) {
        self.abort();
      } else {
        self.onError(new RequestAbortedError());
      }
    }
    function addSignal(self, signal) {
      self[kSignal] = null;
      self[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self);
        return;
      }
      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };
      addAbortListener(self[kSignal], self[kListener]);
    }
    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }
      if ("removeEventListener" in self[kSignal]) {
        self[kSignal].removeEventListener("abort", self[kListener]);
      } else {
        self[kSignal].removeListener("abort", self[kListener]);
      }
      self[kSignal] = null;
      self[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = require("http");
    var {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL3 } = require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL3(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL3(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/undici/lib/handler/RetryHandler.js"(exports2, module2) {
    var assert = require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions != null ? retryOptions : {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn != null ? retryFn : _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter != null ? retryAfter : true,
          maxTimeout: maxTimeout != null ? maxTimeout : 30 * 1e3,
          // 30s,
          timeout: minTimeout != null ? minTimeout : 500,
          // .5s
          timeoutFactor: timeoutFactor != null ? timeoutFactor : 2,
          maxRetries: maxRetries != null ? maxRetries : 5,
          // What errors we should retry
          methods: methods != null ? methods : ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes != null ? statusCodes : [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes != null ? errorCodes : [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent)
          return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          var _a;
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${(_a = this.end) != null ? _a : ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var assert = require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
        --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
        ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      constructor(init) {
        /** @type {[string, string][]|null} */
        __publicField(this, "cookies", null);
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        var _a;
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          (_a = this.cookies) != null ? _a : this.cookies = [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init = void 0) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          const [name, value] = names[i];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = require("assert");
    var { types: types3 } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        var _a;
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = (_a = urlList[urlList.length - 1]) != null ? _a : null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types3.isArrayBuffer(V) || types3.isTypedArray(V) || types3.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V == null ? void 0 : V[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        var _a, _b, _c;
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              var _a2;
              return (_a2 = this.baseUrl) == null ? void 0 : _a2.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window = "client";
        if (((_b = (_a = request.window) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }
        if ("window" in init) {
          window = "no-window";
        }
        request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = (_c = normalizeMethodRecord[method]) != null ? _c : normalizeMethod(method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody != null ? initBody : inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        var _a;
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || ((_a = this.body) == null ? void 0 : _a.locked)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants();
    var { kHeadersList } = require_symbols();
    var EE = require("events");
    var { Readable, pipeline } = require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        (_a = this.connection) == null ? void 0 : _a.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        (_a = this.connection) == null ? void 0 : _a.destroy(error);
        this.emit("terminated", error);
      }
    };
    function fetch2(input, init = {}) {
      var _a, _b;
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (((_a = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a.name) === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: (_b = init.dispatcher) != null ? _b : getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      var _a;
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!((_a = response.urlList) == null ? void 0 : _a.length)) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      var _a, _b;
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable((_a = request.body) == null ? void 0 : _a.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable((_b = response.body) == null ? void 0 : _b.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      var _a, _b, _c, _d;
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = ((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) == null ? void 0 : _c.name) === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = (_d = request.client) == null ? void 0 : _d.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - request’s current URL’s origin is same origin with request’s origin,
            //   and request’s response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // request’s current URL’s scheme is "data"
            currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      var _a;
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = (_a = bodyWithType[1]) != null ? _a : "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          var _a;
          if (!this.destroyed) {
            this.destroyed = true;
            (_a = this.abort) == null ? void 0 : _a.call(this, err != null ? err : new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          var _a;
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          (_a = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a.call(fetchParams, bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        var _a;
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += (_a = bytes == null ? void 0 : bytes.byteLength) != null ? _a : 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              var _a;
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              (_a = this.body) == null ? void 0 : _a.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch: fetch2,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict != null ? eventInitDict : {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types: types3 } = require("util");
    var { StringDecoder } = require("string_decoder");
    var { btoa } = require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types3.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = require("assert");
    var { getGlobalDispatcher } = require_global2();
    var _relevantRequestResponseList, _batchCacheOperations, batchCacheOperations_fn, _queryCache, queryCache_fn, _requestMatchesCachedItem, requestMatchesCachedItem_fn;
    var _Cache = class _Cache {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
         * @param {CacheBatchOperation[]} operations
         * @returns {requestResponseList}
         */
        __privateAdd(this, _batchCacheOperations);
        /**
         * @see https://w3c.github.io/ServiceWorker/#query-cache
         * @param {any} requestQuery
         * @param {import('../../types/cache').CacheQueryOptions} options
         * @param {requestResponseList} targetStorage
         * @returns {requestResponseList}
         */
        __privateAdd(this, _queryCache);
        /**
         * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
         * @param {any} requestQuery
         * @param {any} request
         * @param {any | null} response
         * @param {import('../../types/cache').CacheQueryOptions | undefined} options
         * @returns {boolean}
         */
        __privateAdd(this, _requestMatchesCachedItem);
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
         * @type {requestResponseList}
         */
        __privateAdd(this, _relevantRequestResponseList, void 0);
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        var _a, _b;
        webidl.brandCheck(this, _Cache);
        if (request !== void 0)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response((_b = (_a = response.body) == null ? void 0 : _a.source) != null ? _b : null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!(requestResponses == null ? void 0 : requestResponses.length));
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
    };
    _relevantRequestResponseList = new WeakMap();
    _batchCacheOperations = new WeakSet();
    batchCacheOperations_fn = function(operations) {
      const cache = __privateGet(this, _relevantRequestResponseList);
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (__privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        __privateGet(this, _relevantRequestResponseList).length = 0;
        __privateSet(this, _relevantRequestResponseList, backupCache);
        throw e;
      }
    };
    _queryCache = new WeakSet();
    queryCache_fn = function(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage != null ? targetStorage : __privateGet(this, _relevantRequestResponseList);
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (__privateMethod(this, _requestMatchesCachedItem, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    };
    _requestMatchesCachedItem = new WeakSet();
    requestMatchesCachedItem_fn = function(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options == null ? void 0 : options.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || (options == null ? void 0 : options.ignoreVary) || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    };
    var Cache = _Cache;
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var _caches;
    var _CacheStorage = class _CacheStorage {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
         * @type {Map<string, import('./cache').requestResponseList}
         */
        __privateAdd(this, _caches, /* @__PURE__ */ new Map());
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            const cacheList = __privateGet(this, _caches).get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of __privateGet(this, _caches).values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (__privateGet(this, _caches).has(cacheName)) {
          const cache2 = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        __privateGet(this, _caches).set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = __privateGet(this, _caches).keys();
        return [...keys];
      }
    };
    _caches = new WeakMap();
    var CacheStorage = _CacheStorage;
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify2(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }
      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === "headers list"
        );
        assert(kHeadersListNode, "Headers cannot be parsed");
      }
      const headersList = headers[kHeadersListNode];
      assert(headersList);
      return headersList;
    }
    module2.exports = {
      isCTLExcludingHtab,
      stringify: stringify2,
      getHeadersList
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      var _a;
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        (_a = cookieAttributeList.unparsed) != null ? _a : cookieAttributeList.unparsed = [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify: stringify2, getHeadersList } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = getHeadersList(headers).cookies;
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify2(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify2(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = require("worker_threads");
    var _eventInit;
    var _MessageEvent = class _MessageEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit, void 0);
        __privateSet(this, _eventInit, eventInitDict);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
          Object.freeze(__privateGet(this, _eventInit).ports);
        }
        return __privateGet(this, _eventInit).ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    _eventInit = new WeakMap();
    var MessageEvent = _MessageEvent;
    var _eventInit2;
    var _CloseEvent = class _CloseEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit2, void 0);
        __privateSet(this, _eventInit2, eventInitDict);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).reason;
      }
    };
    _eventInit2 = new WeakMap();
    var CloseEvent = _CloseEvent;
    var _eventInit3;
    var _ErrorEvent = class _ErrorEvent extends Event {
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        __privateAdd(this, _eventInit3, void 0);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict != null ? eventInitDict : {});
        __privateSet(this, _eventInit3, eventInitDict);
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).error;
      }
    };
    _eventInit3 = new WeakMap();
    var ErrorEvent = _ErrorEvent;
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants4();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if ((response == null ? void 0 : response.socket) && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("diagnostics_channel");
    var { uid, states } = require_constants4();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto5;
    try {
      crypto5 = require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      var _a;
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto5.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: (_a = options.dispatcher) != null ? _a : getGlobalDispatcher(),
        processResponse(response) {
          var _a2, _b;
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (((_a2 = response.headersList.get("Upgrade")) == null ? void 0 : _a2.toLowerCase()) !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (((_b = response.headersList.get("Connection")) == null ? void 0 : _b.toLowerCase()) !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto5.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      var _a;
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = (_a = result.code) != null ? _a : 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants4();
    var crypto5;
    try {
      crypto5 = require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto5.randomBytes(4);
      }
      createFrame(opcode) {
        var _a, _b;
        const bodyLength = (_b = (_a = this.frameData) == null ? void 0 : _a.byteLength) != null ? _b : 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var diagnosticsChannel = require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var _buffers, _byteOffset, _state, _info, _fragments;
    var ByteParser = class extends Writable {
      constructor(ws) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        __privateGet(this, _buffers).push(chunk);
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        var _a, _b;
        while (true) {
          if (__privateGet(this, _state) === parserStates.INFO) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).fin = (buffer[0] & 128) !== 0;
            __privateGet(this, _info).opcode = buffer[0] & 15;
            (_b = (_a = __privateGet(this, _info)).originalOpcode) != null ? _b : _a.originalOpcode = __privateGet(this, _info).opcode;
            __privateGet(this, _info).fragmented = !__privateGet(this, _info).fin && __privateGet(this, _info).opcode !== opcodes.CONTINUATION;
            if (__privateGet(this, _info).fragmented && __privateGet(this, _info).opcode !== opcodes.BINARY && __privateGet(this, _info).opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              __privateGet(this, _info).payloadLength = payloadLength;
              __privateSet(this, _state, parserStates.READ_DATA);
            } else if (payloadLength === 126) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_16);
            } else if (payloadLength === 127) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_64);
            }
            if (__privateGet(this, _info).fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((__privateGet(this, _info).opcode === opcodes.PING || __privateGet(this, _info).opcode === opcodes.PONG || __privateGet(this, _info).opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              __privateGet(this, _info).closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              __privateSet(this, _state, parserStates.INFO);
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (__privateGet(this, _info).opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
            if (__privateGet(this, _byteOffset) < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            __privateGet(this, _info).payloadLength = (upper << 8) + lower;
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
            if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
              return callback();
            } else if (__privateGet(this, _byteOffset) >= __privateGet(this, _info).payloadLength) {
              const body = this.consume(__privateGet(this, _info).payloadLength);
              __privateGet(this, _fragments).push(body);
              if (!__privateGet(this, _info).fragmented || __privateGet(this, _info).fin && __privateGet(this, _info).opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                websocketMessageReceived(this.ws, __privateGet(this, _info).originalOpcode, fullMessage);
                __privateSet(this, _info, {});
                __privateGet(this, _fragments).length = 0;
              }
              __privateSet(this, _state, parserStates.INFO);
            }
          }
          if (__privateGet(this, _byteOffset) > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (__privateGet(this, _buffers)[0].length === n) {
          __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
          return __privateGet(this, _buffers).shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += next.length;
          }
        }
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
    _buffers = new WeakMap();
    _byteOffset = new WeakMap();
    _state = new WeakMap();
    _info = new WeakMap();
    _fragments = new WeakMap();
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types: types3 } = require("util");
    var experimentalWarned = false;
    var _events, _bufferedAmount, _protocol, _extensions, _onConnectionEstablished, onConnectionEstablished_fn;
    var _WebSocket = class _WebSocket extends EventTarget {
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        /**
         * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
         */
        __privateAdd(this, _onConnectionEstablished);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, "");
        __privateAdd(this, _extensions, "");
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => __privateMethod(this, _onConnectionEstablished, onConnectionEstablished_fn).call(this, response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (types3.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + ab.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - ab.byteLength);
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
            socket.write(buffer, () => {
              __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _bufferedAmount);
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _extensions);
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _protocol);
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).open) {
          this.removeEventListener("open", __privateGet(this, _events).open);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).open = fn;
          this.addEventListener("open", fn);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).error) {
          this.removeEventListener("error", __privateGet(this, _events).error);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).error = fn;
          this.addEventListener("error", fn);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).close) {
          this.removeEventListener("close", __privateGet(this, _events).close);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).close = fn;
          this.addEventListener("close", fn);
        } else {
          __privateGet(this, _events).close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).message) {
          this.removeEventListener("message", __privateGet(this, _events).message);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).message = fn;
          this.addEventListener("message", fn);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
    };
    _events = new WeakMap();
    _bufferedAmount = new WeakMap();
    _protocol = new WeakMap();
    _extensions = new WeakMap();
    _onConnectionEstablished = new WeakSet();
    onConnectionEstablished_fn = function(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        __privateSet(this, _extensions, extensions);
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        __privateSet(this, _protocol, protocol);
      }
      fireEvent("open", this);
    };
    var WebSocket = _WebSocket;
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types3.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch2(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http = __importStar2(require("http"));
    var https = __importStar2(require("https"));
    var pm = __importStar2(require_proxy());
    var tunnel = __importStar2(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports2.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports2.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `${proxyUrl.username}:${proxyUrl.password}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter2(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter2(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter2(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter2(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter2(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            core_1.debug(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            core_1.setSecret(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path = __importStar2(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os = __importStar2(require("os"));
    var path = __importStar2(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode = exports2.ExitCode || (exports2.ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("ENV", file_command_1.prepareKeyValueMessage(name, val));
      }
      command_1.issueCommand("set-env", { name }, convertedVal);
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      command_1.issueCommand("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        file_command_1.issueFileCommand("PATH", inputPath);
      } else {
        command_1.issueCommand("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports2.addPath = addPath;
    function getInput(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports2.getInput = getInput;
    function getMultilineInput(name, options) {
      const inputs = getInput(name, options).split("\n").filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("OUTPUT", file_command_1.prepareKeyValueMessage(name, value));
      }
      process.stdout.write(os.EOL);
      command_1.issueCommand("set-output", { name }, utils_1.toCommandValue(value));
    }
    exports2.setOutput = setOutput;
    function setCommandEcho(enabled) {
      command_1.issue("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports2.setFailed = setFailed;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports2.isDebug = isDebug;
    function debug(message) {
      command_1.issueCommand("debug", {}, message);
    }
    exports2.debug = debug;
    function error(message, properties = {}) {
      command_1.issueCommand("error", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error;
    function warning(message, properties = {}) {
      command_1.issueCommand("warning", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning;
    function notice(message, properties = {}) {
      command_1.issueCommand("notice", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports2.info = info;
    function startGroup(name) {
      command_1.issue("group", name);
    }
    exports2.startGroup = startGroup;
    function endGroup() {
      command_1.issue("endgroup");
    }
    exports2.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter2(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("STATE", file_command_1.prepareKeyValueMessage(name, value));
      }
      command_1.issueCommand("save-state", { name }, utils_1.toCommandValue(value));
    }
    exports2.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter2(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
  }
});

// node_modules/@atproto/api/dist/index.js
var require_dist = __commonJS({
  "node_modules/@atproto/api/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from3, except, desc) => {
      if (from3 && typeof from3 === "object" || typeof from3 === "function") {
        for (let key of __getOwnPropNames2(from3))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc2(from3, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var require_boundaries = __commonJS2({
      "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js"(exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.EXTENDED_PICTOGRAPHIC = exports3.CLUSTER_BREAK = void 0;
        var CLUSTER_BREAK;
        (function(CLUSTER_BREAK2) {
          CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
          CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
          CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
          CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
          CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
          CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
          CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
          CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
          CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
          CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
          CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
          CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
          CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
          CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
          CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
          CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
          CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
          CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
        })(CLUSTER_BREAK = exports3.CLUSTER_BREAK || (exports3.CLUSTER_BREAK = {}));
        exports3.EXTENDED_PICTOGRAPHIC = 101;
      }
    });
    var require_GraphemerHelper = __commonJS2({
      "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js"(exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var boundaries_1 = require_boundaries();
        var NotBreak = 0;
        var BreakStart = 1;
        var Break = 2;
        var BreakLastRegional = 3;
        var BreakPenultimateRegional = 4;
        var GraphemerHelper = class {
          static isSurrogate(str, pos) {
            return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
          }
          static codePointAt(str, idx) {
            if (idx === void 0) {
              idx = 0;
            }
            const code2 = str.charCodeAt(idx);
            if (55296 <= code2 && code2 <= 56319 && idx < str.length - 1) {
              const hi = code2;
              const low = str.charCodeAt(idx + 1);
              if (56320 <= low && low <= 57343) {
                return (hi - 55296) * 1024 + (low - 56320) + 65536;
              }
              return hi;
            }
            if (56320 <= code2 && code2 <= 57343 && idx >= 1) {
              const hi = str.charCodeAt(idx - 1);
              const low = code2;
              if (55296 <= hi && hi <= 56319) {
                return (hi - 55296) * 1024 + (low - 56320) + 65536;
              }
              return low;
            }
            return code2;
          }
          static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
            const all = [start].concat(mid).concat([end]);
            const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
            const previous = all[all.length - 2];
            const next = end;
            const nextEmoji = endEmoji;
            const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
            if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
              return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
            }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
              if (all.filter(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
              }).length % 2 === 1) {
                return BreakLastRegional;
              } else {
                return BreakPenultimateRegional;
              }
            }
            if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
              return NotBreak;
            } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
              return BreakStart;
            } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
              return BreakStart;
            } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
              return NotBreak;
            } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
              return NotBreak;
            } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
              return NotBreak;
            } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
              return NotBreak;
            } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
              return NotBreak;
            } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
              return NotBreak;
            }
            const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
            if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
              return c === boundaries_1.CLUSTER_BREAK.EXTEND;
            }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
              return NotBreak;
            }
            if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
              return Break;
            }
            if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
              return NotBreak;
            }
            return BreakStart;
          }
        };
        exports3.default = GraphemerHelper;
      }
    });
    var require_GraphemerIterator = __commonJS2({
      "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js"(exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var GraphemerIterator = class {
          constructor(str, nextBreak) {
            this._index = 0;
            this._str = str;
            this._nextBreak = nextBreak;
          }
          [Symbol.iterator]() {
            return this;
          }
          next() {
            let brk;
            if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
              const value = this._str.slice(this._index, brk);
              this._index = brk;
              return { value, done: false };
            }
            if (this._index < this._str.length) {
              const value = this._str.slice(this._index);
              this._index = this._str.length;
              return { value, done: false };
            }
            return { value: void 0, done: true };
          }
        };
        exports3.default = GraphemerIterator;
      }
    });
    var require_Graphemer = __commonJS2({
      "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js"(exports3) {
        "use strict";
        var __importDefault = exports3 && exports3.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var boundaries_1 = require_boundaries();
        var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
        var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
        var Graphemer2 = class {
          static nextBreak(string3, index) {
            if (index === void 0) {
              index = 0;
            }
            if (index < 0) {
              return 0;
            }
            if (index >= string3.length - 1) {
              return string3.length;
            }
            const prevCP = GraphemerHelper_1.default.codePointAt(string3, index);
            const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
            const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
            const mid = [];
            const midEmoji = [];
            for (let i = index + 1; i < string3.length; i++) {
              if (GraphemerHelper_1.default.isSurrogate(string3, i - 1)) {
                continue;
              }
              const nextCP = GraphemerHelper_1.default.codePointAt(string3, i);
              const next = Graphemer2.getGraphemeBreakProperty(nextCP);
              const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
              if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
                return i;
              }
              mid.push(next);
              midEmoji.push(nextEmoji);
            }
            return string3.length;
          }
          splitGraphemes(str) {
            const res = [];
            let index = 0;
            let brk;
            while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
              res.push(str.slice(index, brk));
              index = brk;
            }
            if (index < str.length) {
              res.push(str.slice(index));
            }
            return res;
          }
          iterateGraphemes(str) {
            return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
          }
          countGraphemes(str) {
            let count = 0;
            let index = 0;
            let brk;
            while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
              index = brk;
              count++;
            }
            if (index < str.length) {
              count++;
            }
            return count;
          }
          static getGraphemeBreakProperty(code2) {
            if (code2 < 48905) {
              if (code2 < 44116) {
                if (code2 < 4141) {
                  if (code2 < 2818) {
                    if (code2 < 2363) {
                      if (code2 < 1759) {
                        if (code2 < 1471) {
                          if (code2 < 127) {
                            if (code2 < 11) {
                              if (code2 < 10) {
                                if (0 <= code2 && code2 <= 9) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 === 10) {
                                  return boundaries_1.CLUSTER_BREAK.LF;
                                }
                              }
                            } else {
                              if (code2 < 13) {
                                if (11 <= code2 && code2 <= 12) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 < 14) {
                                  if (code2 === 13) {
                                    return boundaries_1.CLUSTER_BREAK.CR;
                                  }
                                } else {
                                  if (14 <= code2 && code2 <= 31) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 768) {
                              if (code2 < 173) {
                                if (127 <= code2 && code2 <= 159) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 === 173) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              }
                            } else {
                              if (code2 < 1155) {
                                if (768 <= code2 && code2 <= 879) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 1425) {
                                  if (1155 <= code2 && code2 <= 1161) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1425 <= code2 && code2 <= 1469) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 1552) {
                            if (code2 < 1476) {
                              if (code2 < 1473) {
                                if (code2 === 1471) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1473 <= code2 && code2 <= 1474) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 1479) {
                                if (1476 <= code2 && code2 <= 1477) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 1536) {
                                  if (code2 === 1479) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1536 <= code2 && code2 <= 1541) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 1648) {
                              if (code2 < 1564) {
                                if (1552 <= code2 && code2 <= 1562) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 1611) {
                                  if (code2 === 1564) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (1611 <= code2 && code2 <= 1631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 1750) {
                                if (code2 === 1648) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 1757) {
                                  if (1750 <= code2 && code2 <= 1756) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 1757) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 2075) {
                          if (code2 < 1840) {
                            if (code2 < 1770) {
                              if (code2 < 1767) {
                                if (1759 <= code2 && code2 <= 1764) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1767 <= code2 && code2 <= 1768) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 1807) {
                                if (1770 <= code2 && code2 <= 1773) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 1807) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 1809) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 2027) {
                              if (code2 < 1958) {
                                if (1840 <= code2 && code2 <= 1866) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1958 <= code2 && code2 <= 1968) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 2045) {
                                if (2027 <= code2 && code2 <= 2035) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2070) {
                                  if (code2 === 2045) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2070 <= code2 && code2 <= 2073) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2200) {
                            if (code2 < 2089) {
                              if (code2 < 2085) {
                                if (2075 <= code2 && code2 <= 2083) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (2085 <= code2 && code2 <= 2087) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 2137) {
                                if (2089 <= code2 && code2 <= 2093) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2192) {
                                  if (2137 <= code2 && code2 <= 2139) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2192 <= code2 && code2 <= 2193) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2275) {
                              if (code2 < 2250) {
                                if (2200 <= code2 && code2 <= 2207) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2274) {
                                  if (2250 <= code2 && code2 <= 2273) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2274) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2307) {
                                if (2275 <= code2 && code2 <= 2306) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 2307) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2362) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 2561) {
                        if (code2 < 2434) {
                          if (code2 < 2381) {
                            if (code2 < 2366) {
                              if (code2 === 2363) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 2364) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 2369) {
                                if (2366 <= code2 && code2 <= 2368) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 2377) {
                                  if (2369 <= code2 && code2 <= 2376) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2377 <= code2 && code2 <= 2380) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2385) {
                              if (code2 < 2382) {
                                if (code2 === 2381) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (2382 <= code2 && code2 <= 2383) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 2402) {
                                if (2385 <= code2 && code2 <= 2391) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2433) {
                                  if (2402 <= code2 && code2 <= 2403) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2433) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2503) {
                            if (code2 < 2494) {
                              if (code2 < 2492) {
                                if (2434 <= code2 && code2 <= 2435) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 2492) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 2495) {
                                if (code2 === 2494) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2497) {
                                  if (2495 <= code2 && code2 <= 2496) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2497 <= code2 && code2 <= 2500) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2519) {
                              if (code2 < 2507) {
                                if (2503 <= code2 && code2 <= 2504) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 2509) {
                                  if (2507 <= code2 && code2 <= 2508) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2509) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2530) {
                                if (code2 === 2519) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2558) {
                                  if (2530 <= code2 && code2 <= 2531) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2558) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 2691) {
                          if (code2 < 2631) {
                            if (code2 < 2620) {
                              if (code2 < 2563) {
                                if (2561 <= code2 && code2 <= 2562) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 2563) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 2622) {
                                if (code2 === 2620) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2625) {
                                  if (2622 <= code2 && code2 <= 2624) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2625 <= code2 && code2 <= 2626) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2672) {
                              if (code2 < 2635) {
                                if (2631 <= code2 && code2 <= 2632) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2641) {
                                  if (2635 <= code2 && code2 <= 2637) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2641) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2677) {
                                if (2672 <= code2 && code2 <= 2673) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2689) {
                                  if (code2 === 2677) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2689 <= code2 && code2 <= 2690) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2761) {
                            if (code2 < 2750) {
                              if (code2 === 2691) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 2748) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 2753) {
                                if (2750 <= code2 && code2 <= 2752) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 2759) {
                                  if (2753 <= code2 && code2 <= 2757) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2759 <= code2 && code2 <= 2760) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2786) {
                              if (code2 < 2763) {
                                if (code2 === 2761) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 2765) {
                                  if (2763 <= code2 && code2 <= 2764) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2765) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2810) {
                                if (2786 <= code2 && code2 <= 2787) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2817) {
                                  if (2810 <= code2 && code2 <= 2815) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2817) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 3315) {
                      if (code2 < 3076) {
                        if (code2 < 2946) {
                          if (code2 < 2887) {
                            if (code2 < 2878) {
                              if (code2 < 2876) {
                                if (2818 <= code2 && code2 <= 2819) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 2876) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 2880) {
                                if (2878 <= code2 && code2 <= 2879) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2881) {
                                  if (code2 === 2880) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2881 <= code2 && code2 <= 2884) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2893) {
                              if (code2 < 2891) {
                                if (2887 <= code2 && code2 <= 2888) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (2891 <= code2 && code2 <= 2892) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 2901) {
                                if (code2 === 2893) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2914) {
                                  if (2901 <= code2 && code2 <= 2903) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2914 <= code2 && code2 <= 2915) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3014) {
                            if (code2 < 3007) {
                              if (code2 === 2946) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (code2 === 3006) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 3008) {
                                if (code2 === 3007) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 3009) {
                                  if (code2 === 3008) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3009 <= code2 && code2 <= 3010) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3031) {
                              if (code2 < 3018) {
                                if (3014 <= code2 && code2 <= 3016) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 3021) {
                                  if (3018 <= code2 && code2 <= 3020) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 3021) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3072) {
                                if (code2 === 3031) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3073) {
                                  if (code2 === 3072) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3073 <= code2 && code2 <= 3075) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 3262) {
                          if (code2 < 3146) {
                            if (code2 < 3134) {
                              if (code2 === 3076) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (code2 === 3132) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 3137) {
                                if (3134 <= code2 && code2 <= 3136) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3142) {
                                  if (3137 <= code2 && code2 <= 3140) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3142 <= code2 && code2 <= 3144) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3201) {
                              if (code2 < 3157) {
                                if (3146 <= code2 && code2 <= 3149) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3170) {
                                  if (3157 <= code2 && code2 <= 3158) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3170 <= code2 && code2 <= 3171) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3202) {
                                if (code2 === 3201) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3260) {
                                  if (3202 <= code2 && code2 <= 3203) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 3260) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3270) {
                            if (code2 < 3264) {
                              if (code2 === 3262) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 3263) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 3266) {
                                if (3264 <= code2 && code2 <= 3265) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 3267) {
                                  if (code2 === 3266) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3267 <= code2 && code2 <= 3268) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3276) {
                              if (code2 < 3271) {
                                if (code2 === 3270) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3274) {
                                  if (3271 <= code2 && code2 <= 3272) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3274 <= code2 && code2 <= 3275) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3285) {
                                if (3276 <= code2 && code2 <= 3277) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3298) {
                                  if (3285 <= code2 && code2 <= 3286) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3298 <= code2 && code2 <= 3299) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 3551) {
                        if (code2 < 3406) {
                          if (code2 < 3391) {
                            if (code2 < 3330) {
                              if (code2 < 3328) {
                                if (code2 === 3315) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (3328 <= code2 && code2 <= 3329) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 3387) {
                                if (3330 <= code2 && code2 <= 3331) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 3390) {
                                  if (3387 <= code2 && code2 <= 3388) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 3390) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3398) {
                              if (code2 < 3393) {
                                if (3391 <= code2 && code2 <= 3392) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (3393 <= code2 && code2 <= 3396) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 3402) {
                                if (3398 <= code2 && code2 <= 3400) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 3405) {
                                  if (3402 <= code2 && code2 <= 3404) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 3405) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3530) {
                            if (code2 < 3426) {
                              if (code2 === 3406) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                              if (code2 === 3415) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 3457) {
                                if (3426 <= code2 && code2 <= 3427) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3458) {
                                  if (code2 === 3457) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3458 <= code2 && code2 <= 3459) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3538) {
                              if (code2 < 3535) {
                                if (code2 === 3530) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3536) {
                                  if (code2 === 3535) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3536 <= code2 && code2 <= 3537) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3542) {
                                if (3538 <= code2 && code2 <= 3540) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3544) {
                                  if (code2 === 3542) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3544 <= code2 && code2 <= 3550) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 3893) {
                          if (code2 < 3655) {
                            if (code2 < 3633) {
                              if (code2 < 3570) {
                                if (code2 === 3551) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (3570 <= code2 && code2 <= 3571) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 3635) {
                                if (code2 === 3633) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3636) {
                                  if (code2 === 3635) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3636 <= code2 && code2 <= 3642) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3764) {
                              if (code2 < 3761) {
                                if (3655 <= code2 && code2 <= 3662) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 3761) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3763) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 3784) {
                                if (3764 <= code2 && code2 <= 3772) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3864) {
                                  if (3784 <= code2 && code2 <= 3790) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3864 <= code2 && code2 <= 3865) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3967) {
                            if (code2 < 3897) {
                              if (code2 === 3893) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (code2 === 3895) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 3902) {
                                if (code2 === 3897) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3953) {
                                  if (3902 <= code2 && code2 <= 3903) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3953 <= code2 && code2 <= 3966) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3981) {
                              if (code2 < 3968) {
                                if (code2 === 3967) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 3974) {
                                  if (3968 <= code2 && code2 <= 3972) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3974 <= code2 && code2 <= 3975) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3993) {
                                if (3981 <= code2 && code2 <= 3991) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 4038) {
                                  if (3993 <= code2 && code2 <= 4028) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4038) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 7204) {
                    if (code2 < 6448) {
                      if (code2 < 5938) {
                        if (code2 < 4226) {
                          if (code2 < 4157) {
                            if (code2 < 4146) {
                              if (code2 < 4145) {
                                if (4141 <= code2 && code2 <= 4144) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 4145) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 4153) {
                                if (4146 <= code2 && code2 <= 4151) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 4155) {
                                  if (4153 <= code2 && code2 <= 4154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4155 <= code2 && code2 <= 4156) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 4184) {
                              if (code2 < 4182) {
                                if (4157 <= code2 && code2 <= 4158) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (4182 <= code2 && code2 <= 4183) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 4190) {
                                if (4184 <= code2 && code2 <= 4185) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 4209) {
                                  if (4190 <= code2 && code2 <= 4192) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4209 <= code2 && code2 <= 4212) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 4352) {
                            if (code2 < 4229) {
                              if (code2 === 4226) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (code2 === 4228) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code2 < 4237) {
                                if (4229 <= code2 && code2 <= 4230) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 4237) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 4253) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 4957) {
                              if (code2 < 4448) {
                                if (4352 <= code2 && code2 <= 4447) {
                                  return boundaries_1.CLUSTER_BREAK.L;
                                }
                              } else {
                                if (code2 < 4520) {
                                  if (4448 <= code2 && code2 <= 4519) {
                                    return boundaries_1.CLUSTER_BREAK.V;
                                  }
                                } else {
                                  if (4520 <= code2 && code2 <= 4607) {
                                    return boundaries_1.CLUSTER_BREAK.T;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 5906) {
                                if (4957 <= code2 && code2 <= 4959) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 5909) {
                                  if (5906 <= code2 && code2 <= 5908) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 5909) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 6089) {
                          if (code2 < 6070) {
                            if (code2 < 5970) {
                              if (code2 < 5940) {
                                if (5938 <= code2 && code2 <= 5939) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 5940) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 6002) {
                                if (5970 <= code2 && code2 <= 5971) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6068) {
                                  if (6002 <= code2 && code2 <= 6003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6068 <= code2 && code2 <= 6069) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6078) {
                              if (code2 < 6071) {
                                if (code2 === 6070) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (6071 <= code2 && code2 <= 6077) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 6086) {
                                if (6078 <= code2 && code2 <= 6085) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 6087) {
                                  if (code2 === 6086) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6087 <= code2 && code2 <= 6088) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 6277) {
                            if (code2 < 6155) {
                              if (code2 < 6109) {
                                if (6089 <= code2 && code2 <= 6099) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 6109) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 6158) {
                                if (6155 <= code2 && code2 <= 6157) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 6158) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                                if (code2 === 6159) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 6435) {
                              if (code2 < 6313) {
                                if (6277 <= code2 && code2 <= 6278) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6432) {
                                  if (code2 === 6313) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6432 <= code2 && code2 <= 6434) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6439) {
                                if (6435 <= code2 && code2 <= 6438) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 6441) {
                                  if (6439 <= code2 && code2 <= 6440) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6441 <= code2 && code2 <= 6443) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 6971) {
                        if (code2 < 6744) {
                          if (code2 < 6681) {
                            if (code2 < 6451) {
                              if (code2 < 6450) {
                                if (6448 <= code2 && code2 <= 6449) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 6450) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 6457) {
                                if (6451 <= code2 && code2 <= 6456) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 6679) {
                                  if (6457 <= code2 && code2 <= 6459) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6679 <= code2 && code2 <= 6680) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6741) {
                              if (code2 < 6683) {
                                if (6681 <= code2 && code2 <= 6682) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 6683) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 6742) {
                                if (code2 === 6741) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 6742) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 6743) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 6771) {
                            if (code2 < 6754) {
                              if (code2 < 6752) {
                                if (6744 <= code2 && code2 <= 6750) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 6752) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 6757) {
                                if (code2 === 6754) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6765) {
                                  if (6757 <= code2 && code2 <= 6764) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6765 <= code2 && code2 <= 6770) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6912) {
                              if (code2 < 6783) {
                                if (6771 <= code2 && code2 <= 6780) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6832) {
                                  if (code2 === 6783) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6832 <= code2 && code2 <= 6862) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6916) {
                                if (6912 <= code2 && code2 <= 6915) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6964) {
                                  if (code2 === 6916) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (6964 <= code2 && code2 <= 6970) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 7080) {
                          if (code2 < 7019) {
                            if (code2 < 6973) {
                              if (code2 === 6971) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 6972) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 6978) {
                                if (6973 <= code2 && code2 <= 6977) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 6979) {
                                  if (code2 === 6978) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6979 <= code2 && code2 <= 6980) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 7073) {
                              if (code2 < 7040) {
                                if (7019 <= code2 && code2 <= 7027) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 7042) {
                                  if (7040 <= code2 && code2 <= 7041) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7042) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7074) {
                                if (code2 === 7073) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 7078) {
                                  if (7074 <= code2 && code2 <= 7077) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7078 <= code2 && code2 <= 7079) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 7144) {
                            if (code2 < 7083) {
                              if (code2 < 7082) {
                                if (7080 <= code2 && code2 <= 7081) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 7082) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 7142) {
                                if (7083 <= code2 && code2 <= 7085) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 7142) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 7143) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          } else {
                            if (code2 < 7150) {
                              if (code2 < 7146) {
                                if (7144 <= code2 && code2 <= 7145) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 7149) {
                                  if (7146 <= code2 && code2 <= 7148) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 7149) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7151) {
                                if (code2 === 7150) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 7154) {
                                  if (7151 <= code2 && code2 <= 7153) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7154 <= code2 && code2 <= 7155) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 43346) {
                      if (code2 < 11647) {
                        if (code2 < 7415) {
                          if (code2 < 7380) {
                            if (code2 < 7220) {
                              if (code2 < 7212) {
                                if (7204 <= code2 && code2 <= 7211) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (7212 <= code2 && code2 <= 7219) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 7222) {
                                if (7220 <= code2 && code2 <= 7221) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 7376) {
                                  if (7222 <= code2 && code2 <= 7223) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7376 <= code2 && code2 <= 7378) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 7394) {
                              if (code2 < 7393) {
                                if (7380 <= code2 && code2 <= 7392) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 7393) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 7405) {
                                if (7394 <= code2 && code2 <= 7400) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 7405) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 7412) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 8205) {
                            if (code2 < 7616) {
                              if (code2 < 7416) {
                                if (code2 === 7415) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (7416 <= code2 && code2 <= 7417) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 8203) {
                                if (7616 <= code2 && code2 <= 7679) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 8203) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                                if (code2 === 8204) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 8288) {
                              if (code2 < 8206) {
                                if (code2 === 8205) {
                                  return boundaries_1.CLUSTER_BREAK.ZWJ;
                                }
                              } else {
                                if (code2 < 8232) {
                                  if (8206 <= code2 && code2 <= 8207) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (8232 <= code2 && code2 <= 8238) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 8400) {
                                if (8288 <= code2 && code2 <= 8303) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 < 11503) {
                                  if (8400 <= code2 && code2 <= 8432) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (11503 <= code2 && code2 <= 11505) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 43043) {
                          if (code2 < 42612) {
                            if (code2 < 12330) {
                              if (code2 < 11744) {
                                if (code2 === 11647) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (11744 <= code2 && code2 <= 11775) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 12441) {
                                if (12330 <= code2 && code2 <= 12335) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 42607) {
                                  if (12441 <= code2 && code2 <= 12442) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (42607 <= code2 && code2 <= 42610) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43010) {
                              if (code2 < 42654) {
                                if (42612 <= code2 && code2 <= 42621) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 42736) {
                                  if (42654 <= code2 && code2 <= 42655) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (42736 <= code2 && code2 <= 42737) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43014) {
                                if (code2 === 43010) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 43014) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 43019) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 43188) {
                            if (code2 < 43047) {
                              if (code2 < 43045) {
                                if (43043 <= code2 && code2 <= 43044) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43045 <= code2 && code2 <= 43046) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 43052) {
                                if (code2 === 43047) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 43136) {
                                  if (code2 === 43052) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43136 <= code2 && code2 <= 43137) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43263) {
                              if (code2 < 43204) {
                                if (43188 <= code2 && code2 <= 43203) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 43232) {
                                  if (43204 <= code2 && code2 <= 43205) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43232 <= code2 && code2 <= 43249) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43302) {
                                if (code2 === 43263) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 43335) {
                                  if (43302 <= code2 && code2 <= 43309) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43335 <= code2 && code2 <= 43345) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 43698) {
                        if (code2 < 43493) {
                          if (code2 < 43444) {
                            if (code2 < 43392) {
                              if (code2 < 43360) {
                                if (43346 <= code2 && code2 <= 43347) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43360 <= code2 && code2 <= 43388) {
                                  return boundaries_1.CLUSTER_BREAK.L;
                                }
                              }
                            } else {
                              if (code2 < 43395) {
                                if (43392 <= code2 && code2 <= 43394) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 43395) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 43443) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 43450) {
                              if (code2 < 43446) {
                                if (43444 <= code2 && code2 <= 43445) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43446 <= code2 && code2 <= 43449) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 43452) {
                                if (43450 <= code2 && code2 <= 43451) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 43454) {
                                  if (43452 <= code2 && code2 <= 43453) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43454 <= code2 && code2 <= 43456) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 43573) {
                            if (code2 < 43567) {
                              if (code2 < 43561) {
                                if (code2 === 43493) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43561 <= code2 && code2 <= 43566) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 43569) {
                                if (43567 <= code2 && code2 <= 43568) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 43571) {
                                  if (43569 <= code2 && code2 <= 43570) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43571 <= code2 && code2 <= 43572) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43597) {
                              if (code2 < 43587) {
                                if (43573 <= code2 && code2 <= 43574) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 43587) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 43596) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 43644) {
                                if (code2 === 43597) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 43644) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 43696) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 44006) {
                          if (code2 < 43756) {
                            if (code2 < 43710) {
                              if (code2 < 43703) {
                                if (43698 <= code2 && code2 <= 43700) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43703 <= code2 && code2 <= 43704) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 43713) {
                                if (43710 <= code2 && code2 <= 43711) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 43713) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 43755) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          } else {
                            if (code2 < 43766) {
                              if (code2 < 43758) {
                                if (43756 <= code2 && code2 <= 43757) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 43765) {
                                  if (43758 <= code2 && code2 <= 43759) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 43765) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44003) {
                                if (code2 === 43766) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 44005) {
                                  if (44003 <= code2 && code2 <= 44004) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44005) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44032) {
                            if (code2 < 44009) {
                              if (code2 < 44008) {
                                if (44006 <= code2 && code2 <= 44007) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 44008) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 44012) {
                                if (44009 <= code2 && code2 <= 44010) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 44012) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 44013) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 44061) {
                              if (code2 < 44033) {
                                if (code2 === 44032) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44060) {
                                  if (44033 <= code2 && code2 <= 44059) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44060) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44088) {
                                if (44061 <= code2 && code2 <= 44087) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44089) {
                                  if (code2 === 44088) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44089 <= code2 && code2 <= 44115) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 46497) {
                  if (code2 < 45293) {
                    if (code2 < 44704) {
                      if (code2 < 44397) {
                        if (code2 < 44256) {
                          if (code2 < 44173) {
                            if (code2 < 44144) {
                              if (code2 < 44117) {
                                if (code2 === 44116) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44117 <= code2 && code2 <= 44143) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 44145) {
                                if (code2 === 44144) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44172) {
                                  if (44145 <= code2 && code2 <= 44171) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44172) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44201) {
                              if (code2 < 44200) {
                                if (44173 <= code2 && code2 <= 44199) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 44200) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 44228) {
                                if (44201 <= code2 && code2 <= 44227) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44229) {
                                  if (code2 === 44228) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44229 <= code2 && code2 <= 44255) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44313) {
                            if (code2 < 44284) {
                              if (code2 < 44257) {
                                if (code2 === 44256) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44257 <= code2 && code2 <= 44283) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 44285) {
                                if (code2 === 44284) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44312) {
                                  if (44285 <= code2 && code2 <= 44311) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44312) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44368) {
                              if (code2 < 44340) {
                                if (44313 <= code2 && code2 <= 44339) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44341) {
                                  if (code2 === 44340) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44341 <= code2 && code2 <= 44367) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44369) {
                                if (code2 === 44368) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44396) {
                                  if (44369 <= code2 && code2 <= 44395) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44396) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 44537) {
                          if (code2 < 44480) {
                            if (code2 < 44425) {
                              if (code2 < 44424) {
                                if (44397 <= code2 && code2 <= 44423) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 44424) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 44452) {
                                if (44425 <= code2 && code2 <= 44451) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44453) {
                                  if (code2 === 44452) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44453 <= code2 && code2 <= 44479) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44508) {
                              if (code2 < 44481) {
                                if (code2 === 44480) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44481 <= code2 && code2 <= 44507) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 44509) {
                                if (code2 === 44508) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44536) {
                                  if (44509 <= code2 && code2 <= 44535) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44536) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44620) {
                            if (code2 < 44565) {
                              if (code2 < 44564) {
                                if (44537 <= code2 && code2 <= 44563) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 44564) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 44592) {
                                if (44565 <= code2 && code2 <= 44591) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44593) {
                                  if (code2 === 44592) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44593 <= code2 && code2 <= 44619) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44649) {
                              if (code2 < 44621) {
                                if (code2 === 44620) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44648) {
                                  if (44621 <= code2 && code2 <= 44647) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44648) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44676) {
                                if (44649 <= code2 && code2 <= 44675) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44677) {
                                  if (code2 === 44676) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44677 <= code2 && code2 <= 44703) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 44985) {
                        if (code2 < 44844) {
                          if (code2 < 44761) {
                            if (code2 < 44732) {
                              if (code2 < 44705) {
                                if (code2 === 44704) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44705 <= code2 && code2 <= 44731) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 44733) {
                                if (code2 === 44732) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44760) {
                                  if (44733 <= code2 && code2 <= 44759) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44760) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44789) {
                              if (code2 < 44788) {
                                if (44761 <= code2 && code2 <= 44787) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 44788) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 44816) {
                                if (44789 <= code2 && code2 <= 44815) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44817) {
                                  if (code2 === 44816) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44817 <= code2 && code2 <= 44843) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44901) {
                            if (code2 < 44872) {
                              if (code2 < 44845) {
                                if (code2 === 44844) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44845 <= code2 && code2 <= 44871) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 44873) {
                                if (code2 === 44872) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44900) {
                                  if (44873 <= code2 && code2 <= 44899) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44900) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44956) {
                              if (code2 < 44928) {
                                if (44901 <= code2 && code2 <= 44927) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 44929) {
                                  if (code2 === 44928) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44929 <= code2 && code2 <= 44955) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44957) {
                                if (code2 === 44956) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 44984) {
                                  if (44957 <= code2 && code2 <= 44983) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44984) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 45152) {
                          if (code2 < 45068) {
                            if (code2 < 45013) {
                              if (code2 < 45012) {
                                if (44985 <= code2 && code2 <= 45011) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 45012) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 45040) {
                                if (45013 <= code2 && code2 <= 45039) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45041) {
                                  if (code2 === 45040) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45041 <= code2 && code2 <= 45067) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45097) {
                              if (code2 < 45069) {
                                if (code2 === 45068) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45096) {
                                  if (45069 <= code2 && code2 <= 45095) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45096) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45124) {
                                if (45097 <= code2 && code2 <= 45123) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45125) {
                                  if (code2 === 45124) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45125 <= code2 && code2 <= 45151) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45209) {
                            if (code2 < 45180) {
                              if (code2 < 45153) {
                                if (code2 === 45152) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45153 <= code2 && code2 <= 45179) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 45181) {
                                if (code2 === 45180) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45208) {
                                  if (45181 <= code2 && code2 <= 45207) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45208) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45264) {
                              if (code2 < 45236) {
                                if (45209 <= code2 && code2 <= 45235) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45237) {
                                  if (code2 === 45236) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45237 <= code2 && code2 <= 45263) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45265) {
                                if (code2 === 45264) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45292) {
                                  if (45265 <= code2 && code2 <= 45291) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45292) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 45908) {
                      if (code2 < 45600) {
                        if (code2 < 45433) {
                          if (code2 < 45376) {
                            if (code2 < 45321) {
                              if (code2 < 45320) {
                                if (45293 <= code2 && code2 <= 45319) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 45320) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 45348) {
                                if (45321 <= code2 && code2 <= 45347) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45349) {
                                  if (code2 === 45348) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45349 <= code2 && code2 <= 45375) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45404) {
                              if (code2 < 45377) {
                                if (code2 === 45376) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45377 <= code2 && code2 <= 45403) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 45405) {
                                if (code2 === 45404) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45432) {
                                  if (45405 <= code2 && code2 <= 45431) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45432) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45516) {
                            if (code2 < 45461) {
                              if (code2 < 45460) {
                                if (45433 <= code2 && code2 <= 45459) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 45460) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 45488) {
                                if (45461 <= code2 && code2 <= 45487) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45489) {
                                  if (code2 === 45488) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45489 <= code2 && code2 <= 45515) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45545) {
                              if (code2 < 45517) {
                                if (code2 === 45516) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45544) {
                                  if (45517 <= code2 && code2 <= 45543) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45544) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45572) {
                                if (45545 <= code2 && code2 <= 45571) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45573) {
                                  if (code2 === 45572) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45573 <= code2 && code2 <= 45599) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 45741) {
                          if (code2 < 45657) {
                            if (code2 < 45628) {
                              if (code2 < 45601) {
                                if (code2 === 45600) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45601 <= code2 && code2 <= 45627) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 45629) {
                                if (code2 === 45628) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45656) {
                                  if (45629 <= code2 && code2 <= 45655) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45656) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45712) {
                              if (code2 < 45684) {
                                if (45657 <= code2 && code2 <= 45683) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45685) {
                                  if (code2 === 45684) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45685 <= code2 && code2 <= 45711) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45713) {
                                if (code2 === 45712) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45740) {
                                  if (45713 <= code2 && code2 <= 45739) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45740) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45824) {
                            if (code2 < 45769) {
                              if (code2 < 45768) {
                                if (45741 <= code2 && code2 <= 45767) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 45768) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 45796) {
                                if (45769 <= code2 && code2 <= 45795) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45797) {
                                  if (code2 === 45796) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45797 <= code2 && code2 <= 45823) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45853) {
                              if (code2 < 45825) {
                                if (code2 === 45824) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45852) {
                                  if (45825 <= code2 && code2 <= 45851) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45852) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45880) {
                                if (45853 <= code2 && code2 <= 45879) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 45881) {
                                  if (code2 === 45880) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45881 <= code2 && code2 <= 45907) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 46189) {
                        if (code2 < 46048) {
                          if (code2 < 45965) {
                            if (code2 < 45936) {
                              if (code2 < 45909) {
                                if (code2 === 45908) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45909 <= code2 && code2 <= 45935) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 45937) {
                                if (code2 === 45936) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 45964) {
                                  if (45937 <= code2 && code2 <= 45963) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45964) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45993) {
                              if (code2 < 45992) {
                                if (45965 <= code2 && code2 <= 45991) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 45992) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 46020) {
                                if (45993 <= code2 && code2 <= 46019) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46021) {
                                  if (code2 === 46020) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46021 <= code2 && code2 <= 46047) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46105) {
                            if (code2 < 46076) {
                              if (code2 < 46049) {
                                if (code2 === 46048) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46049 <= code2 && code2 <= 46075) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 46077) {
                                if (code2 === 46076) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46104) {
                                  if (46077 <= code2 && code2 <= 46103) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46104) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46160) {
                              if (code2 < 46132) {
                                if (46105 <= code2 && code2 <= 46131) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46133) {
                                  if (code2 === 46132) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46133 <= code2 && code2 <= 46159) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46161) {
                                if (code2 === 46160) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46188) {
                                  if (46161 <= code2 && code2 <= 46187) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46188) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 46356) {
                          if (code2 < 46272) {
                            if (code2 < 46217) {
                              if (code2 < 46216) {
                                if (46189 <= code2 && code2 <= 46215) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 46216) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 46244) {
                                if (46217 <= code2 && code2 <= 46243) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46245) {
                                  if (code2 === 46244) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46245 <= code2 && code2 <= 46271) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46301) {
                              if (code2 < 46273) {
                                if (code2 === 46272) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46300) {
                                  if (46273 <= code2 && code2 <= 46299) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46300) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46328) {
                                if (46301 <= code2 && code2 <= 46327) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46329) {
                                  if (code2 === 46328) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46329 <= code2 && code2 <= 46355) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46413) {
                            if (code2 < 46384) {
                              if (code2 < 46357) {
                                if (code2 === 46356) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46357 <= code2 && code2 <= 46383) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 46385) {
                                if (code2 === 46384) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46412) {
                                  if (46385 <= code2 && code2 <= 46411) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46412) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46468) {
                              if (code2 < 46440) {
                                if (46413 <= code2 && code2 <= 46439) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46441) {
                                  if (code2 === 46440) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46441 <= code2 && code2 <= 46467) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46469) {
                                if (code2 === 46468) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46496) {
                                  if (46469 <= code2 && code2 <= 46495) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46496) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 47701) {
                    if (code2 < 47112) {
                      if (code2 < 46804) {
                        if (code2 < 46637) {
                          if (code2 < 46580) {
                            if (code2 < 46525) {
                              if (code2 < 46524) {
                                if (46497 <= code2 && code2 <= 46523) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 46524) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 46552) {
                                if (46525 <= code2 && code2 <= 46551) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46553) {
                                  if (code2 === 46552) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46553 <= code2 && code2 <= 46579) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46608) {
                              if (code2 < 46581) {
                                if (code2 === 46580) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46581 <= code2 && code2 <= 46607) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 46609) {
                                if (code2 === 46608) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46636) {
                                  if (46609 <= code2 && code2 <= 46635) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46636) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46720) {
                            if (code2 < 46665) {
                              if (code2 < 46664) {
                                if (46637 <= code2 && code2 <= 46663) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 46664) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 46692) {
                                if (46665 <= code2 && code2 <= 46691) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46693) {
                                  if (code2 === 46692) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46693 <= code2 && code2 <= 46719) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46749) {
                              if (code2 < 46721) {
                                if (code2 === 46720) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46748) {
                                  if (46721 <= code2 && code2 <= 46747) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46748) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46776) {
                                if (46749 <= code2 && code2 <= 46775) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46777) {
                                  if (code2 === 46776) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46777 <= code2 && code2 <= 46803) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 46945) {
                          if (code2 < 46861) {
                            if (code2 < 46832) {
                              if (code2 < 46805) {
                                if (code2 === 46804) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46805 <= code2 && code2 <= 46831) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 46833) {
                                if (code2 === 46832) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46860) {
                                  if (46833 <= code2 && code2 <= 46859) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46860) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46916) {
                              if (code2 < 46888) {
                                if (46861 <= code2 && code2 <= 46887) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 46889) {
                                  if (code2 === 46888) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46889 <= code2 && code2 <= 46915) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46917) {
                                if (code2 === 46916) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 46944) {
                                  if (46917 <= code2 && code2 <= 46943) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46944) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47028) {
                            if (code2 < 46973) {
                              if (code2 < 46972) {
                                if (46945 <= code2 && code2 <= 46971) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 46972) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 47e3) {
                                if (46973 <= code2 && code2 <= 46999) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47001) {
                                  if (code2 === 47e3) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47001 <= code2 && code2 <= 47027) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47057) {
                              if (code2 < 47029) {
                                if (code2 === 47028) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47056) {
                                  if (47029 <= code2 && code2 <= 47055) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47056) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47084) {
                                if (47057 <= code2 && code2 <= 47083) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47085) {
                                  if (code2 === 47084) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47085 <= code2 && code2 <= 47111) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 47393) {
                        if (code2 < 47252) {
                          if (code2 < 47169) {
                            if (code2 < 47140) {
                              if (code2 < 47113) {
                                if (code2 === 47112) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47113 <= code2 && code2 <= 47139) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 47141) {
                                if (code2 === 47140) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47168) {
                                  if (47141 <= code2 && code2 <= 47167) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47168) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47197) {
                              if (code2 < 47196) {
                                if (47169 <= code2 && code2 <= 47195) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 47196) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 47224) {
                                if (47197 <= code2 && code2 <= 47223) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47225) {
                                  if (code2 === 47224) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47225 <= code2 && code2 <= 47251) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47309) {
                            if (code2 < 47280) {
                              if (code2 < 47253) {
                                if (code2 === 47252) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47253 <= code2 && code2 <= 47279) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 47281) {
                                if (code2 === 47280) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47308) {
                                  if (47281 <= code2 && code2 <= 47307) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47308) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47364) {
                              if (code2 < 47336) {
                                if (47309 <= code2 && code2 <= 47335) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47337) {
                                  if (code2 === 47336) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47337 <= code2 && code2 <= 47363) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47365) {
                                if (code2 === 47364) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47392) {
                                  if (47365 <= code2 && code2 <= 47391) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47392) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 47560) {
                          if (code2 < 47476) {
                            if (code2 < 47421) {
                              if (code2 < 47420) {
                                if (47393 <= code2 && code2 <= 47419) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 47420) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 47448) {
                                if (47421 <= code2 && code2 <= 47447) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47449) {
                                  if (code2 === 47448) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47449 <= code2 && code2 <= 47475) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47505) {
                              if (code2 < 47477) {
                                if (code2 === 47476) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47504) {
                                  if (47477 <= code2 && code2 <= 47503) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47504) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47532) {
                                if (47505 <= code2 && code2 <= 47531) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47533) {
                                  if (code2 === 47532) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47533 <= code2 && code2 <= 47559) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47617) {
                            if (code2 < 47588) {
                              if (code2 < 47561) {
                                if (code2 === 47560) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47561 <= code2 && code2 <= 47587) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 47589) {
                                if (code2 === 47588) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47616) {
                                  if (47589 <= code2 && code2 <= 47615) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47616) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47672) {
                              if (code2 < 47644) {
                                if (47617 <= code2 && code2 <= 47643) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47645) {
                                  if (code2 === 47644) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47645 <= code2 && code2 <= 47671) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47673) {
                                if (code2 === 47672) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47700) {
                                  if (47673 <= code2 && code2 <= 47699) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47700) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 48316) {
                      if (code2 < 48008) {
                        if (code2 < 47841) {
                          if (code2 < 47784) {
                            if (code2 < 47729) {
                              if (code2 < 47728) {
                                if (47701 <= code2 && code2 <= 47727) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 47728) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 47756) {
                                if (47729 <= code2 && code2 <= 47755) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47757) {
                                  if (code2 === 47756) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47757 <= code2 && code2 <= 47783) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47812) {
                              if (code2 < 47785) {
                                if (code2 === 47784) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47785 <= code2 && code2 <= 47811) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 47813) {
                                if (code2 === 47812) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47840) {
                                  if (47813 <= code2 && code2 <= 47839) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47840) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47924) {
                            if (code2 < 47869) {
                              if (code2 < 47868) {
                                if (47841 <= code2 && code2 <= 47867) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 47868) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 47896) {
                                if (47869 <= code2 && code2 <= 47895) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47897) {
                                  if (code2 === 47896) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47897 <= code2 && code2 <= 47923) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47953) {
                              if (code2 < 47925) {
                                if (code2 === 47924) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 47952) {
                                  if (47925 <= code2 && code2 <= 47951) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47952) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47980) {
                                if (47953 <= code2 && code2 <= 47979) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 47981) {
                                  if (code2 === 47980) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47981 <= code2 && code2 <= 48007) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 48149) {
                          if (code2 < 48065) {
                            if (code2 < 48036) {
                              if (code2 < 48009) {
                                if (code2 === 48008) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48009 <= code2 && code2 <= 48035) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 48037) {
                                if (code2 === 48036) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48064) {
                                  if (48037 <= code2 && code2 <= 48063) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48064) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48120) {
                              if (code2 < 48092) {
                                if (48065 <= code2 && code2 <= 48091) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48093) {
                                  if (code2 === 48092) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48093 <= code2 && code2 <= 48119) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48121) {
                                if (code2 === 48120) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48148) {
                                  if (48121 <= code2 && code2 <= 48147) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48148) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48232) {
                            if (code2 < 48177) {
                              if (code2 < 48176) {
                                if (48149 <= code2 && code2 <= 48175) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 48176) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 48204) {
                                if (48177 <= code2 && code2 <= 48203) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48205) {
                                  if (code2 === 48204) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48205 <= code2 && code2 <= 48231) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48261) {
                              if (code2 < 48233) {
                                if (code2 === 48232) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48260) {
                                  if (48233 <= code2 && code2 <= 48259) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48260) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48288) {
                                if (48261 <= code2 && code2 <= 48287) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48289) {
                                  if (code2 === 48288) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48289 <= code2 && code2 <= 48315) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 48597) {
                        if (code2 < 48456) {
                          if (code2 < 48373) {
                            if (code2 < 48344) {
                              if (code2 < 48317) {
                                if (code2 === 48316) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48317 <= code2 && code2 <= 48343) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 48345) {
                                if (code2 === 48344) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48372) {
                                  if (48345 <= code2 && code2 <= 48371) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48372) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48401) {
                              if (code2 < 48400) {
                                if (48373 <= code2 && code2 <= 48399) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 48400) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 48428) {
                                if (48401 <= code2 && code2 <= 48427) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48429) {
                                  if (code2 === 48428) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48429 <= code2 && code2 <= 48455) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48513) {
                            if (code2 < 48484) {
                              if (code2 < 48457) {
                                if (code2 === 48456) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48457 <= code2 && code2 <= 48483) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 48485) {
                                if (code2 === 48484) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48512) {
                                  if (48485 <= code2 && code2 <= 48511) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48512) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48568) {
                              if (code2 < 48540) {
                                if (48513 <= code2 && code2 <= 48539) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48541) {
                                  if (code2 === 48540) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48541 <= code2 && code2 <= 48567) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48569) {
                                if (code2 === 48568) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48596) {
                                  if (48569 <= code2 && code2 <= 48595) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48596) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 48764) {
                          if (code2 < 48680) {
                            if (code2 < 48625) {
                              if (code2 < 48624) {
                                if (48597 <= code2 && code2 <= 48623) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 48624) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 48652) {
                                if (48625 <= code2 && code2 <= 48651) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48653) {
                                  if (code2 === 48652) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48653 <= code2 && code2 <= 48679) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48709) {
                              if (code2 < 48681) {
                                if (code2 === 48680) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48708) {
                                  if (48681 <= code2 && code2 <= 48707) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48708) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48736) {
                                if (48709 <= code2 && code2 <= 48735) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48737) {
                                  if (code2 === 48736) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48737 <= code2 && code2 <= 48763) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48821) {
                            if (code2 < 48792) {
                              if (code2 < 48765) {
                                if (code2 === 48764) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48765 <= code2 && code2 <= 48791) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 48793) {
                                if (code2 === 48792) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48820) {
                                  if (48793 <= code2 && code2 <= 48819) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48820) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48876) {
                              if (code2 < 48848) {
                                if (48821 <= code2 && code2 <= 48847) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48849) {
                                  if (code2 === 48848) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48849 <= code2 && code2 <= 48875) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48877) {
                                if (code2 === 48876) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 48904) {
                                  if (48877 <= code2 && code2 <= 48903) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48904) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code2 < 53720) {
                if (code2 < 51312) {
                  if (code2 < 50108) {
                    if (code2 < 49493) {
                      if (code2 < 49212) {
                        if (code2 < 49045) {
                          if (code2 < 48988) {
                            if (code2 < 48933) {
                              if (code2 < 48932) {
                                if (48905 <= code2 && code2 <= 48931) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 48932) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 48960) {
                                if (48933 <= code2 && code2 <= 48959) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 48961) {
                                  if (code2 === 48960) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48961 <= code2 && code2 <= 48987) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49016) {
                              if (code2 < 48989) {
                                if (code2 === 48988) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48989 <= code2 && code2 <= 49015) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 49017) {
                                if (code2 === 49016) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49044) {
                                  if (49017 <= code2 && code2 <= 49043) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49044) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49128) {
                            if (code2 < 49073) {
                              if (code2 < 49072) {
                                if (49045 <= code2 && code2 <= 49071) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 49072) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 49100) {
                                if (49073 <= code2 && code2 <= 49099) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49101) {
                                  if (code2 === 49100) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49101 <= code2 && code2 <= 49127) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49157) {
                              if (code2 < 49129) {
                                if (code2 === 49128) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49156) {
                                  if (49129 <= code2 && code2 <= 49155) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49156) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49184) {
                                if (49157 <= code2 && code2 <= 49183) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49185) {
                                  if (code2 === 49184) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49185 <= code2 && code2 <= 49211) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 49352) {
                          if (code2 < 49269) {
                            if (code2 < 49240) {
                              if (code2 < 49213) {
                                if (code2 === 49212) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49213 <= code2 && code2 <= 49239) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 49241) {
                                if (code2 === 49240) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49268) {
                                  if (49241 <= code2 && code2 <= 49267) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49268) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49297) {
                              if (code2 < 49296) {
                                if (49269 <= code2 && code2 <= 49295) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 49296) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 49324) {
                                if (49297 <= code2 && code2 <= 49323) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49325) {
                                  if (code2 === 49324) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49325 <= code2 && code2 <= 49351) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49409) {
                            if (code2 < 49380) {
                              if (code2 < 49353) {
                                if (code2 === 49352) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49353 <= code2 && code2 <= 49379) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 49381) {
                                if (code2 === 49380) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49408) {
                                  if (49381 <= code2 && code2 <= 49407) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49408) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49464) {
                              if (code2 < 49436) {
                                if (49409 <= code2 && code2 <= 49435) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49437) {
                                  if (code2 === 49436) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49437 <= code2 && code2 <= 49463) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49465) {
                                if (code2 === 49464) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49492) {
                                  if (49465 <= code2 && code2 <= 49491) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49492) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 49800) {
                        if (code2 < 49633) {
                          if (code2 < 49576) {
                            if (code2 < 49521) {
                              if (code2 < 49520) {
                                if (49493 <= code2 && code2 <= 49519) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 49520) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 49548) {
                                if (49521 <= code2 && code2 <= 49547) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49549) {
                                  if (code2 === 49548) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49549 <= code2 && code2 <= 49575) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49604) {
                              if (code2 < 49577) {
                                if (code2 === 49576) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49577 <= code2 && code2 <= 49603) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 49605) {
                                if (code2 === 49604) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49632) {
                                  if (49605 <= code2 && code2 <= 49631) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49632) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49716) {
                            if (code2 < 49661) {
                              if (code2 < 49660) {
                                if (49633 <= code2 && code2 <= 49659) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 49660) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 49688) {
                                if (49661 <= code2 && code2 <= 49687) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49689) {
                                  if (code2 === 49688) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49689 <= code2 && code2 <= 49715) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49745) {
                              if (code2 < 49717) {
                                if (code2 === 49716) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49744) {
                                  if (49717 <= code2 && code2 <= 49743) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49744) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49772) {
                                if (49745 <= code2 && code2 <= 49771) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49773) {
                                  if (code2 === 49772) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49773 <= code2 && code2 <= 49799) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 49941) {
                          if (code2 < 49857) {
                            if (code2 < 49828) {
                              if (code2 < 49801) {
                                if (code2 === 49800) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49801 <= code2 && code2 <= 49827) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 49829) {
                                if (code2 === 49828) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49856) {
                                  if (49829 <= code2 && code2 <= 49855) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49856) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49912) {
                              if (code2 < 49884) {
                                if (49857 <= code2 && code2 <= 49883) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49885) {
                                  if (code2 === 49884) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49885 <= code2 && code2 <= 49911) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49913) {
                                if (code2 === 49912) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 49940) {
                                  if (49913 <= code2 && code2 <= 49939) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49940) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50024) {
                            if (code2 < 49969) {
                              if (code2 < 49968) {
                                if (49941 <= code2 && code2 <= 49967) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 49968) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 49996) {
                                if (49969 <= code2 && code2 <= 49995) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 49997) {
                                  if (code2 === 49996) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49997 <= code2 && code2 <= 50023) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50053) {
                              if (code2 < 50025) {
                                if (code2 === 50024) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50052) {
                                  if (50025 <= code2 && code2 <= 50051) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50052) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50080) {
                                if (50053 <= code2 && code2 <= 50079) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50081) {
                                  if (code2 === 50080) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50081 <= code2 && code2 <= 50107) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 50697) {
                      if (code2 < 50389) {
                        if (code2 < 50248) {
                          if (code2 < 50165) {
                            if (code2 < 50136) {
                              if (code2 < 50109) {
                                if (code2 === 50108) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50109 <= code2 && code2 <= 50135) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 50137) {
                                if (code2 === 50136) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50164) {
                                  if (50137 <= code2 && code2 <= 50163) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50164) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50193) {
                              if (code2 < 50192) {
                                if (50165 <= code2 && code2 <= 50191) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 50192) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 50220) {
                                if (50193 <= code2 && code2 <= 50219) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50221) {
                                  if (code2 === 50220) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50221 <= code2 && code2 <= 50247) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50305) {
                            if (code2 < 50276) {
                              if (code2 < 50249) {
                                if (code2 === 50248) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50249 <= code2 && code2 <= 50275) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 50277) {
                                if (code2 === 50276) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50304) {
                                  if (50277 <= code2 && code2 <= 50303) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50304) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50360) {
                              if (code2 < 50332) {
                                if (50305 <= code2 && code2 <= 50331) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50333) {
                                  if (code2 === 50332) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50333 <= code2 && code2 <= 50359) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50361) {
                                if (code2 === 50360) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50388) {
                                  if (50361 <= code2 && code2 <= 50387) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50388) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 50556) {
                          if (code2 < 50472) {
                            if (code2 < 50417) {
                              if (code2 < 50416) {
                                if (50389 <= code2 && code2 <= 50415) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 50416) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 50444) {
                                if (50417 <= code2 && code2 <= 50443) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50445) {
                                  if (code2 === 50444) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50445 <= code2 && code2 <= 50471) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50501) {
                              if (code2 < 50473) {
                                if (code2 === 50472) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50500) {
                                  if (50473 <= code2 && code2 <= 50499) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50500) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50528) {
                                if (50501 <= code2 && code2 <= 50527) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50529) {
                                  if (code2 === 50528) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50529 <= code2 && code2 <= 50555) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50613) {
                            if (code2 < 50584) {
                              if (code2 < 50557) {
                                if (code2 === 50556) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50557 <= code2 && code2 <= 50583) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 50585) {
                                if (code2 === 50584) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50612) {
                                  if (50585 <= code2 && code2 <= 50611) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50612) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50668) {
                              if (code2 < 50640) {
                                if (50613 <= code2 && code2 <= 50639) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50641) {
                                  if (code2 === 50640) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50641 <= code2 && code2 <= 50667) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50669) {
                                if (code2 === 50668) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50696) {
                                  if (50669 <= code2 && code2 <= 50695) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50696) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 51004) {
                        if (code2 < 50837) {
                          if (code2 < 50780) {
                            if (code2 < 50725) {
                              if (code2 < 50724) {
                                if (50697 <= code2 && code2 <= 50723) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 50724) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 50752) {
                                if (50725 <= code2 && code2 <= 50751) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50753) {
                                  if (code2 === 50752) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50753 <= code2 && code2 <= 50779) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50808) {
                              if (code2 < 50781) {
                                if (code2 === 50780) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50781 <= code2 && code2 <= 50807) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 50809) {
                                if (code2 === 50808) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50836) {
                                  if (50809 <= code2 && code2 <= 50835) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50836) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50920) {
                            if (code2 < 50865) {
                              if (code2 < 50864) {
                                if (50837 <= code2 && code2 <= 50863) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 50864) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 50892) {
                                if (50865 <= code2 && code2 <= 50891) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50893) {
                                  if (code2 === 50892) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50893 <= code2 && code2 <= 50919) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50949) {
                              if (code2 < 50921) {
                                if (code2 === 50920) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 50948) {
                                  if (50921 <= code2 && code2 <= 50947) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50948) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50976) {
                                if (50949 <= code2 && code2 <= 50975) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 50977) {
                                  if (code2 === 50976) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50977 <= code2 && code2 <= 51003) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 51145) {
                          if (code2 < 51061) {
                            if (code2 < 51032) {
                              if (code2 < 51005) {
                                if (code2 === 51004) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51005 <= code2 && code2 <= 51031) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 51033) {
                                if (code2 === 51032) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51060) {
                                  if (51033 <= code2 && code2 <= 51059) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51060) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51116) {
                              if (code2 < 51088) {
                                if (51061 <= code2 && code2 <= 51087) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51089) {
                                  if (code2 === 51088) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51089 <= code2 && code2 <= 51115) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51117) {
                                if (code2 === 51116) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51144) {
                                  if (51117 <= code2 && code2 <= 51143) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51144) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51228) {
                            if (code2 < 51173) {
                              if (code2 < 51172) {
                                if (51145 <= code2 && code2 <= 51171) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 51172) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 51200) {
                                if (51173 <= code2 && code2 <= 51199) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51201) {
                                  if (code2 === 51200) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51201 <= code2 && code2 <= 51227) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51257) {
                              if (code2 < 51229) {
                                if (code2 === 51228) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51256) {
                                  if (51229 <= code2 && code2 <= 51255) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51256) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51284) {
                                if (51257 <= code2 && code2 <= 51283) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51285) {
                                  if (code2 === 51284) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51285 <= code2 && code2 <= 51311) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 52516) {
                    if (code2 < 51901) {
                      if (code2 < 51593) {
                        if (code2 < 51452) {
                          if (code2 < 51369) {
                            if (code2 < 51340) {
                              if (code2 < 51313) {
                                if (code2 === 51312) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51313 <= code2 && code2 <= 51339) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 51341) {
                                if (code2 === 51340) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51368) {
                                  if (51341 <= code2 && code2 <= 51367) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51368) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51397) {
                              if (code2 < 51396) {
                                if (51369 <= code2 && code2 <= 51395) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 51396) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 51424) {
                                if (51397 <= code2 && code2 <= 51423) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51425) {
                                  if (code2 === 51424) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51425 <= code2 && code2 <= 51451) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51509) {
                            if (code2 < 51480) {
                              if (code2 < 51453) {
                                if (code2 === 51452) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51453 <= code2 && code2 <= 51479) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 51481) {
                                if (code2 === 51480) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51508) {
                                  if (51481 <= code2 && code2 <= 51507) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51508) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51564) {
                              if (code2 < 51536) {
                                if (51509 <= code2 && code2 <= 51535) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51537) {
                                  if (code2 === 51536) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51537 <= code2 && code2 <= 51563) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51565) {
                                if (code2 === 51564) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51592) {
                                  if (51565 <= code2 && code2 <= 51591) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51592) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 51760) {
                          if (code2 < 51676) {
                            if (code2 < 51621) {
                              if (code2 < 51620) {
                                if (51593 <= code2 && code2 <= 51619) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 51620) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 51648) {
                                if (51621 <= code2 && code2 <= 51647) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51649) {
                                  if (code2 === 51648) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51649 <= code2 && code2 <= 51675) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51705) {
                              if (code2 < 51677) {
                                if (code2 === 51676) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51704) {
                                  if (51677 <= code2 && code2 <= 51703) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51704) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51732) {
                                if (51705 <= code2 && code2 <= 51731) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51733) {
                                  if (code2 === 51732) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51733 <= code2 && code2 <= 51759) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51817) {
                            if (code2 < 51788) {
                              if (code2 < 51761) {
                                if (code2 === 51760) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51761 <= code2 && code2 <= 51787) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 51789) {
                                if (code2 === 51788) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51816) {
                                  if (51789 <= code2 && code2 <= 51815) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51816) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51872) {
                              if (code2 < 51844) {
                                if (51817 <= code2 && code2 <= 51843) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51845) {
                                  if (code2 === 51844) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51845 <= code2 && code2 <= 51871) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51873) {
                                if (code2 === 51872) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 51900) {
                                  if (51873 <= code2 && code2 <= 51899) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51900) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 52208) {
                        if (code2 < 52041) {
                          if (code2 < 51984) {
                            if (code2 < 51929) {
                              if (code2 < 51928) {
                                if (51901 <= code2 && code2 <= 51927) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 51928) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 51956) {
                                if (51929 <= code2 && code2 <= 51955) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 51957) {
                                  if (code2 === 51956) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51957 <= code2 && code2 <= 51983) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52012) {
                              if (code2 < 51985) {
                                if (code2 === 51984) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51985 <= code2 && code2 <= 52011) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 52013) {
                                if (code2 === 52012) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52040) {
                                  if (52013 <= code2 && code2 <= 52039) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52040) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52124) {
                            if (code2 < 52069) {
                              if (code2 < 52068) {
                                if (52041 <= code2 && code2 <= 52067) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 52068) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 52096) {
                                if (52069 <= code2 && code2 <= 52095) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52097) {
                                  if (code2 === 52096) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52097 <= code2 && code2 <= 52123) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52153) {
                              if (code2 < 52125) {
                                if (code2 === 52124) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52152) {
                                  if (52125 <= code2 && code2 <= 52151) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52152) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52180) {
                                if (52153 <= code2 && code2 <= 52179) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52181) {
                                  if (code2 === 52180) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52181 <= code2 && code2 <= 52207) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 52349) {
                          if (code2 < 52265) {
                            if (code2 < 52236) {
                              if (code2 < 52209) {
                                if (code2 === 52208) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52209 <= code2 && code2 <= 52235) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 52237) {
                                if (code2 === 52236) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52264) {
                                  if (52237 <= code2 && code2 <= 52263) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52264) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52320) {
                              if (code2 < 52292) {
                                if (52265 <= code2 && code2 <= 52291) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52293) {
                                  if (code2 === 52292) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52293 <= code2 && code2 <= 52319) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52321) {
                                if (code2 === 52320) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52348) {
                                  if (52321 <= code2 && code2 <= 52347) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52348) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52432) {
                            if (code2 < 52377) {
                              if (code2 < 52376) {
                                if (52349 <= code2 && code2 <= 52375) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 52376) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 52404) {
                                if (52377 <= code2 && code2 <= 52403) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52405) {
                                  if (code2 === 52404) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52405 <= code2 && code2 <= 52431) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52461) {
                              if (code2 < 52433) {
                                if (code2 === 52432) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52460) {
                                  if (52433 <= code2 && code2 <= 52459) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52460) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52488) {
                                if (52461 <= code2 && code2 <= 52487) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52489) {
                                  if (code2 === 52488) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52489 <= code2 && code2 <= 52515) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 53105) {
                      if (code2 < 52797) {
                        if (code2 < 52656) {
                          if (code2 < 52573) {
                            if (code2 < 52544) {
                              if (code2 < 52517) {
                                if (code2 === 52516) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52517 <= code2 && code2 <= 52543) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 52545) {
                                if (code2 === 52544) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52572) {
                                  if (52545 <= code2 && code2 <= 52571) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52572) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52601) {
                              if (code2 < 52600) {
                                if (52573 <= code2 && code2 <= 52599) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 52600) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 52628) {
                                if (52601 <= code2 && code2 <= 52627) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52629) {
                                  if (code2 === 52628) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52629 <= code2 && code2 <= 52655) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52713) {
                            if (code2 < 52684) {
                              if (code2 < 52657) {
                                if (code2 === 52656) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52657 <= code2 && code2 <= 52683) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 52685) {
                                if (code2 === 52684) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52712) {
                                  if (52685 <= code2 && code2 <= 52711) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52712) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52768) {
                              if (code2 < 52740) {
                                if (52713 <= code2 && code2 <= 52739) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52741) {
                                  if (code2 === 52740) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52741 <= code2 && code2 <= 52767) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52769) {
                                if (code2 === 52768) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52796) {
                                  if (52769 <= code2 && code2 <= 52795) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52796) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 52964) {
                          if (code2 < 52880) {
                            if (code2 < 52825) {
                              if (code2 < 52824) {
                                if (52797 <= code2 && code2 <= 52823) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 52824) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 52852) {
                                if (52825 <= code2 && code2 <= 52851) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52853) {
                                  if (code2 === 52852) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52853 <= code2 && code2 <= 52879) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52909) {
                              if (code2 < 52881) {
                                if (code2 === 52880) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 52908) {
                                  if (52881 <= code2 && code2 <= 52907) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52908) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52936) {
                                if (52909 <= code2 && code2 <= 52935) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 52937) {
                                  if (code2 === 52936) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52937 <= code2 && code2 <= 52963) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53021) {
                            if (code2 < 52992) {
                              if (code2 < 52965) {
                                if (code2 === 52964) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52965 <= code2 && code2 <= 52991) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 52993) {
                                if (code2 === 52992) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53020) {
                                  if (52993 <= code2 && code2 <= 53019) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53020) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53076) {
                              if (code2 < 53048) {
                                if (53021 <= code2 && code2 <= 53047) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53049) {
                                  if (code2 === 53048) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53049 <= code2 && code2 <= 53075) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53077) {
                                if (code2 === 53076) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53104) {
                                  if (53077 <= code2 && code2 <= 53103) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53104) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 53412) {
                        if (code2 < 53245) {
                          if (code2 < 53188) {
                            if (code2 < 53133) {
                              if (code2 < 53132) {
                                if (53105 <= code2 && code2 <= 53131) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 53132) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 53160) {
                                if (53133 <= code2 && code2 <= 53159) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53161) {
                                  if (code2 === 53160) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53161 <= code2 && code2 <= 53187) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53216) {
                              if (code2 < 53189) {
                                if (code2 === 53188) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53189 <= code2 && code2 <= 53215) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 53217) {
                                if (code2 === 53216) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53244) {
                                  if (53217 <= code2 && code2 <= 53243) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53244) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53328) {
                            if (code2 < 53273) {
                              if (code2 < 53272) {
                                if (53245 <= code2 && code2 <= 53271) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 53272) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 53300) {
                                if (53273 <= code2 && code2 <= 53299) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53301) {
                                  if (code2 === 53300) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53301 <= code2 && code2 <= 53327) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53357) {
                              if (code2 < 53329) {
                                if (code2 === 53328) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53356) {
                                  if (53329 <= code2 && code2 <= 53355) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53356) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53384) {
                                if (53357 <= code2 && code2 <= 53383) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53385) {
                                  if (code2 === 53384) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53385 <= code2 && code2 <= 53411) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 53553) {
                          if (code2 < 53469) {
                            if (code2 < 53440) {
                              if (code2 < 53413) {
                                if (code2 === 53412) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53413 <= code2 && code2 <= 53439) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 53441) {
                                if (code2 === 53440) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53468) {
                                  if (53441 <= code2 && code2 <= 53467) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53468) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53524) {
                              if (code2 < 53496) {
                                if (53469 <= code2 && code2 <= 53495) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53497) {
                                  if (code2 === 53496) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53497 <= code2 && code2 <= 53523) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53525) {
                                if (code2 === 53524) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53552) {
                                  if (53525 <= code2 && code2 <= 53551) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53552) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53636) {
                            if (code2 < 53581) {
                              if (code2 < 53580) {
                                if (53553 <= code2 && code2 <= 53579) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 53580) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 53608) {
                                if (53581 <= code2 && code2 <= 53607) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53609) {
                                  if (code2 === 53608) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53609 <= code2 && code2 <= 53635) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53665) {
                              if (code2 < 53637) {
                                if (code2 === 53636) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53664) {
                                  if (53637 <= code2 && code2 <= 53663) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53664) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53692) {
                                if (53665 <= code2 && code2 <= 53691) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53693) {
                                  if (code2 === 53692) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53693 <= code2 && code2 <= 53719) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 70459) {
                  if (code2 < 54897) {
                    if (code2 < 54308) {
                      if (code2 < 54001) {
                        if (code2 < 53860) {
                          if (code2 < 53777) {
                            if (code2 < 53748) {
                              if (code2 < 53721) {
                                if (code2 === 53720) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53721 <= code2 && code2 <= 53747) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 53749) {
                                if (code2 === 53748) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53776) {
                                  if (53749 <= code2 && code2 <= 53775) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53776) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53805) {
                              if (code2 < 53804) {
                                if (53777 <= code2 && code2 <= 53803) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 53804) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 53832) {
                                if (53805 <= code2 && code2 <= 53831) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53833) {
                                  if (code2 === 53832) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53833 <= code2 && code2 <= 53859) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53917) {
                            if (code2 < 53888) {
                              if (code2 < 53861) {
                                if (code2 === 53860) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53861 <= code2 && code2 <= 53887) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 53889) {
                                if (code2 === 53888) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 53916) {
                                  if (53889 <= code2 && code2 <= 53915) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53916) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53972) {
                              if (code2 < 53944) {
                                if (53917 <= code2 && code2 <= 53943) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 53945) {
                                  if (code2 === 53944) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53945 <= code2 && code2 <= 53971) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53973) {
                                if (code2 === 53972) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54e3) {
                                  if (53973 <= code2 && code2 <= 53999) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54e3) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 54141) {
                          if (code2 < 54084) {
                            if (code2 < 54029) {
                              if (code2 < 54028) {
                                if (54001 <= code2 && code2 <= 54027) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 54028) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 54056) {
                                if (54029 <= code2 && code2 <= 54055) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54057) {
                                  if (code2 === 54056) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54057 <= code2 && code2 <= 54083) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54112) {
                              if (code2 < 54085) {
                                if (code2 === 54084) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54085 <= code2 && code2 <= 54111) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 54113) {
                                if (code2 === 54112) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54140) {
                                  if (54113 <= code2 && code2 <= 54139) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54140) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54224) {
                            if (code2 < 54169) {
                              if (code2 < 54168) {
                                if (54141 <= code2 && code2 <= 54167) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 54168) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 54196) {
                                if (54169 <= code2 && code2 <= 54195) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54197) {
                                  if (code2 === 54196) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54197 <= code2 && code2 <= 54223) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54253) {
                              if (code2 < 54225) {
                                if (code2 === 54224) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54252) {
                                  if (54225 <= code2 && code2 <= 54251) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54252) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54280) {
                                if (54253 <= code2 && code2 <= 54279) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54281) {
                                  if (code2 === 54280) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54281 <= code2 && code2 <= 54307) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 54589) {
                        if (code2 < 54448) {
                          if (code2 < 54365) {
                            if (code2 < 54336) {
                              if (code2 < 54309) {
                                if (code2 === 54308) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54309 <= code2 && code2 <= 54335) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 54337) {
                                if (code2 === 54336) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54364) {
                                  if (54337 <= code2 && code2 <= 54363) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54364) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54393) {
                              if (code2 < 54392) {
                                if (54365 <= code2 && code2 <= 54391) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 54392) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 54420) {
                                if (54393 <= code2 && code2 <= 54419) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54421) {
                                  if (code2 === 54420) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54421 <= code2 && code2 <= 54447) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54505) {
                            if (code2 < 54476) {
                              if (code2 < 54449) {
                                if (code2 === 54448) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54449 <= code2 && code2 <= 54475) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 54477) {
                                if (code2 === 54476) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54504) {
                                  if (54477 <= code2 && code2 <= 54503) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54504) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54560) {
                              if (code2 < 54532) {
                                if (54505 <= code2 && code2 <= 54531) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54533) {
                                  if (code2 === 54532) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54533 <= code2 && code2 <= 54559) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54561) {
                                if (code2 === 54560) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54588) {
                                  if (54561 <= code2 && code2 <= 54587) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54588) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 54756) {
                          if (code2 < 54672) {
                            if (code2 < 54617) {
                              if (code2 < 54616) {
                                if (54589 <= code2 && code2 <= 54615) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 54616) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 54644) {
                                if (54617 <= code2 && code2 <= 54643) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54645) {
                                  if (code2 === 54644) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54645 <= code2 && code2 <= 54671) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54701) {
                              if (code2 < 54673) {
                                if (code2 === 54672) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54700) {
                                  if (54673 <= code2 && code2 <= 54699) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54700) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54728) {
                                if (54701 <= code2 && code2 <= 54727) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54729) {
                                  if (code2 === 54728) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54729 <= code2 && code2 <= 54755) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54813) {
                            if (code2 < 54784) {
                              if (code2 < 54757) {
                                if (code2 === 54756) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54757 <= code2 && code2 <= 54783) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 54785) {
                                if (code2 === 54784) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54812) {
                                  if (54785 <= code2 && code2 <= 54811) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54812) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54868) {
                              if (code2 < 54840) {
                                if (54813 <= code2 && code2 <= 54839) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54841) {
                                  if (code2 === 54840) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54841 <= code2 && code2 <= 54867) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54869) {
                                if (code2 === 54868) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 54896) {
                                  if (54869 <= code2 && code2 <= 54895) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54896) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 69632) {
                      if (code2 < 55216) {
                        if (code2 < 55037) {
                          if (code2 < 54980) {
                            if (code2 < 54925) {
                              if (code2 < 54924) {
                                if (54897 <= code2 && code2 <= 54923) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 54924) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 54952) {
                                if (54925 <= code2 && code2 <= 54951) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 54953) {
                                  if (code2 === 54952) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54953 <= code2 && code2 <= 54979) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 55008) {
                              if (code2 < 54981) {
                                if (code2 === 54980) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54981 <= code2 && code2 <= 55007) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code2 < 55009) {
                                if (code2 === 55008) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 55036) {
                                  if (55009 <= code2 && code2 <= 55035) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 55036) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 55120) {
                            if (code2 < 55065) {
                              if (code2 < 55064) {
                                if (55037 <= code2 && code2 <= 55063) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 === 55064) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code2 < 55092) {
                                if (55065 <= code2 && code2 <= 55091) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 55093) {
                                  if (code2 === 55092) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (55093 <= code2 && code2 <= 55119) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 55149) {
                              if (code2 < 55121) {
                                if (code2 === 55120) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code2 < 55148) {
                                  if (55121 <= code2 && code2 <= 55147) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 55148) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55176) {
                                if (55149 <= code2 && code2 <= 55175) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code2 < 55177) {
                                  if (code2 === 55176) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (55177 <= code2 && code2 <= 55203) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 68097) {
                          if (code2 < 65279) {
                            if (code2 < 64286) {
                              if (code2 < 55243) {
                                if (55216 <= code2 && code2 <= 55238) {
                                  return boundaries_1.CLUSTER_BREAK.V;
                                }
                              } else {
                                if (55243 <= code2 && code2 <= 55291) {
                                  return boundaries_1.CLUSTER_BREAK.T;
                                }
                              }
                            } else {
                              if (code2 < 65024) {
                                if (code2 === 64286) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 65056) {
                                  if (65024 <= code2 && code2 <= 65039) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (65056 <= code2 && code2 <= 65071) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 66045) {
                              if (code2 < 65438) {
                                if (code2 === 65279) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 < 65520) {
                                  if (65438 <= code2 && code2 <= 65439) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (65520 <= code2 && code2 <= 65531) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 66272) {
                                if (code2 === 66045) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 66422) {
                                  if (code2 === 66272) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (66422 <= code2 && code2 <= 66426) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 68325) {
                            if (code2 < 68108) {
                              if (code2 < 68101) {
                                if (68097 <= code2 && code2 <= 68099) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (68101 <= code2 && code2 <= 68102) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 68152) {
                                if (68108 <= code2 && code2 <= 68111) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 68159) {
                                  if (68152 <= code2 && code2 <= 68154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 68159) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 69373) {
                              if (code2 < 68900) {
                                if (68325 <= code2 && code2 <= 68326) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 69291) {
                                  if (68900 <= code2 && code2 <= 68903) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69291 <= code2 && code2 <= 69292) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69446) {
                                if (69373 <= code2 && code2 <= 69375) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 69506) {
                                  if (69446 <= code2 && code2 <= 69456) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69506 <= code2 && code2 <= 69509) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 70016) {
                        if (code2 < 69815) {
                          if (code2 < 69747) {
                            if (code2 < 69634) {
                              if (code2 === 69632) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 69633) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 69688) {
                                if (code2 === 69634) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 69744) {
                                  if (69688 <= code2 && code2 <= 69702) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 69744) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 69762) {
                              if (code2 < 69759) {
                                if (69747 <= code2 && code2 <= 69748) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (69759 <= code2 && code2 <= 69761) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 69808) {
                                if (code2 === 69762) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 69811) {
                                  if (69808 <= code2 && code2 <= 69810) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (69811 <= code2 && code2 <= 69814) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 69888) {
                            if (code2 < 69821) {
                              if (code2 < 69817) {
                                if (69815 <= code2 && code2 <= 69816) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (69817 <= code2 && code2 <= 69818) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 69826) {
                                if (code2 === 69821) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code2 === 69826) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 69837) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 69933) {
                              if (code2 < 69927) {
                                if (69888 <= code2 && code2 <= 69890) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 69932) {
                                  if (69927 <= code2 && code2 <= 69931) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 69932) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69957) {
                                if (69933 <= code2 && code2 <= 69940) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70003) {
                                  if (69957 <= code2 && code2 <= 69958) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 70194) {
                          if (code2 < 70082) {
                            if (code2 < 70067) {
                              if (code2 < 70018) {
                                if (70016 <= code2 && code2 <= 70017) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 70018) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 70070) {
                                if (70067 <= code2 && code2 <= 70069) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 70079) {
                                  if (70070 <= code2 && code2 <= 70078) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70079 <= code2 && code2 <= 70080) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70095) {
                              if (code2 < 70089) {
                                if (70082 <= code2 && code2 <= 70083) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code2 < 70094) {
                                  if (70089 <= code2 && code2 <= 70092) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70094) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70188) {
                                if (code2 === 70095) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70191) {
                                  if (70188 <= code2 && code2 <= 70190) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70191 <= code2 && code2 <= 70193) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 70209) {
                            if (code2 < 70197) {
                              if (code2 < 70196) {
                                if (70194 <= code2 && code2 <= 70195) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 70196) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 70198) {
                                if (code2 === 70197) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 70206) {
                                  if (70198 <= code2 && code2 <= 70199) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70206) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70371) {
                              if (code2 < 70367) {
                                if (code2 === 70209) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70368) {
                                  if (code2 === 70367) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70368 <= code2 && code2 <= 70370) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70400) {
                                if (70371 <= code2 && code2 <= 70378) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70402) {
                                  if (70400 <= code2 && code2 <= 70401) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70402 <= code2 && code2 <= 70403) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 72343) {
                    if (code2 < 71339) {
                      if (code2 < 70841) {
                        if (code2 < 70512) {
                          if (code2 < 70471) {
                            if (code2 < 70463) {
                              if (code2 < 70462) {
                                if (70459 <= code2 && code2 <= 70460) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 70462) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 70464) {
                                if (code2 === 70463) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 70465) {
                                  if (code2 === 70464) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70465 <= code2 && code2 <= 70468) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70487) {
                              if (code2 < 70475) {
                                if (70471 <= code2 && code2 <= 70472) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (70475 <= code2 && code2 <= 70477) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 70498) {
                                if (code2 === 70487) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70502) {
                                  if (70498 <= code2 && code2 <= 70499) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70502 <= code2 && code2 <= 70508) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 70725) {
                            if (code2 < 70712) {
                              if (code2 < 70709) {
                                if (70512 <= code2 && code2 <= 70516) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (70709 <= code2 && code2 <= 70711) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 70720) {
                                if (70712 <= code2 && code2 <= 70719) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70722) {
                                  if (70720 <= code2 && code2 <= 70721) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70722 <= code2 && code2 <= 70724) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70832) {
                              if (code2 < 70726) {
                                if (code2 === 70725) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 70726) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 70750) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 70833) {
                                if (code2 === 70832) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70835) {
                                  if (70833 <= code2 && code2 <= 70834) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70835 <= code2 && code2 <= 70840) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 71096) {
                          if (code2 < 70847) {
                            if (code2 < 70843) {
                              if (code2 === 70841) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 70842) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 70845) {
                                if (70843 <= code2 && code2 <= 70844) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 70845) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 70846) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          } else {
                            if (code2 < 71087) {
                              if (code2 < 70849) {
                                if (70847 <= code2 && code2 <= 70848) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70850) {
                                  if (code2 === 70849) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70850 <= code2 && code2 <= 70851) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71088) {
                                if (code2 === 71087) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71090) {
                                  if (71088 <= code2 && code2 <= 71089) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71090 <= code2 && code2 <= 71093) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 71216) {
                            if (code2 < 71102) {
                              if (code2 < 71100) {
                                if (71096 <= code2 && code2 <= 71099) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (71100 <= code2 && code2 <= 71101) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 71103) {
                                if (code2 === 71102) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 71132) {
                                  if (71103 <= code2 && code2 <= 71104) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71132 <= code2 && code2 <= 71133) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71229) {
                              if (code2 < 71219) {
                                if (71216 <= code2 && code2 <= 71218) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 71227) {
                                  if (71219 <= code2 && code2 <= 71226) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71227 <= code2 && code2 <= 71228) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71230) {
                                if (code2 === 71229) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71231) {
                                  if (code2 === 71230) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71231 <= code2 && code2 <= 71232) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 71999) {
                        if (code2 < 71463) {
                          if (code2 < 71350) {
                            if (code2 < 71341) {
                              if (code2 === 71339) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (code2 === 71340) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code2 < 71342) {
                                if (code2 === 71341) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71344) {
                                  if (71342 <= code2 && code2 <= 71343) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71344 <= code2 && code2 <= 71349) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71453) {
                              if (code2 === 71350) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 71351) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 71458) {
                                if (71453 <= code2 && code2 <= 71455) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71462) {
                                  if (71458 <= code2 && code2 <= 71461) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 71462) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 71984) {
                            if (code2 < 71727) {
                              if (code2 < 71724) {
                                if (71463 <= code2 && code2 <= 71467) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (71724 <= code2 && code2 <= 71726) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 71736) {
                                if (71727 <= code2 && code2 <= 71735) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71737) {
                                  if (code2 === 71736) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71737 <= code2 && code2 <= 71738) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71995) {
                              if (code2 < 71985) {
                                if (code2 === 71984) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71991) {
                                  if (71985 <= code2 && code2 <= 71989) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71991 <= code2 && code2 <= 71992) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71997) {
                                if (71995 <= code2 && code2 <= 71996) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 71997) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 71998) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 72193) {
                          if (code2 < 72145) {
                            if (code2 < 72001) {
                              if (code2 === 71999) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                              if (code2 === 72e3) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code2 < 72002) {
                                if (code2 === 72001) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code2 === 72002) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 72003) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 72156) {
                              if (code2 < 72148) {
                                if (72145 <= code2 && code2 <= 72147) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 72154) {
                                  if (72148 <= code2 && code2 <= 72151) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72154 <= code2 && code2 <= 72155) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72160) {
                                if (72156 <= code2 && code2 <= 72159) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 === 72160) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 72164) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 72263) {
                            if (code2 < 72249) {
                              if (code2 < 72243) {
                                if (72193 <= code2 && code2 <= 72202) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (72243 <= code2 && code2 <= 72248) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 72250) {
                                if (code2 === 72249) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 72251) {
                                  if (code2 === 72250) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (72251 <= code2 && code2 <= 72254) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 72281) {
                              if (code2 < 72273) {
                                if (code2 === 72263) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 72279) {
                                  if (72273 <= code2 && code2 <= 72278) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72279 <= code2 && code2 <= 72280) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72324) {
                                if (72281 <= code2 && code2 <= 72283) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 72330) {
                                  if (72324 <= code2 && code2 <= 72329) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (72330 <= code2 && code2 <= 72342) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 94033) {
                      if (code2 < 73104) {
                        if (code2 < 72881) {
                          if (code2 < 72766) {
                            if (code2 < 72751) {
                              if (code2 < 72344) {
                                if (code2 === 72343) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (72344 <= code2 && code2 <= 72345) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 72752) {
                                if (code2 === 72751) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 72760) {
                                  if (72752 <= code2 && code2 <= 72758) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72760 <= code2 && code2 <= 72765) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 72850) {
                              if (code2 === 72766) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (code2 === 72767) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code2 < 72873) {
                                if (72850 <= code2 && code2 <= 72871) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 72874) {
                                  if (code2 === 72873) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72874 <= code2 && code2 <= 72880) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 73018) {
                            if (code2 < 72884) {
                              if (code2 < 72882) {
                                if (code2 === 72881) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (72882 <= code2 && code2 <= 72883) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 72885) {
                                if (code2 === 72884) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 73009) {
                                  if (72885 <= code2 && code2 <= 72886) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73009 <= code2 && code2 <= 73014) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 73030) {
                              if (code2 < 73020) {
                                if (code2 === 73018) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 73023) {
                                  if (73020 <= code2 && code2 <= 73021) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73023 <= code2 && code2 <= 73029) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73031) {
                                if (code2 === 73030) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code2 < 73098) {
                                  if (code2 === 73031) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73098 <= code2 && code2 <= 73102) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 73526) {
                          if (code2 < 73459) {
                            if (code2 < 73109) {
                              if (code2 < 73107) {
                                if (73104 <= code2 && code2 <= 73105) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (73107 <= code2 && code2 <= 73108) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 73110) {
                                if (code2 === 73109) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 73110) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 73111) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 73474) {
                              if (code2 < 73461) {
                                if (73459 <= code2 && code2 <= 73460) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 73472) {
                                  if (73461 <= code2 && code2 <= 73462) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (73472 <= code2 && code2 <= 73473) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73475) {
                                if (code2 === 73474) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code2 < 73524) {
                                  if (code2 === 73475) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (73524 <= code2 && code2 <= 73525) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 78896) {
                            if (code2 < 73536) {
                              if (code2 < 73534) {
                                if (73526 <= code2 && code2 <= 73530) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (73534 <= code2 && code2 <= 73535) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 73537) {
                                if (code2 === 73536) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 73537) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 73538) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code2 < 92912) {
                              if (code2 < 78912) {
                                if (78896 <= code2 && code2 <= 78911) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 < 78919) {
                                  if (code2 === 78912) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (78919 <= code2 && code2 <= 78933) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 92976) {
                                if (92912 <= code2 && code2 <= 92916) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 94031) {
                                  if (92976 <= code2 && code2 <= 92982) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 94031) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 121476) {
                        if (code2 < 119143) {
                          if (code2 < 113824) {
                            if (code2 < 94180) {
                              if (code2 < 94095) {
                                if (94033 <= code2 && code2 <= 94087) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (94095 <= code2 && code2 <= 94098) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 94192) {
                                if (code2 === 94180) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 113821) {
                                  if (94192 <= code2 && code2 <= 94193) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (113821 <= code2 && code2 <= 113822) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 118576) {
                              if (code2 < 118528) {
                                if (113824 <= code2 && code2 <= 113827) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (118528 <= code2 && code2 <= 118573) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 119141) {
                                if (118576 <= code2 && code2 <= 118598) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 119141) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 119142) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 119173) {
                            if (code2 < 119150) {
                              if (code2 < 119149) {
                                if (119143 <= code2 && code2 <= 119145) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 === 119149) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code2 < 119155) {
                                if (119150 <= code2 && code2 <= 119154) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 119163) {
                                  if (119155 <= code2 && code2 <= 119162) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (119163 <= code2 && code2 <= 119170) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 121344) {
                              if (code2 < 119210) {
                                if (119173 <= code2 && code2 <= 119179) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 119362) {
                                  if (119210 <= code2 && code2 <= 119213) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (119362 <= code2 && code2 <= 119364) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 121403) {
                                if (121344 <= code2 && code2 <= 121398) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 121461) {
                                  if (121403 <= code2 && code2 <= 121452) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 121461) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 123628) {
                          if (code2 < 122907) {
                            if (code2 < 121505) {
                              if (code2 < 121499) {
                                if (code2 === 121476) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (121499 <= code2 && code2 <= 121503) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 122880) {
                                if (121505 <= code2 && code2 <= 121519) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 122888) {
                                  if (122880 <= code2 && code2 <= 122886) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (122888 <= code2 && code2 <= 122904) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 123023) {
                              if (code2 < 122915) {
                                if (122907 <= code2 && code2 <= 122913) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 122918) {
                                  if (122915 <= code2 && code2 <= 122916) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (122918 <= code2 && code2 <= 122922) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 123184) {
                                if (code2 === 123023) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 123566) {
                                  if (123184 <= code2 && code2 <= 123190) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 123566) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 127995) {
                            if (code2 < 125136) {
                              if (code2 < 124140) {
                                if (123628 <= code2 && code2 <= 123631) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (124140 <= code2 && code2 <= 124143) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code2 < 125252) {
                                if (125136 <= code2 && code2 <= 125142) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 127462) {
                                  if (125252 <= code2 && code2 <= 125258) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (127462 <= code2 && code2 <= 127487) {
                                    return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 917632) {
                              if (code2 < 917504) {
                                if (127995 <= code2 && code2 <= 127999) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 917536) {
                                  if (917504 <= code2 && code2 <= 917535) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (917536 <= code2 && code2 <= 917631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 917760) {
                                if (917632 <= code2 && code2 <= 917759) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code2 < 918e3) {
                                  if (917760 <= code2 && code2 <= 917999) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (918e3 <= code2 && code2 <= 921599) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return boundaries_1.CLUSTER_BREAK.OTHER;
          }
          static getEmojiProperty(code2) {
            if (code2 < 10160) {
              if (code2 < 9728) {
                if (code2 < 9e3) {
                  if (code2 < 8482) {
                    if (code2 < 8252) {
                      if (code2 === 169) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 174) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code2 === 8252) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 8265) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  } else {
                    if (code2 < 8596) {
                      if (code2 === 8482) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 8505) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code2 < 8617) {
                        if (8596 <= code2 && code2 <= 8601) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 8986) {
                          if (8617 <= code2 && code2 <= 8618) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (8986 <= code2 && code2 <= 8987) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 9410) {
                    if (code2 < 9167) {
                      if (code2 === 9e3) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 9096) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code2 < 9193) {
                        if (code2 === 9167) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 9208) {
                          if (9193 <= code2 && code2 <= 9203) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9208 <= code2 && code2 <= 9210) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 9654) {
                      if (code2 < 9642) {
                        if (code2 === 9410) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (9642 <= code2 && code2 <= 9643) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 9664) {
                        if (code2 === 9654) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 9723) {
                          if (code2 === 9664) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9723 <= code2 && code2 <= 9726) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 10035) {
                  if (code2 < 10004) {
                    if (code2 < 9748) {
                      if (code2 < 9735) {
                        if (9728 <= code2 && code2 <= 9733) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (9735 <= code2 && code2 <= 9746) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 9872) {
                        if (9748 <= code2 && code2 <= 9861) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 9992) {
                          if (9872 <= code2 && code2 <= 9989) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9992 <= code2 && code2 <= 10002) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 10013) {
                      if (code2 === 10004) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 10006) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code2 < 10017) {
                        if (code2 === 10013) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 10017) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10024) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 10067) {
                    if (code2 < 10055) {
                      if (code2 < 10052) {
                        if (10035 <= code2 && code2 <= 10036) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 10052) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 10060) {
                        if (code2 === 10055) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 10060) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10062) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  } else {
                    if (code2 < 10083) {
                      if (code2 < 10071) {
                        if (10067 <= code2 && code2 <= 10069) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 10071) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 10133) {
                        if (10083 <= code2 && code2 <= 10087) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 10145) {
                          if (10133 <= code2 && code2 <= 10135) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10145) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code2 < 127489) {
                if (code2 < 12951) {
                  if (code2 < 11035) {
                    if (code2 < 10548) {
                      if (code2 === 10160) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 10175) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code2 < 11013) {
                        if (10548 <= code2 && code2 <= 10549) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (11013 <= code2 && code2 <= 11015) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  } else {
                    if (code2 < 11093) {
                      if (code2 < 11088) {
                        if (11035 <= code2 && code2 <= 11036) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 11088) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 12336) {
                        if (code2 === 11093) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 12336) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 12349) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 127340) {
                    if (code2 < 126976) {
                      if (code2 === 12951) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (code2 === 12953) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code2 < 127245) {
                        if (126976 <= code2 && code2 <= 127231) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 127279) {
                          if (127245 <= code2 && code2 <= 127247) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 127279) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 127374) {
                      if (code2 < 127358) {
                        if (127340 <= code2 && code2 <= 127345) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (127358 <= code2 && code2 <= 127359) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 127377) {
                        if (code2 === 127374) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 127405) {
                          if (127377 <= code2 && code2 <= 127386) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127405 <= code2 && code2 <= 127461) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 128981) {
                  if (code2 < 127561) {
                    if (code2 < 127535) {
                      if (code2 < 127514) {
                        if (127489 <= code2 && code2 <= 127503) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 127514) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 127538) {
                        if (code2 === 127535) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 127548) {
                          if (127538 <= code2 && code2 <= 127546) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127548 <= code2 && code2 <= 127551) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 128326) {
                      if (code2 < 128e3) {
                        if (127561 <= code2 && code2 <= 127994) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (128e3 <= code2 && code2 <= 128317) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 128640) {
                        if (128326 <= code2 && code2 <= 128591) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 128884) {
                          if (128640 <= code2 && code2 <= 128767) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (128884 <= code2 && code2 <= 128895) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 129198) {
                    if (code2 < 129096) {
                      if (code2 < 129036) {
                        if (128981 <= code2 && code2 <= 129023) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (129036 <= code2 && code2 <= 129039) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 129114) {
                        if (129096 <= code2 && code2 <= 129103) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 129160) {
                          if (129114 <= code2 && code2 <= 129119) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129160 <= code2 && code2 <= 129167) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 129340) {
                      if (code2 < 129292) {
                        if (129198 <= code2 && code2 <= 129279) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (129292 <= code2 && code2 <= 129338) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 129351) {
                        if (129340 <= code2 && code2 <= 129349) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 130048) {
                          if (129351 <= code2 && code2 <= 129791) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (130048 <= code2 && code2 <= 131069) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return boundaries_1.CLUSTER_BREAK.OTHER;
          }
        };
        exports3.default = Graphemer2;
      }
    });
    var require_lib2 = __commonJS2({
      "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js"(exports3) {
        "use strict";
        var __importDefault = exports3 && exports3.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var Graphemer_1 = __importDefault(require_Graphemer());
        exports3.default = Graphemer_1.default;
      }
    });
    var require_dist2 = __commonJS2({
      "../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js"(exports3) {
        (() => {
          "use strict";
          var e = { d: (t2, r2) => {
            for (var n2 in r2)
              e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
          }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
          } }, t = {};
          function r(e2, t2) {
            return t2 === void 0 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
          }
          function n(e2) {
            var t2 = /\D/.exec(e2);
            return t2 ? t2[0] : "";
          }
          function i(e2, t2, r2) {
            t2 === void 0 && (t2 = ":"), r2 === void 0 && (r2 = false);
            var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
            if (!r2 || !/[Z+\-]/.test(e2))
              return i2.test(e2);
            if (/Z$/.test(e2))
              return i2.test(e2.replace("Z", ""));
            var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
            return i2.test(u2) && function(e3, t3, r3) {
              return r3 === void 0 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
            }(d2, o2, n(d2));
          }
          function o(e2) {
            var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
            if (!a2)
              return false;
            var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
            return u2 && i(a2, s, true);
          }
          function a(e2, t2) {
            return t2 === void 0 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
          }
          e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
          var u = exports3;
          for (var d in t)
            u[d] = t[d];
          t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
        })();
      }
    });
    var src_exports2 = {};
    __export2(src_exports2, {
      APP_BSKY_GRAPH: () => APP_BSKY_GRAPH,
      ActorNS: () => ActorNS,
      AdminNS: () => AdminNS,
      AppBskyActorDefs: () => defs_exports5,
      AppBskyActorGetPreferences: () => getPreferences_exports,
      AppBskyActorGetProfile: () => getProfile_exports,
      AppBskyActorGetProfiles: () => getProfiles_exports,
      AppBskyActorGetSuggestions: () => getSuggestions_exports,
      AppBskyActorProfile: () => profile_exports,
      AppBskyActorPutPreferences: () => putPreferences_exports,
      AppBskyActorSearchActors: () => searchActors_exports,
      AppBskyActorSearchActorsTypeahead: () => searchActorsTypeahead_exports,
      AppBskyEmbedExternal: () => external_exports,
      AppBskyEmbedImages: () => images_exports,
      AppBskyEmbedRecord: () => record_exports,
      AppBskyEmbedRecordWithMedia: () => recordWithMedia_exports,
      AppBskyFeedDefs: () => defs_exports6,
      AppBskyFeedDescribeFeedGenerator: () => describeFeedGenerator_exports,
      AppBskyFeedGenerator: () => generator_exports,
      AppBskyFeedGetActorFeeds: () => getActorFeeds_exports,
      AppBskyFeedGetActorLikes: () => getActorLikes_exports,
      AppBskyFeedGetAuthorFeed: () => getAuthorFeed_exports,
      AppBskyFeedGetFeed: () => getFeed_exports,
      AppBskyFeedGetFeedGenerator: () => getFeedGenerator_exports,
      AppBskyFeedGetFeedGenerators: () => getFeedGenerators_exports,
      AppBskyFeedGetFeedSkeleton: () => getFeedSkeleton_exports,
      AppBskyFeedGetLikes: () => getLikes_exports,
      AppBskyFeedGetListFeed: () => getListFeed_exports,
      AppBskyFeedGetPostThread: () => getPostThread_exports,
      AppBskyFeedGetPosts: () => getPosts_exports,
      AppBskyFeedGetRepostedBy: () => getRepostedBy_exports,
      AppBskyFeedGetSuggestedFeeds: () => getSuggestedFeeds_exports,
      AppBskyFeedGetTimeline: () => getTimeline_exports,
      AppBskyFeedLike: () => like_exports,
      AppBskyFeedPost: () => post_exports,
      AppBskyFeedRepost: () => repost_exports,
      AppBskyFeedSearchPosts: () => searchPosts_exports,
      AppBskyFeedThreadgate: () => threadgate_exports,
      AppBskyGraphBlock: () => block_exports,
      AppBskyGraphDefs: () => defs_exports7,
      AppBskyGraphFollow: () => follow_exports,
      AppBskyGraphGetBlocks: () => getBlocks_exports2,
      AppBskyGraphGetFollowers: () => getFollowers_exports,
      AppBskyGraphGetFollows: () => getFollows_exports,
      AppBskyGraphGetList: () => getList_exports,
      AppBskyGraphGetListBlocks: () => getListBlocks_exports,
      AppBskyGraphGetListMutes: () => getListMutes_exports,
      AppBskyGraphGetLists: () => getLists_exports,
      AppBskyGraphGetMutes: () => getMutes_exports,
      AppBskyGraphGetSuggestedFollowsByActor: () => getSuggestedFollowsByActor_exports,
      AppBskyGraphList: () => list_exports,
      AppBskyGraphListblock: () => listblock_exports,
      AppBskyGraphListitem: () => listitem_exports,
      AppBskyGraphMuteActor: () => muteActor_exports,
      AppBskyGraphMuteActorList: () => muteActorList_exports,
      AppBskyGraphUnmuteActor: () => unmuteActor_exports,
      AppBskyGraphUnmuteActorList: () => unmuteActorList_exports,
      AppBskyNotificationGetUnreadCount: () => getUnreadCount_exports,
      AppBskyNotificationListNotifications: () => listNotifications_exports,
      AppBskyNotificationRegisterPush: () => registerPush_exports,
      AppBskyNotificationUpdateSeen: () => updateSeen_exports,
      AppBskyRichtextFacet: () => facet_exports,
      AppBskyUnspeccedDefs: () => defs_exports8,
      AppBskyUnspeccedGetPopular: () => getPopular_exports,
      AppBskyUnspeccedGetPopularFeedGenerators: () => getPopularFeedGenerators_exports,
      AppBskyUnspeccedGetTimelineSkeleton: () => getTimelineSkeleton_exports,
      AppBskyUnspeccedSearchActorsSkeleton: () => searchActorsSkeleton_exports,
      AppBskyUnspeccedSearchPostsSkeleton: () => searchPostsSkeleton_exports,
      AppNS: () => AppNS,
      AtUri: () => AtUri,
      AtpAgent: () => AtpAgent,
      AtpBaseClient: () => AtpBaseClient,
      AtpServiceClient: () => AtpServiceClient,
      AtprotoNS: () => AtprotoNS,
      BlobRef: () => BlobRef,
      BlockRecord: () => BlockRecord,
      BskyAgent: () => BskyAgent,
      BskyNS: () => BskyNS,
      COM_ATPROTO_ADMIN: () => COM_ATPROTO_ADMIN,
      COM_ATPROTO_MODERATION: () => COM_ATPROTO_MODERATION,
      ComAtprotoAdminDefs: () => defs_exports,
      ComAtprotoAdminDeleteAccount: () => deleteAccount_exports,
      ComAtprotoAdminDisableAccountInvites: () => disableAccountInvites_exports,
      ComAtprotoAdminDisableInviteCodes: () => disableInviteCodes_exports,
      ComAtprotoAdminEmitModerationEvent: () => emitModerationEvent_exports,
      ComAtprotoAdminEnableAccountInvites: () => enableAccountInvites_exports,
      ComAtprotoAdminGetAccountInfo: () => getAccountInfo_exports,
      ComAtprotoAdminGetInviteCodes: () => getInviteCodes_exports,
      ComAtprotoAdminGetModerationEvent: () => getModerationEvent_exports,
      ComAtprotoAdminGetRecord: () => getRecord_exports,
      ComAtprotoAdminGetRepo: () => getRepo_exports,
      ComAtprotoAdminGetSubjectStatus: () => getSubjectStatus_exports,
      ComAtprotoAdminQueryModerationEvents: () => queryModerationEvents_exports,
      ComAtprotoAdminQueryModerationStatuses: () => queryModerationStatuses_exports,
      ComAtprotoAdminSearchRepos: () => searchRepos_exports,
      ComAtprotoAdminSendEmail: () => sendEmail_exports,
      ComAtprotoAdminUpdateAccountEmail: () => updateAccountEmail_exports,
      ComAtprotoAdminUpdateAccountHandle: () => updateAccountHandle_exports,
      ComAtprotoAdminUpdateSubjectStatus: () => updateSubjectStatus_exports,
      ComAtprotoIdentityResolveHandle: () => resolveHandle_exports,
      ComAtprotoIdentityUpdateHandle: () => updateHandle_exports,
      ComAtprotoLabelDefs: () => defs_exports2,
      ComAtprotoLabelQueryLabels: () => queryLabels_exports,
      ComAtprotoLabelSubscribeLabels: () => subscribeLabels_exports,
      ComAtprotoModerationCreateReport: () => createReport_exports,
      ComAtprotoModerationDefs: () => defs_exports3,
      ComAtprotoRepoApplyWrites: () => applyWrites_exports,
      ComAtprotoRepoCreateRecord: () => createRecord_exports,
      ComAtprotoRepoDeleteRecord: () => deleteRecord_exports,
      ComAtprotoRepoDescribeRepo: () => describeRepo_exports,
      ComAtprotoRepoGetRecord: () => getRecord_exports2,
      ComAtprotoRepoListRecords: () => listRecords_exports,
      ComAtprotoRepoPutRecord: () => putRecord_exports,
      ComAtprotoRepoStrongRef: () => strongRef_exports,
      ComAtprotoRepoUploadBlob: () => uploadBlob_exports,
      ComAtprotoServerConfirmEmail: () => confirmEmail_exports,
      ComAtprotoServerCreateAccount: () => createAccount_exports,
      ComAtprotoServerCreateAppPassword: () => createAppPassword_exports,
      ComAtprotoServerCreateInviteCode: () => createInviteCode_exports,
      ComAtprotoServerCreateInviteCodes: () => createInviteCodes_exports,
      ComAtprotoServerCreateSession: () => createSession_exports,
      ComAtprotoServerDefs: () => defs_exports4,
      ComAtprotoServerDeleteAccount: () => deleteAccount_exports2,
      ComAtprotoServerDeleteSession: () => deleteSession_exports,
      ComAtprotoServerDescribeServer: () => describeServer_exports,
      ComAtprotoServerGetAccountInviteCodes: () => getAccountInviteCodes_exports,
      ComAtprotoServerGetSession: () => getSession_exports,
      ComAtprotoServerListAppPasswords: () => listAppPasswords_exports,
      ComAtprotoServerRefreshSession: () => refreshSession_exports,
      ComAtprotoServerRequestAccountDelete: () => requestAccountDelete_exports,
      ComAtprotoServerRequestEmailConfirmation: () => requestEmailConfirmation_exports,
      ComAtprotoServerRequestEmailUpdate: () => requestEmailUpdate_exports,
      ComAtprotoServerRequestPasswordReset: () => requestPasswordReset_exports,
      ComAtprotoServerReserveSigningKey: () => reserveSigningKey_exports,
      ComAtprotoServerResetPassword: () => resetPassword_exports,
      ComAtprotoServerRevokeAppPassword: () => revokeAppPassword_exports,
      ComAtprotoServerUpdateEmail: () => updateEmail_exports,
      ComAtprotoSyncGetBlob: () => getBlob_exports,
      ComAtprotoSyncGetBlocks: () => getBlocks_exports,
      ComAtprotoSyncGetCheckout: () => getCheckout_exports,
      ComAtprotoSyncGetHead: () => getHead_exports,
      ComAtprotoSyncGetLatestCommit: () => getLatestCommit_exports,
      ComAtprotoSyncGetRecord: () => getRecord_exports3,
      ComAtprotoSyncGetRepo: () => getRepo_exports2,
      ComAtprotoSyncListBlobs: () => listBlobs_exports,
      ComAtprotoSyncListRepos: () => listRepos_exports,
      ComAtprotoSyncNotifyOfUpdate: () => notifyOfUpdate_exports,
      ComAtprotoSyncRequestCrawl: () => requestCrawl_exports,
      ComAtprotoSyncSubscribeRepos: () => subscribeRepos_exports,
      ComAtprotoTempFetchLabels: () => fetchLabels_exports,
      ComAtprotoTempImportRepo: () => importRepo_exports,
      ComAtprotoTempPushBlob: () => pushBlob_exports,
      ComAtprotoTempTransferAccount: () => transferAccount_exports,
      ComNS: () => ComNS,
      EmbedNS: () => EmbedNS,
      FeedNS: () => FeedNS,
      FollowRecord: () => FollowRecord,
      GeneratorRecord: () => GeneratorRecord,
      GraphNS: () => GraphNS,
      IdentityNS: () => IdentityNS,
      LABELS: () => LABELS,
      LABEL_GROUPS: () => LABEL_GROUPS,
      LabelNS: () => LabelNS,
      LikeRecord: () => LikeRecord,
      ListRecord: () => ListRecord,
      ListblockRecord: () => ListblockRecord,
      ListitemRecord: () => ListitemRecord,
      ModerationDecision: () => ModerationDecision,
      ModerationNS: () => ModerationNS,
      NotificationNS: () => NotificationNS,
      PostRecord: () => PostRecord,
      ProfileRecord: () => ProfileRecord,
      RepoNS: () => RepoNS,
      RepostRecord: () => RepostRecord,
      RichText: () => RichText,
      RichTextSegment: () => RichTextSegment,
      RichtextNS: () => RichtextNS,
      ServerNS: () => ServerNS,
      SyncNS: () => SyncNS,
      TempNS: () => TempNS,
      ThreadgateRecord: () => ThreadgateRecord,
      UnicodeString: () => UnicodeString,
      UnspeccedNS: () => UnspeccedNS,
      default: () => AtpAgent,
      jsonStringToLex: () => jsonStringToLex,
      jsonToLex: () => jsonToLex,
      lexToJson: () => lexToJson,
      moderateFeedGenerator: () => moderateFeedGenerator,
      moderatePost: () => moderatePost,
      moderateProfile: () => moderateProfile,
      moderateUserList: () => moderateUserList,
      parseLanguage: () => parseLanguage,
      sanitizeRichText: () => sanitizeRichText,
      stringifyLex: () => stringifyLex
    });
    module2.exports = __toCommonJS2(src_exports2);
    var ensureValidHandle = (handle2) => {
      if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {
        throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
      }
      if (handle2.length > 253) {
        throw new InvalidHandleError("Handle is too long (253 chars max)");
      }
      const labels = handle2.split(".");
      if (labels.length < 2) {
        throw new InvalidHandleError("Handle domain needs at least two parts");
      }
      for (let i = 0; i < labels.length; i++) {
        const l = labels[i];
        if (l.length < 1) {
          throw new InvalidHandleError("Handle parts can not be empty");
        }
        if (l.length > 63) {
          throw new InvalidHandleError("Handle part too long (max 63 chars)");
        }
        if (l.endsWith("-") || l.startsWith("-")) {
          throw new InvalidHandleError("Handle parts can not start or end with hyphens");
        }
        if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {
          throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
        }
      }
    };
    var InvalidHandleError = class extends Error {
    };
    var ensureValidDid = (did2) => {
      if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {
        throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
      }
      const parts = did2.split(":");
      if (parts.length < 3) {
        throw new InvalidDidError("DID requires prefix, method, and method-specific content");
      }
      if (parts[0] != "did") {
        throw new InvalidDidError('DID requires "did:" prefix');
      }
      if (!/^[a-z]+$/.test(parts[1])) {
        throw new InvalidDidError("DID method must be lower-case letters");
      }
      if (did2.endsWith(":") || did2.endsWith("%")) {
        throw new InvalidDidError('DID can not end with ":" or "%"');
      }
      if (did2.length > 2 * 1024) {
        throw new InvalidDidError("DID is too long (2048 chars max)");
      }
    };
    var InvalidDidError = class extends Error {
    };
    var NSID = class {
      constructor(nsid2) {
        this.segments = [];
        ensureValidNsid(nsid2);
        this.segments = nsid2.split(".");
      }
      static parse(nsid2) {
        return new NSID(nsid2);
      }
      static create(authority, name2) {
        const segments = [...authority.split(".").reverse(), name2].join(".");
        return new NSID(segments);
      }
      static isValid(nsid2) {
        try {
          NSID.parse(nsid2);
          return true;
        } catch (e) {
          return false;
        }
      }
      get authority() {
        return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
      }
      get name() {
        return this.segments.at(this.segments.length - 1);
      }
      toString() {
        return this.segments.join(".");
      }
    };
    var ensureValidNsid = (nsid2) => {
      const toCheck = nsid2;
      if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
        throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
      }
      if (toCheck.length > 253 + 1 + 63) {
        throw new InvalidNsidError("NSID is too long (317 chars max)");
      }
      const labels = toCheck.split(".");
      if (labels.length < 3) {
        throw new InvalidNsidError("NSID needs at least three parts");
      }
      for (let i = 0; i < labels.length; i++) {
        const l = labels[i];
        if (l.length < 1) {
          throw new InvalidNsidError("NSID parts can not be empty");
        }
        if (l.length > 63) {
          throw new InvalidNsidError("NSID part too long (max 63 chars)");
        }
        if (l.endsWith("-") || l.startsWith("-")) {
          throw new InvalidNsidError("NSID parts can not start or end with hyphen");
        }
        if (/^[0-9]/.test(l) && i == 0) {
          throw new InvalidNsidError("NSID first part may not start with a digit");
        }
        if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
          throw new InvalidNsidError("NSID name part must be only letters");
        }
      }
    };
    var InvalidNsidError = class extends Error {
    };
    var ensureValidAtUri = (uri2) => {
      const uriParts = uri2.split("#");
      if (uriParts.length > 2) {
        throw new Error('ATURI can have at most one "#", separating fragment out');
      }
      const fragmentPart = uriParts[1] || null;
      uri2 = uriParts[0];
      if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri2)) {
        throw new Error("Disallowed characters in ATURI (ASCII)");
      }
      const parts = uri2.split("/");
      if (parts.length >= 3 && (parts[0] != "at:" || parts[1].length != 0)) {
        throw new Error('ATURI must start with "at://"');
      }
      if (parts.length < 3) {
        throw new Error("ATURI requires at least method and authority sections");
      }
      try {
        if (parts[2].startsWith("did:")) {
          ensureValidDid(parts[2]);
        } else {
          ensureValidHandle(parts[2]);
        }
      } catch {
        throw new Error("ATURI authority must be a valid handle or DID");
      }
      if (parts.length >= 4) {
        if (parts[3].length == 0) {
          throw new Error("ATURI can not have a slash after authority without a path segment");
        }
        try {
          ensureValidNsid(parts[3]);
        } catch {
          throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
        }
      }
      if (parts.length >= 5) {
        if (parts[4].length == 0) {
          throw new Error("ATURI can not have a slash after collection, unless record key is provided");
        }
      }
      if (parts.length >= 6) {
        throw new Error("ATURI path can have at most two parts, and no trailing slash");
      }
      if (uriParts.length >= 2 && fragmentPart == null) {
        throw new Error("ATURI fragment must be non-empty and start with slash");
      }
      if (fragmentPart != null) {
        if (fragmentPart.length == 0 || fragmentPart[0] != "/") {
          throw new Error("ATURI fragment must be non-empty and start with slash");
        }
        if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
          throw new Error("Disallowed characters in ATURI fragment (ASCII)");
        }
      }
      if (uri2.length > 8 * 1024) {
        throw new Error("ATURI is far too long");
      }
    };
    var ATP_URI_REGEX = /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
    var RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
    var AtUri = class {
      constructor(uri2, base3) {
        let parsed;
        if (base3) {
          parsed = parse2(base3);
          if (!parsed) {
            throw new Error(`Invalid at uri: ${base3}`);
          }
          const relativep = parseRelative(uri2);
          if (!relativep) {
            throw new Error(`Invalid path: ${uri2}`);
          }
          Object.assign(parsed, relativep);
        } else {
          parsed = parse2(uri2);
          if (!parsed) {
            throw new Error(`Invalid at uri: ${uri2}`);
          }
        }
        this.hash = parsed.hash;
        this.host = parsed.host;
        this.pathname = parsed.pathname;
        this.searchParams = parsed.searchParams;
      }
      static make(handleOrDid, collection, rkey) {
        let str = handleOrDid;
        if (collection)
          str += "/" + collection;
        if (rkey)
          str += "/" + rkey;
        return new AtUri(str);
      }
      get protocol() {
        return "at:";
      }
      get origin() {
        return `at://${this.host}`;
      }
      get hostname() {
        return this.host;
      }
      set hostname(v) {
        this.host = v;
      }
      get search() {
        return this.searchParams.toString();
      }
      set search(v) {
        this.searchParams = new URLSearchParams(v);
      }
      get collection() {
        return this.pathname.split("/").filter(Boolean)[0] || "";
      }
      set collection(v) {
        const parts = this.pathname.split("/").filter(Boolean);
        parts[0] = v;
        this.pathname = parts.join("/");
      }
      get rkey() {
        return this.pathname.split("/").filter(Boolean)[1] || "";
      }
      set rkey(v) {
        const parts = this.pathname.split("/").filter(Boolean);
        if (!parts[0])
          parts[0] = "undefined";
        parts[1] = v;
        this.pathname = parts.join("/");
      }
      get href() {
        return this.toString();
      }
      toString() {
        let path = this.pathname || "/";
        if (!path.startsWith("/")) {
          path = `/${path}`;
        }
        let qs = this.searchParams.toString();
        if (qs && !qs.startsWith("?")) {
          qs = `?${qs}`;
        }
        let hash = this.hash;
        if (hash && !hash.startsWith("#")) {
          hash = `#${hash}`;
        }
        return `at://${this.host}${path}${qs}${hash}`;
      }
    };
    function parse2(str) {
      const match = ATP_URI_REGEX.exec(str);
      if (match) {
        return {
          hash: match[5] || "",
          host: match[2] || "",
          pathname: match[3] || "",
          searchParams: new URLSearchParams(match[4] || "")
        };
      }
      return void 0;
    }
    function parseRelative(str) {
      const match = RELATIVE_REGEX.exec(str);
      if (match) {
        return {
          hash: match[3] || "",
          pathname: match[1] || "",
          searchParams: new URLSearchParams(match[2] || "")
        };
      }
      return void 0;
    }
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
        const keys = [];
        for (const key in object2) {
          if (Object.prototype.hasOwnProperty.call(object2, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
        };
      };
    })(objectUtil || (objectUtil = {}));
    var ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    var ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    var ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    var overrideErrorMap = errorMap;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    function getErrorMap() {
      return overrideErrorMap;
    }
    var makeIssue = (params2) => {
      const { data, path, errorMaps, issueData } = params2;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    var EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const issue = makeIssue({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    var ParseStatus = class {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (typeof value.value !== "undefined" || pair.alwaysSet) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    var INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    var OK = (value) => ({ status: "valid", value });
    var isAborted = (x) => x.status === "aborted";
    var isDirty = (x) => x.status === "dirty";
    var isValid = (x) => x.status === "valid";
    var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    var ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params2) {
      if (!params2)
        return {};
      const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
      if (errorMap2 && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap2)
        return { errorMap: errorMap2, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      constructor(def2) {
        this.spa = this.safeParseAsync;
        this._def = def2;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params2) {
        const result = this.safeParse(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params2) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
          },
          path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params2) {
        const result = await this.safeParseAsync(data, params2);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params2) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
            async: true
          },
          path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def2) {
        const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def2) {
        const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var cuid2Regex = /^[a-z][a-z0-9]*$/;
    var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
    var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
    var emojiRegex = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    var datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    function isValidIP(ip, version22) {
      if ((version22 === "v4" || !version22) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version22 === "v6" || !version22) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString = class extends ZodType {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
        this.toLowerCase = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
        this.toUpperCase = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params2) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params2)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params2) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
        ...processCreateParams(params2)
      });
    };
    var ZodBigInt = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params2) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params2)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params2) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
        ...processCreateParams(params2)
      });
    };
    var ZodDate = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params2) => {
      return new ZodDate({
        checks: [],
        coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params2)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params2) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params2)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params2) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params2)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params2) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params2)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params2) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params2)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params2) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params2)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params2) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params2)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params2) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params2)
      });
    };
    var ZodArray = class extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def2 = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def2.exactLength !== null) {
          const tooBig = ctx.data.length > def2.exactLength.value;
          const tooSmall = ctx.data.length < def2.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def2.exactLength.value : void 0,
              maximum: tooBig ? def2.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def2.exactLength.message
            });
            status.dirty();
          }
        }
        if (def2.minLength !== null) {
          if (ctx.data.length < def2.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def2.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def2.minLength.message
            });
            status.dirty();
          }
        }
        if (def2.maxLength !== null) {
          if (ctx.data.length > def2.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def2.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def2.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema2, params2) => {
      return new ZodArray({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params2)
      });
    };
    function deepPartialify(schema2) {
      if (schema2 instanceof ZodObject) {
        const newShape = {};
        for (const key in schema2.shape) {
          const fieldSchema = schema2.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema2._def,
          shape: () => newShape
        });
      } else if (schema2 instanceof ZodArray) {
        return new ZodArray({
          ...schema2._def,
          type: deepPartialify(schema2.element)
        });
      } else if (schema2 instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodTuple) {
        return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
      } else {
        return schema2;
      }
    }
    var ZodObject = class extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      extend(augmentation) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      setKey(key, schema2) {
        return this.augment({ [key]: schema2 });
      }
      catchall(index) {
        return new ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.strictCreate = (shape, params2) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.lazycreate = (shape, params2) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types3, params2) => {
      return new ZodUnion({
        options: types3,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params2)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    var ZodDiscriminatedUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(discriminator, options, params2) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params2)
        });
      }
    };
    function mergeValues(a, b) {
      const aType = getParsedType(a);
      const bType = getParsedType(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params2) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params2)
      });
    };
    var ZodTuple = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas2, params2) => {
      if (!Array.isArray(schemas2)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas2,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params2)
      });
    };
    var ZodRecord = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    var ZodMap = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params2) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params2)
      });
    };
    var ZodSet = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def2 = this._def;
        if (def2.minSize !== null) {
          if (ctx.data.size < def2.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def2.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def2.minSize.message
            });
            status.dirty();
          }
        }
        if (def2.maxSize !== null) {
          if (ctx.data.size > def2.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def2.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def2.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params2) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params2)
      });
    };
    var ZodFunction = class extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params2 = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          return OK(async (...args) => {
            const error = new ZodError([]);
            const parsedArgs = await this._def.args.parseAsync(args, params2).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await fn(...parsedArgs);
            const parsedReturns = await this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          return OK((...args) => {
            const parsedArgs = this._def.args.safeParse(args, params2);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = fn(...parsedArgs.data);
            const parsedReturns = this._def.returns.safeParse(result, params2);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params2) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params2)
        });
      }
    };
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params2) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params2)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params2) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params2)
      });
    };
    function createZodEnum(values, params2) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params2)
      });
    }
    var ZodEnum = class extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return ZodEnum.create(values);
      }
      exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params2) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params2)
      });
    };
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema2, params2) => {
      return new ZodPromise({
        type: schema2,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params2)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data);
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base3 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base3))
              return base3;
            const result = effect.transform(base3.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
              if (!isValid(base3))
                return base3;
              return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema2, effect, params2) => {
      return new ZodEffects({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params2)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema2, params2) => {
      return new ZodEffects({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params2)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params2) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params2)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params2) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params2)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params2) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
        ...processCreateParams(params2)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params2) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
        ...processCreateParams(params2)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params2) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params2)
      });
    };
    var BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    var ZodPipeline = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    var custom = (check, params2 = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check(data)) {
            const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    var late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params2 = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params2);
    var stringType = ZodString.create;
    var numberType = ZodNumber.create;
    var nanType = ZodNaN.create;
    var bigIntType = ZodBigInt.create;
    var booleanType = ZodBoolean.create;
    var dateType = ZodDate.create;
    var symbolType = ZodSymbol.create;
    var undefinedType = ZodUndefined.create;
    var nullType = ZodNull.create;
    var anyType = ZodAny.create;
    var unknownType = ZodUnknown.create;
    var neverType = ZodNever.create;
    var voidType = ZodVoid.create;
    var arrayType = ZodArray.create;
    var objectType = ZodObject.create;
    var strictObjectType = ZodObject.strictCreate;
    var unionType = ZodUnion.create;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    var intersectionType = ZodIntersection.create;
    var tupleType = ZodTuple.create;
    var recordType = ZodRecord.create;
    var mapType = ZodMap.create;
    var setType = ZodSet.create;
    var functionType = ZodFunction.create;
    var lazyType = ZodLazy.create;
    var literalType = ZodLiteral.create;
    var enumType = ZodEnum.create;
    var nativeEnumType = ZodNativeEnum.create;
    var promiseType = ZodPromise.create;
    var effectsType = ZodEffects.create;
    var optionalType = ZodOptional.create;
    var nullableType = ZodNullable.create;
    var preprocessType = ZodEffects.createWithPreprocess;
    var pipelineType = ZodPipeline.create;
    var ostring = () => stringType().optional();
    var onumber = () => numberType().optional();
    var oboolean = () => booleanType().optional();
    var coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    var NEVER = INVALID;
    var z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
    var check_exports = {};
    __export2(check_exports, {
      assure: () => assure,
      is: () => is,
      isObject: () => isObject
    });
    var is = (obj, def2) => {
      return def2.safeParse(obj).success;
    };
    var assure = (def2, obj) => {
      return def2.parse(obj);
    };
    var isObject = (obj) => {
      return typeof obj === "object" && obj !== null;
    };
    var encode_1 = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode = read;
    var MSB$1 = 128;
    var REST$1 = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$1);
      read.bytes = counter - offset;
      return res;
    }
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    var length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    var varint = {
      encode: encode_1,
      decode,
      encodingLength: length
    };
    var _brrp_varint = varint;
    var varint_default = _brrp_varint;
    var decode2 = (data, offset = 0) => {
      const code2 = varint_default.decode(data, offset);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    var encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    var encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
    var empty = new Uint8Array(0);
    var equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var fromString = (str) => new TextEncoder().encode(str);
    var toString = (b) => new TextDecoder().decode(b);
    var create = (code2, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes2, 0);
      encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest2, digestOffset);
      return new Digest(code2, size, digest2, bytes2);
    };
    var decode3 = (multihash) => {
      const bytes2 = coerce2(multihash);
      const [code2, sizeOffset] = decode2(bytes2);
      const [size, digestOffset] = decode2(bytes2.subarray(sizeOffset));
      const digest2 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest2, bytes2);
    };
    var equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    };
    var Digest = class {
      constructor(code2, size, digest2, bytes2) {
        this.code = code2;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes2;
      }
    };
    var base58_exports = {};
    __export2(base58_exports, {
      base58btc: () => base58btc,
      base58flickr: () => base58flickr
    });
    function base(ALPHABET, name2) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode5(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode6(string3) {
        var buffer = decodeUnsafe(string3);
        if (buffer) {
          return buffer;
        }
        throw new Error(`Non-${name2} character`);
      }
      return {
        encode: encode5,
        decodeUnsafe,
        decode: decode6
      };
    }
    var src = base;
    var _brrp__multiformats_scope_baseX = src;
    var base_x_default = _brrp__multiformats_scope_baseX;
    var Encoder = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder2) {
        return or(this, decoder2);
      }
    };
    var ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder2) {
        return or(this, decoder2);
      }
      decode(input) {
        const prefix = input[0];
        const decoder2 = this.decoders[prefix];
        if (decoder2) {
          return decoder2.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from = ({ name: name2, prefix, encode: encode5, decode: decode6 }) => new Codec(name2, prefix, encode5, decode6);
    var baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
      const { encode: encode5, decode: decode6 } = base_x_default(alphabet2, name2);
      return from({
        prefix,
        name: name2,
        encode: encode5,
        decode: (text) => coerce2(decode6(text))
      });
    };
    var decode4 = (string3, alphabet2, bitsPerChar, name2) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string3[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode2 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from({
        prefix,
        name: name2,
        encode(input) {
          return encode2(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode4(input, alphabet2, bitsPerChar, name2);
        }
      });
    };
    var base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    var base32_exports = {};
    __export2(base32_exports, {
      base32: () => base32,
      base32hex: () => base32hex,
      base32hexpad: () => base32hexpad,
      base32hexpadupper: () => base32hexpadupper,
      base32hexupper: () => base32hexupper,
      base32pad: () => base32pad,
      base32padupper: () => base32padupper,
      base32upper: () => base32upper,
      base32z: () => base32z
    });
    var base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    var CID = class {
      constructor(version22, code2, multihash, bytes2) {
        this.code = code2;
        this.version = version22;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest: digest2 } = this.multihash;
            const multihash = create(code2, digest2);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes: bytes2, version: version22, _baseCache } = this;
        switch (version22) {
          case 0:
            return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes2, _baseCache, base3 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version22, code: code2, multihash, bytes: bytes2 } = value;
          return new CID(version22, code2, multihash, bytes2 || encodeCID(version22, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version22, multihash, code: code2 } = value;
          const digest2 = decode3(multihash);
          return CID.create(version22, code2, digest2);
        } else {
          return null;
        }
      }
      static create(version22, code2, digest2) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version22) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version22, code2, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID(version22, code2, digest2.bytes);
            return new CID(version22, code2, digest2, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code2, digest2) {
        return CID.create(1, code2, digest2);
      }
      static decode(bytes2) {
        const [cid2, remainder] = CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid2;
      }
      static decodeFirst(bytes2) {
        const specs = CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid2 = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
        return [
          cid2,
          bytes2.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = decode2(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version22 = next();
        let codec = DAG_PB_CODE;
        if (version22 === 18) {
          version22 = 0;
          offset = 0;
        } else if (version22 === 1) {
          codec = next();
        }
        if (version22 !== 0 && version22 !== 1) {
          throw new RangeError(`Invalid CID version ${version22}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version22,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes2] = parseCIDtoBytes(source, base3);
        const cid2 = CID.decode(bytes2);
        cid2._baseCache.set(prefix, source);
        return cid2;
      }
    };
    var parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder2 = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder2.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder2 = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder2.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder2 = base3 || base32;
          return [
            base32.prefix,
            decoder2.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    var toStringV0 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid2 = cache.get(prefix);
      if (cid2 == null) {
        const cid3 = base3.encode(bytes2).slice(1);
        cache.set(prefix, cid3);
        return cid3;
      } else {
        return cid2;
      }
    };
    var toStringV1 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      const cid2 = cache.get(prefix);
      if (cid2 == null) {
        const cid3 = base3.encode(bytes2);
        cache.set(prefix, cid3);
        return cid3;
      } else {
        return cid2;
      }
    };
    var DAG_PB_CODE = 112;
    var SHA_256_CODE = 18;
    var encodeCID = (version22, code2, multihash) => {
      const codeOffset = encodingLength(version22);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version22, bytes2, 0);
      encodeTo(code2, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol = Symbol.for("@ipld/js-cid/CID");
    var readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version2 = "0.0.0-dev";
    var deprecate = (range, message) => {
      if (range.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    var identity_exports = {};
    __export2(identity_exports, {
      identity: () => identity
    });
    var identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => toString(buf),
      decode: (str) => fromString(str)
    });
    var base2_exports = {};
    __export2(base2_exports, {
      base2: () => base2
    });
    var base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    var base8_exports = {};
    __export2(base8_exports, {
      base8: () => base8
    });
    var base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    var base10_exports = {};
    __export2(base10_exports, {
      base10: () => base10
    });
    var base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    var base16_exports = {};
    __export2(base16_exports, {
      base16: () => base16,
      base16upper: () => base16upper
    });
    var base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    var base36_exports = {};
    __export2(base36_exports, {
      base36: () => base36,
      base36upper: () => base36upper
    });
    var base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    var base64_exports = {};
    __export2(base64_exports, {
      base64: () => base64,
      base64pad: () => base64pad,
      base64url: () => base64url,
      base64urlpad: () => base64urlpad
    });
    var base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    var base256emoji_exports = {};
    __export2(base256emoji_exports, {
      base256emoji: () => base256emoji
    });
    var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode3(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars[c];
        return p;
      }, "");
    }
    function decode5(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode3,
      decode: decode5
    });
    var sha2_browser_exports = {};
    __export2(sha2_browser_exports, {
      sha256: () => sha256,
      sha512: () => sha512
    });
    var from2 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);
    var Hasher = class {
      constructor(name2, code2, encode5) {
        this.name = name2;
        this.code = code2;
        this.encode = encode5;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
    var sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    var sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
    var identity_exports2 = {};
    __export2(identity_exports2, {
      identity: () => identity2
    });
    var code = 0;
    var name = "identity";
    var encode4 = coerce2;
    var digest = (input) => create(code, encode4(input));
    var identity2 = {
      code,
      name,
      encode: encode4,
      digest
    };
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    var bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    var hashes = {
      ...sha2_browser_exports,
      ...identity_exports2
    };
    function createCodec(name2, prefix, encode5, decode6) {
      return {
        name: name2,
        prefix,
        encoder: {
          name: name2,
          prefix,
          encode: encode5
        },
        decoder: { decode: decode6 }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf);
    }, (str) => {
      const encoder2 = new TextEncoder();
      return encoder2.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string3 = "a";
      for (let i = 0; i < buf.length; i++) {
        string3 += String.fromCharCode(buf[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    });
    var BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    var bases_default = BASES;
    function fromString2(string3, encoding = "utf8") {
      const base3 = bases_default[encoding];
      if (!base3) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base3.decoder.decode(`${base3.prefix}${string3}`);
    }
    function toString2(array2, encoding = "utf8") {
      const base3 = bases_default[encoding];
      if (!base3) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base3.encoder.encode(array2).substring(1);
    }
    var jsonToIpld = (val) => {
      if (Array.isArray(val)) {
        return val.map((item) => jsonToIpld(item));
      }
      if (val && typeof val === "object") {
        if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
          return CID.parse(val["$link"]);
        }
        if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
          return fromString2(val["$bytes"], "base64");
        }
        const toReturn = {};
        for (const key of Object.keys(val)) {
          toReturn[key] = jsonToIpld(val[key]);
        }
        return toReturn;
      }
      return val;
    };
    var ipldToJson = (val) => {
      if (Array.isArray(val)) {
        return val.map((item) => ipldToJson(item));
      }
      if (val && typeof val === "object") {
        if (val instanceof Uint8Array) {
          return {
            $bytes: toString2(val, "base64")
          };
        }
        if (CID.asCID(val)) {
          return {
            $link: val.toString()
          };
        }
        const toReturn = {};
        for (const key of Object.keys(val)) {
          toReturn[key] = ipldToJson(val[key]);
        }
        return toReturn;
      }
      return val;
    };
    var cidSchema = z.any().refine((obj) => CID.asCID(obj) !== null, {
      message: "Not a CID"
    }).transform((obj) => CID.asCID(obj));
    var schema = {
      cid: cidSchema,
      bytes: z.instanceof(Uint8Array),
      string: z.string(),
      array: z.array(z.unknown()),
      map: z.record(z.string(), z.unknown()),
      unknown: z.unknown()
    };
    var def = {
      cid: {
        name: "cid",
        schema: schema.cid
      },
      bytes: {
        name: "bytes",
        schema: schema.bytes
      },
      string: {
        name: "string",
        schema: schema.string
      },
      map: {
        name: "map",
        schema: schema.map
      },
      unknown: {
        name: "unknown",
        schema: schema.unknown
      }
    };
    var SECOND = 1e3;
    var MINUTE = SECOND * 60;
    var HOUR = MINUTE * 60;
    var DAY = HOUR * 24;
    var import_graphemer = __toESM2(require_lib2());
    var utf8Len = (str) => {
      return new TextEncoder().encode(str).byteLength;
    };
    var graphemeLen = (str) => {
      const splitter = new import_graphemer.default();
      return splitter.countGraphemes(str);
    };
    var parseLanguage = (langTag) => {
      const parsed = langTag.match(bcp47Regexp);
      if (!(parsed == null ? void 0 : parsed.groups))
        return null;
      const parts = parsed.groups;
      return {
        grandfathered: parts.grandfathered,
        language: parts.language,
        extlang: parts.extlang,
        script: parts.script,
        region: parts.region,
        variant: parts.variant,
        extension: parts.extension,
        privateUse: parts.privateUseA || parts.privateUseB
      };
    };
    var validateLanguage = (langTag) => {
      return bcp47Regexp.test(langTag);
    };
    var bcp47Regexp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
    var isValidDidDoc = (doc) => {
      return didDocument.safeParse(doc).success;
    };
    var getDid = (doc) => {
      const id = doc.id;
      if (typeof id !== "string") {
        throw new Error("No `id` on document");
      }
      return id;
    };
    var getPdsEndpoint = (doc) => {
      return getServiceEndpoint(doc, {
        id: "#atproto_pds",
        type: "AtprotoPersonalDataServer"
      });
    };
    var getServiceEndpoint = (doc, opts) => {
      const did2 = getDid(doc);
      let services = doc.service;
      if (!services)
        return void 0;
      if (typeof services !== "object")
        return void 0;
      if (!Array.isArray(services)) {
        services = [services];
      }
      const found = services.find((service2) => service2.id === opts.id || service2.id === `${did2}${opts.id}`);
      if (!found)
        return void 0;
      if (found.type !== opts.type) {
        return void 0;
      }
      if (typeof found.serviceEndpoint !== "string") {
        return void 0;
      }
      return validateUrl(found.serviceEndpoint);
    };
    var validateUrl = (urlStr) => {
      let url;
      try {
        url = new URL(urlStr);
      } catch {
        return void 0;
      }
      if (!["http:", "https:"].includes(url.protocol)) {
        return void 0;
      } else if (!url.hostname) {
        return void 0;
      } else {
        return urlStr;
      }
    };
    var verificationMethod = z.object({
      id: z.string(),
      type: z.string(),
      controller: z.string(),
      publicKeyMultibase: z.string().optional()
    });
    var service = z.object({
      id: z.string(),
      type: z.string(),
      serviceEndpoint: z.union([z.string(), z.record(z.unknown())])
    });
    var didDocument = z.object({
      id: z.string(),
      alsoKnownAs: z.array(z.string()).optional(),
      verificationMethod: z.array(verificationMethod).optional(),
      service: z.array(service).optional()
    });
    var import_iso_datestring_validator = __toESM2(require_dist2());
    function datetime(path, value) {
      try {
        if (!(0, import_iso_datestring_validator.isValidISODateString)(value)) {
          throw new Error();
        }
      } catch {
        return {
          success: false,
          error: new ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
        };
      }
      return { success: true, value };
    }
    function uri(path, value) {
      const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
      if (!isUri) {
        return {
          success: false,
          error: new ValidationError(`${path} must be a uri`)
        };
      }
      return { success: true, value };
    }
    function atUri(path, value) {
      try {
        ensureValidAtUri(value);
      } catch {
        return {
          success: false,
          error: new ValidationError(`${path} must be a valid at-uri`)
        };
      }
      return { success: true, value };
    }
    function did(path, value) {
      try {
        ensureValidDid(value);
      } catch {
        return {
          success: false,
          error: new ValidationError(`${path} must be a valid did`)
        };
      }
      return { success: true, value };
    }
    function handle(path, value) {
      try {
        ensureValidHandle(value);
      } catch {
        return {
          success: false,
          error: new ValidationError(`${path} must be a valid handle`)
        };
      }
      return { success: true, value };
    }
    function atIdentifier(path, value) {
      const isDid = did(path, value);
      if (!isDid.success) {
        const isHandle2 = handle(path, value);
        if (!isHandle2.success) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid did or a handle`)
          };
        }
      }
      return { success: true, value };
    }
    function nsid(path, value) {
      try {
        ensureValidNsid(value);
      } catch {
        return {
          success: false,
          error: new ValidationError(`${path} must be a valid nsid`)
        };
      }
      return { success: true, value };
    }
    function cid(path, value) {
      try {
        CID.parse(value);
      } catch {
        return {
          success: false,
          error: new ValidationError(`${path} must be a cid string`)
        };
      }
      return { success: true, value };
    }
    function language(path, value) {
      if (validateLanguage(value)) {
        return { success: true, value };
      }
      return {
        success: false,
        error: new ValidationError(`${path} must be a well-formed BCP 47 language tag`)
      };
    }
    function validate2(lexicons2, path, def2, value) {
      switch (def2.type) {
        case "boolean":
          return boolean(lexicons2, path, def2, value);
        case "integer":
          return integer(lexicons2, path, def2, value);
        case "string":
          return string2(lexicons2, path, def2, value);
        case "bytes":
          return bytes(lexicons2, path, def2, value);
        case "cid-link":
          return cidLink(lexicons2, path, def2, value);
        case "unknown":
          return unknown(lexicons2, path, def2, value);
        default:
          return {
            success: false,
            error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
          };
      }
    }
    function boolean(lexicons2, path, def2, value) {
      def2 = def2;
      const type = typeof value;
      if (type === "undefined") {
        if (typeof def2.default === "boolean") {
          return { success: true, value: def2.default };
        }
        return {
          success: false,
          error: new ValidationError(`${path} must be a boolean`)
        };
      } else if (type !== "boolean") {
        return {
          success: false,
          error: new ValidationError(`${path} must be a boolean`)
        };
      }
      if (typeof def2.const === "boolean") {
        if (value !== def2.const) {
          return {
            success: false,
            error: new ValidationError(`${path} must be ${def2.const}`)
          };
        }
      }
      return { success: true, value };
    }
    function integer(lexicons2, path, def2, value) {
      def2 = def2;
      const type = typeof value;
      if (type === "undefined") {
        if (typeof def2.default === "number") {
          return { success: true, value: def2.default };
        }
        return {
          success: false,
          error: new ValidationError(`${path} must be an integer`)
        };
      } else if (!Number.isInteger(value)) {
        return {
          success: false,
          error: new ValidationError(`${path} must be an integer`)
        };
      }
      if (typeof def2.const === "number") {
        if (value !== def2.const) {
          return {
            success: false,
            error: new ValidationError(`${path} must be ${def2.const}`)
          };
        }
      }
      if (Array.isArray(def2.enum)) {
        if (!def2.enum.includes(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
          };
        }
      }
      if (typeof def2.maximum === "number") {
        if (value > def2.maximum) {
          return {
            success: false,
            error: new ValidationError(`${path} can not be greater than ${def2.maximum}`)
          };
        }
      }
      if (typeof def2.minimum === "number") {
        if (value < def2.minimum) {
          return {
            success: false,
            error: new ValidationError(`${path} can not be less than ${def2.minimum}`)
          };
        }
      }
      return { success: true, value };
    }
    function string2(lexicons2, path, def2, value) {
      def2 = def2;
      if (typeof value === "undefined") {
        if (typeof def2.default === "string") {
          return { success: true, value: def2.default };
        }
        return {
          success: false,
          error: new ValidationError(`${path} must be a string`)
        };
      } else if (typeof value !== "string") {
        return {
          success: false,
          error: new ValidationError(`${path} must be a string`)
        };
      }
      if (typeof def2.const === "string") {
        if (value !== def2.const) {
          return {
            success: false,
            error: new ValidationError(`${path} must be ${def2.const}`)
          };
        }
      }
      if (Array.isArray(def2.enum)) {
        if (!def2.enum.includes(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
          };
        }
      }
      if (typeof def2.maxLength === "number") {
        if (utf8Len(value) > def2.maxLength) {
          return {
            success: false,
            error: new ValidationError(`${path} must not be longer than ${def2.maxLength} characters`)
          };
        }
      }
      if (typeof def2.minLength === "number") {
        if (utf8Len(value) < def2.minLength) {
          return {
            success: false,
            error: new ValidationError(`${path} must not be shorter than ${def2.minLength} characters`)
          };
        }
      }
      if (typeof def2.maxGraphemes === "number") {
        if (graphemeLen(value) > def2.maxGraphemes) {
          return {
            success: false,
            error: new ValidationError(`${path} must not be longer than ${def2.maxGraphemes} graphemes`)
          };
        }
      }
      if (typeof def2.minGraphemes === "number") {
        if (graphemeLen(value) < def2.minGraphemes) {
          return {
            success: false,
            error: new ValidationError(`${path} must not be shorter than ${def2.minGraphemes} graphemes`)
          };
        }
      }
      if (typeof def2.format === "string") {
        switch (def2.format) {
          case "datetime":
            return datetime(path, value);
          case "uri":
            return uri(path, value);
          case "at-uri":
            return atUri(path, value);
          case "did":
            return did(path, value);
          case "handle":
            return handle(path, value);
          case "at-identifier":
            return atIdentifier(path, value);
          case "nsid":
            return nsid(path, value);
          case "cid":
            return cid(path, value);
          case "language":
            return language(path, value);
        }
      }
      return { success: true, value };
    }
    function bytes(lexicons2, path, def2, value) {
      def2 = def2;
      if (!value || !(value instanceof Uint8Array)) {
        return {
          success: false,
          error: new ValidationError(`${path} must be a byte array`)
        };
      }
      if (typeof def2.maxLength === "number") {
        if (value.byteLength > def2.maxLength) {
          return {
            success: false,
            error: new ValidationError(`${path} must not be larger than ${def2.maxLength} bytes`)
          };
        }
      }
      if (typeof def2.minLength === "number") {
        if (value.byteLength < def2.minLength) {
          return {
            success: false,
            error: new ValidationError(`${path} must not be smaller than ${def2.minLength} bytes`)
          };
        }
      }
      return { success: true, value };
    }
    function cidLink(lexicons2, path, def2, value) {
      if (CID.asCID(value) === null) {
        return {
          success: false,
          error: new ValidationError(`${path} must be a CID`)
        };
      }
      return { success: true, value };
    }
    function unknown(lexicons2, path, def2, value) {
      if (!value || typeof value !== "object") {
        return {
          success: false,
          error: new ValidationError(`${path} must be an object`)
        };
      }
      return { success: true, value };
    }
    var typedJsonBlobRef = z.object({
      $type: z.literal("blob"),
      ref: schema.cid,
      mimeType: z.string(),
      size: z.number()
    }).strict();
    var untypedJsonBlobRef = z.object({
      cid: z.string(),
      mimeType: z.string()
    }).strict();
    var jsonBlobRef = z.union([typedJsonBlobRef, untypedJsonBlobRef]);
    var BlobRef = class {
      constructor(ref, mimeType, size, original) {
        this.ref = ref;
        this.mimeType = mimeType;
        this.size = size;
        this.original = original != null ? original : {
          $type: "blob",
          ref,
          mimeType,
          size
        };
      }
      static asBlobRef(obj) {
        if (check_exports.is(obj, jsonBlobRef)) {
          return BlobRef.fromJsonRef(obj);
        }
        return null;
      }
      static fromJsonRef(json) {
        if (check_exports.is(json, typedJsonBlobRef)) {
          return new BlobRef(json.ref, json.mimeType, json.size);
        } else {
          return new BlobRef(CID.parse(json.cid), json.mimeType, -1, json);
        }
      }
      ipld() {
        return {
          $type: "blob",
          ref: this.ref,
          mimeType: this.mimeType,
          size: this.size
        };
      }
      toJSON() {
        return ipldToJson(this.ipld());
      }
    };
    function blob(lexicons2, path, def2, value) {
      if (!value || !(value instanceof BlobRef)) {
        return {
          success: false,
          error: new ValidationError(`${path} should be a blob ref`)
        };
      }
      return { success: true, value };
    }
    function validate22(lexicons2, path, def2, value) {
      switch (def2.type) {
        case "boolean":
          return boolean(lexicons2, path, def2, value);
        case "integer":
          return integer(lexicons2, path, def2, value);
        case "string":
          return string2(lexicons2, path, def2, value);
        case "bytes":
          return bytes(lexicons2, path, def2, value);
        case "cid-link":
          return cidLink(lexicons2, path, def2, value);
        case "unknown":
          return unknown(lexicons2, path, def2, value);
        case "object":
          return object(lexicons2, path, def2, value);
        case "array":
          return array(lexicons2, path, def2, value);
        case "blob":
          return blob(lexicons2, path, def2, value);
        default:
          return {
            success: false,
            error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
          };
      }
    }
    function array(lexicons2, path, def2, value) {
      if (!Array.isArray(value)) {
        return {
          success: false,
          error: new ValidationError(`${path} must be an array`)
        };
      }
      if (typeof def2.maxLength === "number") {
        if (value.length > def2.maxLength) {
          return {
            success: false,
            error: new ValidationError(`${path} must not have more than ${def2.maxLength} elements`)
          };
        }
      }
      if (typeof def2.minLength === "number") {
        if (value.length < def2.minLength) {
          return {
            success: false,
            error: new ValidationError(`${path} must not have fewer than ${def2.minLength} elements`)
          };
        }
      }
      const itemsDef = def2.items;
      for (let i = 0; i < value.length; i++) {
        const itemValue = value[i];
        const itemPath = `${path}/${i}`;
        const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);
        if (!res.success) {
          return res;
        }
      }
      return { success: true, value };
    }
    function object(lexicons2, path, def2, value) {
      def2 = def2;
      if (!value || typeof value !== "object") {
        return {
          success: false,
          error: new ValidationError(`${path} must be an object`)
        };
      }
      const requiredProps = new Set(def2.required);
      const nullableProps = new Set(def2.nullable);
      let resultValue = value;
      if (typeof def2.properties === "object") {
        for (const key in def2.properties) {
          if (value[key] === null && nullableProps.has(key)) {
            continue;
          }
          const propDef = def2.properties[key];
          const propPath = `${path}/${key}`;
          const validated = validateOneOf(lexicons2, propPath, propDef, value[key]);
          const propValue = validated.success ? validated.value : value[key];
          const propIsUndefined = typeof propValue === "undefined";
          if (propIsUndefined && requiredProps.has(key)) {
            return {
              success: false,
              error: new ValidationError(`${path} must have the property "${key}"`)
            };
          } else if (!propIsUndefined && !validated.success) {
            return validated;
          }
          if (propValue !== value[key]) {
            if (resultValue === value) {
              resultValue = { ...value };
            }
            resultValue[key] = propValue;
          }
        }
      }
      return { success: true, value: resultValue };
    }
    function toLexUri(str, baseUri) {
      if (str.split("#").length > 2) {
        throw new Error("Uri can only have one hash segment");
      }
      if (str.startsWith("lex:")) {
        return str;
      }
      if (str.startsWith("#")) {
        if (!baseUri) {
          throw new Error(`Unable to resolve uri without anchor: ${str}`);
        }
        return `${baseUri}${str}`;
      }
      return `lex:${str}`;
    }
    function validateOneOf(lexicons2, path, def2, value, mustBeObj = false) {
      let error;
      let concreteDefs;
      if (def2.type === "union") {
        if (!isDiscriminatedObject(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object which includes the "$type" property`)
          };
        }
        if (!refsContainType(def2.refs, value.$type)) {
          if (def2.closed) {
            return {
              success: false,
              error: new ValidationError(`${path} $type must be one of ${def2.refs.join(", ")}`)
            };
          }
          return { success: true, value };
        } else {
          concreteDefs = toConcreteTypes(lexicons2, {
            type: "ref",
            ref: value.$type
          });
        }
      } else {
        concreteDefs = toConcreteTypes(lexicons2, def2);
      }
      for (const concreteDef of concreteDefs) {
        const result = mustBeObj ? object(lexicons2, path, concreteDef, value) : validate22(lexicons2, path, concreteDef, value);
        if (result.success) {
          return result;
        }
        error != null ? error : error = result.error;
      }
      if (concreteDefs.length > 1) {
        return {
          success: false,
          error: new ValidationError(`${path} did not match any of the expected definitions`)
        };
      }
      return { success: false, error };
    }
    function assertValidOneOf(lexicons2, path, def2, value, mustBeObj = false) {
      const res = validateOneOf(lexicons2, path, def2, value, mustBeObj);
      if (!res.success)
        throw res.error;
      return res.value;
    }
    function toConcreteTypes(lexicons2, def2) {
      if (def2.type === "ref") {
        return [lexicons2.getDefOrThrow(def2.ref)];
      } else if (def2.type === "union") {
        return def2.refs.map((ref) => lexicons2.getDefOrThrow(ref)).flat();
      } else {
        return [def2];
      }
    }
    function requiredPropertiesRefinement(object2, ctx) {
      if (object2.required === void 0) {
        return;
      }
      if (!Array.isArray(object2.required)) {
        ctx.addIssue({
          code: z.ZodIssueCode.invalid_type,
          received: typeof object2.required,
          expected: "array"
        });
        return;
      }
      if (object2.properties === void 0) {
        if (object2.required.length > 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Required fields defined but no properties defined`
          });
        }
        return;
      }
      for (const field of object2.required) {
        if (object2.properties[field] === void 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Required field "${field}" not defined`
          });
        }
      }
    }
    var refsContainType = (refs, type) => {
      const lexUri = toLexUri(type);
      if (refs.includes(lexUri)) {
        return true;
      }
      if (lexUri.endsWith("#main")) {
        return refs.includes(lexUri.replace("#main", ""));
      } else {
        return refs.includes(lexUri + "#main");
      }
    };
    var lexBoolean = z.object({
      type: z.literal("boolean"),
      description: z.string().optional(),
      default: z.boolean().optional(),
      const: z.boolean().optional()
    }).strict();
    var lexInteger = z.object({
      type: z.literal("integer"),
      description: z.string().optional(),
      default: z.number().int().optional(),
      minimum: z.number().int().optional(),
      maximum: z.number().int().optional(),
      enum: z.number().int().array().optional(),
      const: z.number().int().optional()
    }).strict();
    var lexStringFormat = z.enum([
      "datetime",
      "uri",
      "at-uri",
      "did",
      "handle",
      "at-identifier",
      "nsid",
      "cid",
      "language"
    ]);
    var lexString = z.object({
      type: z.literal("string"),
      format: lexStringFormat.optional(),
      description: z.string().optional(),
      default: z.string().optional(),
      minLength: z.number().int().optional(),
      maxLength: z.number().int().optional(),
      minGraphemes: z.number().int().optional(),
      maxGraphemes: z.number().int().optional(),
      enum: z.string().array().optional(),
      const: z.string().optional(),
      knownValues: z.string().array().optional()
    }).strict();
    var lexUnknown = z.object({
      type: z.literal("unknown"),
      description: z.string().optional()
    }).strict();
    var lexPrimitive = z.discriminatedUnion("type", [
      lexBoolean,
      lexInteger,
      lexString,
      lexUnknown
    ]);
    var lexBytes = z.object({
      type: z.literal("bytes"),
      description: z.string().optional(),
      maxLength: z.number().optional(),
      minLength: z.number().optional()
    }).strict();
    var lexCidLink = z.object({
      type: z.literal("cid-link"),
      description: z.string().optional()
    }).strict();
    var lexIpldType = z.discriminatedUnion("type", [lexBytes, lexCidLink]);
    var lexRef = z.object({
      type: z.literal("ref"),
      description: z.string().optional(),
      ref: z.string()
    }).strict();
    var lexRefUnion = z.object({
      type: z.literal("union"),
      description: z.string().optional(),
      refs: z.string().array(),
      closed: z.boolean().optional()
    }).strict();
    var lexRefVariant = z.discriminatedUnion("type", [lexRef, lexRefUnion]);
    var lexBlob = z.object({
      type: z.literal("blob"),
      description: z.string().optional(),
      accept: z.string().array().optional(),
      maxSize: z.number().optional()
    }).strict();
    var lexArray = z.object({
      type: z.literal("array"),
      description: z.string().optional(),
      items: z.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),
      minLength: z.number().int().optional(),
      maxLength: z.number().int().optional()
    }).strict();
    var lexPrimitiveArray = lexArray.merge(z.object({
      items: lexPrimitive
    }).strict());
    var lexToken = z.object({
      type: z.literal("token"),
      description: z.string().optional()
    }).strict();
    var lexObject = z.object({
      type: z.literal("object"),
      description: z.string().optional(),
      required: z.string().array().optional(),
      nullable: z.string().array().optional(),
      properties: z.record(z.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive]))
    }).strict().superRefine(requiredPropertiesRefinement);
    var lexXrpcParameters = z.object({
      type: z.literal("params"),
      description: z.string().optional(),
      required: z.string().array().optional(),
      properties: z.record(z.union([lexPrimitive, lexPrimitiveArray]))
    }).strict().superRefine(requiredPropertiesRefinement);
    var lexXrpcBody = z.object({
      description: z.string().optional(),
      encoding: z.string(),
      schema: z.union([lexRefVariant, lexObject]).optional()
    }).strict();
    var lexXrpcSubscriptionMessage = z.object({
      description: z.string().optional(),
      schema: z.union([lexRefVariant, lexObject]).optional()
    }).strict();
    var lexXrpcError = z.object({
      name: z.string(),
      description: z.string().optional()
    }).strict();
    var lexXrpcQuery = z.object({
      type: z.literal("query"),
      description: z.string().optional(),
      parameters: lexXrpcParameters.optional(),
      output: lexXrpcBody.optional(),
      errors: lexXrpcError.array().optional()
    }).strict();
    var lexXrpcProcedure = z.object({
      type: z.literal("procedure"),
      description: z.string().optional(),
      parameters: lexXrpcParameters.optional(),
      input: lexXrpcBody.optional(),
      output: lexXrpcBody.optional(),
      errors: lexXrpcError.array().optional()
    }).strict();
    var lexXrpcSubscription = z.object({
      type: z.literal("subscription"),
      description: z.string().optional(),
      parameters: lexXrpcParameters.optional(),
      message: lexXrpcSubscriptionMessage.optional(),
      errors: lexXrpcError.array().optional()
    }).strict();
    var lexRecord = z.object({
      type: z.literal("record"),
      description: z.string().optional(),
      key: z.string().optional(),
      record: lexObject
    }).strict();
    var lexUserType = z.custom((val) => {
      if (!val || typeof val !== "object") {
        return;
      }
      if (val["type"] === void 0) {
        return;
      }
      switch (val["type"]) {
        case "record":
          return lexRecord.parse(val);
        case "query":
          return lexXrpcQuery.parse(val);
        case "procedure":
          return lexXrpcProcedure.parse(val);
        case "subscription":
          return lexXrpcSubscription.parse(val);
        case "blob":
          return lexBlob.parse(val);
        case "array":
          return lexArray.parse(val);
        case "token":
          return lexToken.parse(val);
        case "object":
          return lexObject.parse(val);
        case "boolean":
          return lexBoolean.parse(val);
        case "integer":
          return lexInteger.parse(val);
        case "string":
          return lexString.parse(val);
        case "bytes":
          return lexBytes.parse(val);
        case "cid-link":
          return lexCidLink.parse(val);
        case "unknown":
          return lexUnknown.parse(val);
      }
    }, (val) => {
      if (!val || typeof val !== "object") {
        return {
          message: "Must be an object",
          fatal: true
        };
      }
      if (val["type"] === void 0) {
        return {
          message: "Must have a type",
          fatal: true
        };
      }
      return {
        message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
        fatal: true
      };
    });
    var lexiconDoc = z.object({
      lexicon: z.literal(1),
      id: z.string().refine((v) => NSID.isValid(v), {
        message: "Must be a valid NSID"
      }),
      revision: z.number().optional(),
      description: z.string().optional(),
      defs: z.record(lexUserType)
    }).strict().superRefine((doc, ctx) => {
      for (const defId in doc.defs) {
        const def2 = doc.defs[defId];
        if (defId !== "main" && (def2.type === "record" || def2.type === "procedure" || def2.type === "query" || def2.type === "subscription")) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Records, procedures, queries, and subscriptions must be the main definition.`
          });
        }
      }
    });
    function isObj(obj) {
      return obj !== null && typeof obj === "object";
    }
    function hasProp(data, prop) {
      return prop in data;
    }
    var discriminatedObject = z.object({ $type: z.string() });
    function isDiscriminatedObject(value) {
      return discriminatedObject.safeParse(value).success;
    }
    var ValidationError = class extends Error {
    };
    var InvalidLexiconError = class extends Error {
    };
    var LexiconDefNotFoundError = class extends Error {
    };
    function params(lexicons2, path, def2, val) {
      var _a;
      const value = val && typeof val === "object" ? val : {};
      const requiredProps = new Set((_a = def2.required) != null ? _a : []);
      let resultValue = value;
      if (typeof def2.properties === "object") {
        for (const key in def2.properties) {
          const propDef = def2.properties[key];
          const validated = propDef.type === "array" ? array(lexicons2, key, propDef, value[key]) : validate2(lexicons2, key, propDef, value[key]);
          const propValue = validated.success ? validated.value : value[key];
          const propIsUndefined = typeof propValue === "undefined";
          if (propIsUndefined && requiredProps.has(key)) {
            return {
              success: false,
              error: new ValidationError(`${path} must have the property "${key}"`)
            };
          } else if (!propIsUndefined && !validated.success) {
            return validated;
          }
          if (propValue !== value[key]) {
            if (resultValue === value) {
              resultValue = { ...value };
            }
            resultValue[key] = propValue;
          }
        }
      }
      return { success: true, value: resultValue };
    }
    function assertValidRecord(lexicons2, def2, value) {
      const res = object(lexicons2, "Record", def2.record, value);
      if (!res.success)
        throw res.error;
      return res.value;
    }
    function assertValidXrpcParams(lexicons2, def2, value) {
      if (def2.parameters) {
        const res = params(lexicons2, "Params", def2.parameters, value);
        if (!res.success)
          throw res.error;
        return res.value;
      }
    }
    function assertValidXrpcInput(lexicons2, def2, value) {
      var _a;
      if ((_a = def2.input) == null ? void 0 : _a.schema) {
        return assertValidOneOf(lexicons2, "Input", def2.input.schema, value, true);
      }
    }
    function assertValidXrpcOutput(lexicons2, def2, value) {
      var _a;
      if ((_a = def2.output) == null ? void 0 : _a.schema) {
        return assertValidOneOf(lexicons2, "Output", def2.output.schema, value, true);
      }
    }
    function assertValidXrpcMessage(lexicons2, def2, value) {
      var _a;
      if ((_a = def2.message) == null ? void 0 : _a.schema) {
        return assertValidOneOf(lexicons2, "Message", def2.message.schema, value, true);
      }
    }
    var Lexicons = class {
      constructor(docs) {
        this.docs = /* @__PURE__ */ new Map();
        this.defs = /* @__PURE__ */ new Map();
        if (docs == null ? void 0 : docs.length) {
          for (const doc of docs) {
            this.add(doc);
          }
        }
      }
      add(doc) {
        const uri2 = toLexUri(doc.id);
        if (this.docs.has(uri2)) {
          throw new Error(`${uri2} has already been registered`);
        }
        resolveRefUris(doc, uri2);
        this.docs.set(uri2, doc);
        for (const [defUri, def2] of iterDefs(doc)) {
          this.defs.set(defUri, def2);
        }
      }
      remove(uri2) {
        uri2 = toLexUri(uri2);
        const doc = this.docs.get(uri2);
        if (!doc) {
          throw new Error(`Unable to remove "${uri2}": does not exist`);
        }
        for (const [defUri, _def] of iterDefs(doc)) {
          this.defs.delete(defUri);
        }
        this.docs.delete(uri2);
      }
      get(uri2) {
        uri2 = toLexUri(uri2);
        return this.docs.get(uri2);
      }
      getDef(uri2) {
        uri2 = toLexUri(uri2);
        return this.defs.get(uri2);
      }
      getDefOrThrow(uri2, types3) {
        const def2 = this.getDef(uri2);
        if (!def2) {
          throw new LexiconDefNotFoundError(`Lexicon not found: ${uri2}`);
        }
        if (types3 && !types3.includes(def2.type)) {
          throw new InvalidLexiconError(`Not a ${types3.join(" or ")} lexicon: ${uri2}`);
        }
        return def2;
      }
      validate(lexUri, value) {
        lexUri = toLexUri(lexUri);
        const def2 = this.getDefOrThrow(lexUri, ["record", "object"]);
        if (!isObj(value)) {
          throw new ValidationError(`Value must be an object`);
        }
        if (def2.type === "record") {
          return object(this, "Record", def2.record, value);
        } else if (def2.type === "object") {
          return object(this, "Object", def2, value);
        } else {
          throw new InvalidLexiconError("Definition must be a record or object");
        }
      }
      assertValidRecord(lexUri, value) {
        lexUri = toLexUri(lexUri);
        const def2 = this.getDefOrThrow(lexUri, ["record"]);
        if (!isObj(value)) {
          throw new ValidationError(`Record must be an object`);
        }
        if (!hasProp(value, "$type") || typeof value.$type !== "string") {
          throw new ValidationError(`Record/$type must be a string`);
        }
        const $type = value.$type || "";
        if (toLexUri($type) !== lexUri) {
          throw new ValidationError(`Invalid $type: must be ${lexUri}, got ${$type}`);
        }
        return assertValidRecord(this, def2, value);
      }
      assertValidXrpcParams(lexUri, value) {
        lexUri = toLexUri(lexUri);
        const def2 = this.getDefOrThrow(lexUri, [
          "query",
          "procedure",
          "subscription"
        ]);
        return assertValidXrpcParams(this, def2, value);
      }
      assertValidXrpcInput(lexUri, value) {
        lexUri = toLexUri(lexUri);
        const def2 = this.getDefOrThrow(lexUri, ["procedure"]);
        return assertValidXrpcInput(this, def2, value);
      }
      assertValidXrpcOutput(lexUri, value) {
        lexUri = toLexUri(lexUri);
        const def2 = this.getDefOrThrow(lexUri, ["query", "procedure"]);
        return assertValidXrpcOutput(this, def2, value);
      }
      assertValidXrpcMessage(lexUri, value) {
        lexUri = toLexUri(lexUri);
        const def2 = this.getDefOrThrow(lexUri, ["subscription"]);
        return assertValidXrpcMessage(this, def2, value);
      }
      resolveLexUri(lexUri, ref) {
        lexUri = toLexUri(lexUri);
        return toLexUri(ref, lexUri);
      }
    };
    function* iterDefs(doc) {
      for (const defId in doc.defs) {
        yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];
        if (defId === "main") {
          yield [`lex:${doc.id}`, doc.defs[defId]];
        }
      }
    }
    function resolveRefUris(obj, baseUri) {
      for (const k in obj) {
        if (obj.type === "ref") {
          obj.ref = toLexUri(obj.ref, baseUri);
        } else if (obj.type === "union") {
          obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri));
        } else if (Array.isArray(obj[k])) {
          obj[k] = obj[k].map((item) => {
            if (typeof item === "string") {
              return item.startsWith("#") ? toLexUri(item, baseUri) : item;
            } else if (item && typeof item === "object") {
              return resolveRefUris(item, baseUri);
            }
            return item;
          });
        } else if (obj[k] && typeof obj[k] === "object") {
          obj[k] = resolveRefUris(obj[k], baseUri);
        }
      }
      return obj;
    }
    var lexToIpld = (val) => {
      if (Array.isArray(val)) {
        return val.map((item) => lexToIpld(item));
      }
      if (val && typeof val === "object") {
        if (val instanceof BlobRef) {
          return val.original;
        }
        if (CID.asCID(val) || val instanceof Uint8Array) {
          return val;
        }
        const toReturn = {};
        for (const key of Object.keys(val)) {
          toReturn[key] = lexToIpld(val[key]);
        }
        return toReturn;
      }
      return val;
    };
    var ipldToLex = (val) => {
      if (Array.isArray(val)) {
        return val.map((item) => ipldToLex(item));
      }
      if (val && typeof val === "object") {
        if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && check_exports.is(val, jsonBlobRef)) {
          return BlobRef.fromJsonRef(val);
        }
        if (CID.asCID(val) || val instanceof Uint8Array) {
          return val;
        }
        const toReturn = {};
        for (const key of Object.keys(val)) {
          toReturn[key] = ipldToLex(val[key]);
        }
        return toReturn;
      }
      return val;
    };
    var lexToJson = (val) => {
      return ipldToJson(lexToIpld(val));
    };
    var stringifyLex = (val) => {
      return JSON.stringify(lexToJson(val));
    };
    var jsonToLex = (val) => {
      return ipldToLex(jsonToIpld(val));
    };
    var jsonStringToLex = (val) => {
      return jsonToLex(JSON.parse(val));
    };
    var errorResponseBody = z.object({
      error: z.string().optional(),
      message: z.string().optional()
    });
    var ResponseType = /* @__PURE__ */ ((ResponseType2) => {
      ResponseType2[ResponseType2["Unknown"] = 1] = "Unknown";
      ResponseType2[ResponseType2["InvalidResponse"] = 2] = "InvalidResponse";
      ResponseType2[ResponseType2["Success"] = 200] = "Success";
      ResponseType2[ResponseType2["InvalidRequest"] = 400] = "InvalidRequest";
      ResponseType2[ResponseType2["AuthRequired"] = 401] = "AuthRequired";
      ResponseType2[ResponseType2["Forbidden"] = 403] = "Forbidden";
      ResponseType2[ResponseType2["XRPCNotSupported"] = 404] = "XRPCNotSupported";
      ResponseType2[ResponseType2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
      ResponseType2[ResponseType2["RateLimitExceeded"] = 429] = "RateLimitExceeded";
      ResponseType2[ResponseType2["InternalServerError"] = 500] = "InternalServerError";
      ResponseType2[ResponseType2["MethodNotImplemented"] = 501] = "MethodNotImplemented";
      ResponseType2[ResponseType2["UpstreamFailure"] = 502] = "UpstreamFailure";
      ResponseType2[ResponseType2["NotEnoughResources"] = 503] = "NotEnoughResources";
      ResponseType2[ResponseType2["UpstreamTimeout"] = 504] = "UpstreamTimeout";
      return ResponseType2;
    })(ResponseType || {});
    var ResponseTypeNames = {
      [
        2
        /* InvalidResponse */
      ]: "InvalidResponse",
      [
        200
        /* Success */
      ]: "Success",
      [
        400
        /* InvalidRequest */
      ]: "InvalidRequest",
      [
        401
        /* AuthRequired */
      ]: "AuthenticationRequired",
      [
        403
        /* Forbidden */
      ]: "Forbidden",
      [
        404
        /* XRPCNotSupported */
      ]: "XRPCNotSupported",
      [
        413
        /* PayloadTooLarge */
      ]: "PayloadTooLarge",
      [
        429
        /* RateLimitExceeded */
      ]: "RateLimitExceeded",
      [
        500
        /* InternalServerError */
      ]: "InternalServerError",
      [
        501
        /* MethodNotImplemented */
      ]: "MethodNotImplemented",
      [
        502
        /* UpstreamFailure */
      ]: "UpstreamFailure",
      [
        503
        /* NotEnoughResources */
      ]: "NotEnoughResources",
      [
        504
        /* UpstreamTimeout */
      ]: "UpstreamTimeout"
    };
    var ResponseTypeStrings = {
      [
        2
        /* InvalidResponse */
      ]: "Invalid Response",
      [
        200
        /* Success */
      ]: "Success",
      [
        400
        /* InvalidRequest */
      ]: "Invalid Request",
      [
        401
        /* AuthRequired */
      ]: "Authentication Required",
      [
        403
        /* Forbidden */
      ]: "Forbidden",
      [
        404
        /* XRPCNotSupported */
      ]: "XRPC Not Supported",
      [
        413
        /* PayloadTooLarge */
      ]: "Payload Too Large",
      [
        429
        /* RateLimitExceeded */
      ]: "Rate Limit Exceeded",
      [
        500
        /* InternalServerError */
      ]: "Internal Server Error",
      [
        501
        /* MethodNotImplemented */
      ]: "Method Not Implemented",
      [
        502
        /* UpstreamFailure */
      ]: "Upstream Failure",
      [
        503
        /* NotEnoughResources */
      ]: "Not Enough Resources",
      [
        504
        /* UpstreamTimeout */
      ]: "Upstream Timeout"
    };
    var XRPCResponse = class {
      constructor(data, headers) {
        this.data = data;
        this.headers = headers;
        this.success = true;
      }
    };
    var XRPCError = class extends Error {
      constructor(status, error, message, headers) {
        super(message || error || ResponseTypeStrings[status]);
        this.status = status;
        this.error = error;
        this.success = false;
        if (!this.error) {
          this.error = ResponseTypeNames[status];
        }
        this.headers = headers;
      }
    };
    var XRPCInvalidResponseError = class extends XRPCError {
      constructor(lexiconNsid, validationError, responseBody) {
        super(2, ResponseTypeStrings[
          2
          /* InvalidResponse */
        ], `The server gave an invalid response and may be out of date.`);
        this.lexiconNsid = lexiconNsid;
        this.validationError = validationError;
        this.responseBody = responseBody;
      }
    };
    function getMethodSchemaHTTPMethod(schema2) {
      if (schema2.type === "procedure") {
        return "post";
      }
      return "get";
    }
    function constructMethodCallUri(nsid2, schema2, serviceUri, params2) {
      var _a, _b;
      const uri2 = new URL(serviceUri);
      uri2.pathname = `/xrpc/${nsid2}`;
      if (params2) {
        for (const [key, value] of Object.entries(params2)) {
          const paramSchema = (_b = (_a = schema2.parameters) == null ? void 0 : _a.properties) == null ? void 0 : _b[key];
          if (!paramSchema) {
            throw new Error(`Invalid query parameter: ${key}`);
          }
          if (value !== void 0) {
            if (paramSchema.type === "array") {
              const vals = [];
              vals.concat(value).forEach((val) => {
                uri2.searchParams.append(key, encodeQueryParam(paramSchema.items.type, val));
              });
            } else {
              uri2.searchParams.set(key, encodeQueryParam(paramSchema.type, value));
            }
          }
        }
      }
      return uri2.toString();
    }
    function encodeQueryParam(type, value) {
      if (type === "string" || type === "unknown") {
        return String(value);
      }
      if (type === "float") {
        return String(Number(value));
      } else if (type === "integer") {
        return String(Number(value) | 0);
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "datetime") {
        if (value instanceof Date) {
          return value.toISOString();
        }
        return String(value);
      }
      throw new Error(`Unsupported query param type: ${type}`);
    }
    function normalizeHeaders(headers) {
      const normalized = {};
      for (const [header, value] of Object.entries(headers)) {
        normalized[header.toLowerCase()] = value;
      }
      return normalized;
    }
    function constructMethodCallHeaders(schema2, data, opts) {
      const headers = (opts == null ? void 0 : opts.headers) || {};
      if (schema2.type === "procedure") {
        if (opts == null ? void 0 : opts.encoding) {
          headers["Content-Type"] = opts.encoding;
        }
        if (data && typeof data === "object") {
          if (!headers["Content-Type"]) {
            headers["Content-Type"] = "application/json";
          }
        }
      }
      return headers;
    }
    function encodeMethodCallBody(headers, data) {
      if (!headers["content-type"] || typeof data === "undefined") {
        return void 0;
      }
      if (data instanceof ArrayBuffer) {
        return data;
      }
      if (headers["content-type"].startsWith("text/")) {
        return new TextEncoder().encode(data.toString());
      }
      if (headers["content-type"].startsWith("application/json")) {
        return new TextEncoder().encode(stringifyLex(data));
      }
      return data;
    }
    function httpResponseCodeToEnum(status) {
      let resCode;
      if (status in ResponseType) {
        resCode = status;
      } else if (status >= 100 && status < 200) {
        resCode = 404;
      } else if (status >= 200 && status < 300) {
        resCode = 200;
      } else if (status >= 300 && status < 400) {
        resCode = 404;
      } else if (status >= 400 && status < 500) {
        resCode = 400;
      } else {
        resCode = 500;
      }
      return resCode;
    }
    function httpResponseBodyParse(mimeType, data) {
      if (mimeType) {
        if (mimeType.includes("application/json") && (data == null ? void 0 : data.byteLength)) {
          try {
            const str = new TextDecoder().decode(data);
            return jsonStringToLex(str);
          } catch (e) {
            throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
          }
        }
        if (mimeType.startsWith("text/") && (data == null ? void 0 : data.byteLength)) {
          try {
            return new TextDecoder().decode(data);
          } catch (e) {
            throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
          }
        }
      }
      if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
      }
      return data;
    }
    var Client = class {
      constructor() {
        this.fetch = defaultFetchHandler;
        this.lex = new Lexicons();
      }
      async call(serviceUri, methodNsid, params2, data, opts) {
        return this.service(serviceUri).call(methodNsid, params2, data, opts);
      }
      service(serviceUri) {
        return new ServiceClient(this, serviceUri);
      }
      addLexicon(doc) {
        this.lex.add(doc);
      }
      addLexicons(docs) {
        for (const doc of docs) {
          this.addLexicon(doc);
        }
      }
      removeLexicon(uri2) {
        this.lex.remove(uri2);
      }
    };
    var ServiceClient = class {
      constructor(baseClient, serviceUri) {
        this.headers = {};
        this.baseClient = baseClient;
        this.uri = typeof serviceUri === "string" ? new URL(serviceUri) : serviceUri;
      }
      setHeader(key, value) {
        this.headers[key] = value;
      }
      unsetHeader(key) {
        delete this.headers[key];
      }
      async call(methodNsid, params2, data, opts) {
        const def2 = this.baseClient.lex.getDefOrThrow(methodNsid);
        if (!def2 || def2.type !== "query" && def2.type !== "procedure") {
          throw new Error(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
        }
        const httpMethod = getMethodSchemaHTTPMethod(def2);
        const httpUri = constructMethodCallUri(methodNsid, def2, this.uri, params2);
        const httpHeaders = constructMethodCallHeaders(def2, data, {
          headers: {
            ...this.headers,
            ...opts == null ? void 0 : opts.headers
          },
          encoding: opts == null ? void 0 : opts.encoding
        });
        const res = await this.baseClient.fetch(httpUri, httpMethod, httpHeaders, data);
        const resCode = httpResponseCodeToEnum(res.status);
        if (resCode === 200) {
          try {
            this.baseClient.lex.assertValidXrpcOutput(methodNsid, res.body);
          } catch (e) {
            if (e instanceof ValidationError) {
              throw new XRPCInvalidResponseError(methodNsid, e, res.body);
            } else {
              throw e;
            }
          }
          return new XRPCResponse(res.body, res.headers);
        } else {
          if (res.body && isErrorResponseBody(res.body)) {
            throw new XRPCError(resCode, res.body.error, res.body.message, res.headers);
          } else {
            throw new XRPCError(resCode);
          }
        }
      }
    };
    async function defaultFetchHandler(httpUri, httpMethod, httpHeaders, httpReqBody) {
      try {
        const headers = normalizeHeaders(httpHeaders);
        const reqInit = {
          method: httpMethod,
          headers,
          body: encodeMethodCallBody(headers, httpReqBody),
          duplex: "half"
        };
        const res = await fetch(httpUri, reqInit);
        const resBody = await res.arrayBuffer();
        return {
          status: res.status,
          headers: Object.fromEntries(res.headers.entries()),
          body: httpResponseBodyParse(res.headers.get("content-type"), resBody)
        };
      } catch (e) {
        throw new XRPCError(1, String(e));
      }
    }
    function isErrorResponseBody(v) {
      return errorResponseBody.safeParse(v).success;
    }
    var defaultInst = new Client();
    var schemaDict = {
      ComAtprotoAdminDefs: {
        lexicon: 1,
        id: "com.atproto.admin.defs",
        defs: {
          statusAttr: {
            type: "object",
            required: ["applied"],
            properties: {
              applied: {
                type: "boolean"
              },
              ref: {
                type: "string"
              }
            }
          },
          modEventView: {
            type: "object",
            required: [
              "id",
              "event",
              "subject",
              "subjectBlobCids",
              "createdBy",
              "createdAt"
            ],
            properties: {
              id: {
                type: "integer"
              },
              event: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#modEventTakedown",
                  "lex:com.atproto.admin.defs#modEventReverseTakedown",
                  "lex:com.atproto.admin.defs#modEventComment",
                  "lex:com.atproto.admin.defs#modEventReport",
                  "lex:com.atproto.admin.defs#modEventLabel",
                  "lex:com.atproto.admin.defs#modEventAcknowledge",
                  "lex:com.atproto.admin.defs#modEventEscalate",
                  "lex:com.atproto.admin.defs#modEventMute",
                  "lex:com.atproto.admin.defs#modEventEmail"
                ]
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoRef",
                  "lex:com.atproto.repo.strongRef"
                ]
              },
              subjectBlobCids: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              creatorHandle: {
                type: "string"
              },
              subjectHandle: {
                type: "string"
              }
            }
          },
          modEventViewDetail: {
            type: "object",
            required: [
              "id",
              "event",
              "subject",
              "subjectBlobs",
              "createdBy",
              "createdAt"
            ],
            properties: {
              id: {
                type: "integer"
              },
              event: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#modEventTakedown",
                  "lex:com.atproto.admin.defs#modEventReverseTakedown",
                  "lex:com.atproto.admin.defs#modEventComment",
                  "lex:com.atproto.admin.defs#modEventReport",
                  "lex:com.atproto.admin.defs#modEventLabel",
                  "lex:com.atproto.admin.defs#modEventAcknowledge",
                  "lex:com.atproto.admin.defs#modEventEscalate",
                  "lex:com.atproto.admin.defs#modEventMute"
                ]
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoView",
                  "lex:com.atproto.admin.defs#repoViewNotFound",
                  "lex:com.atproto.admin.defs#recordView",
                  "lex:com.atproto.admin.defs#recordViewNotFound"
                ]
              },
              subjectBlobs: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#blobView"
                }
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          reportView: {
            type: "object",
            required: [
              "id",
              "reasonType",
              "subject",
              "reportedBy",
              "createdAt",
              "resolvedByActionIds"
            ],
            properties: {
              id: {
                type: "integer"
              },
              reasonType: {
                type: "ref",
                ref: "lex:com.atproto.moderation.defs#reasonType"
              },
              comment: {
                type: "string"
              },
              subjectRepoHandle: {
                type: "string"
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoRef",
                  "lex:com.atproto.repo.strongRef"
                ]
              },
              reportedBy: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              resolvedByActionIds: {
                type: "array",
                items: {
                  type: "integer"
                }
              }
            }
          },
          subjectStatusView: {
            type: "object",
            required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
            properties: {
              id: {
                type: "integer"
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoRef",
                  "lex:com.atproto.repo.strongRef"
                ]
              },
              subjectBlobCids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              },
              subjectRepoHandle: {
                type: "string"
              },
              updatedAt: {
                type: "string",
                format: "datetime",
                description: "Timestamp referencing when the last update was made to the moderation status of the subject"
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
              },
              reviewState: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#subjectReviewState"
              },
              comment: {
                type: "string",
                description: "Sticky comment on the subject."
              },
              muteUntil: {
                type: "string",
                format: "datetime"
              },
              lastReviewedBy: {
                type: "string",
                format: "did"
              },
              lastReviewedAt: {
                type: "string",
                format: "datetime"
              },
              lastReportedAt: {
                type: "string",
                format: "datetime"
              },
              takendown: {
                type: "boolean"
              },
              suspendUntil: {
                type: "string",
                format: "datetime"
              }
            }
          },
          reportViewDetail: {
            type: "object",
            required: [
              "id",
              "reasonType",
              "subject",
              "reportedBy",
              "createdAt",
              "resolvedByActions"
            ],
            properties: {
              id: {
                type: "integer"
              },
              reasonType: {
                type: "ref",
                ref: "lex:com.atproto.moderation.defs#reasonType"
              },
              comment: {
                type: "string"
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoView",
                  "lex:com.atproto.admin.defs#repoViewNotFound",
                  "lex:com.atproto.admin.defs#recordView",
                  "lex:com.atproto.admin.defs#recordViewNotFound"
                ]
              },
              subjectStatus: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#subjectStatusView"
              },
              reportedBy: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              resolvedByActions: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventView"
                }
              }
            }
          },
          repoView: {
            type: "object",
            required: [
              "did",
              "handle",
              "relatedRecords",
              "indexedAt",
              "moderation"
            ],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              email: {
                type: "string"
              },
              relatedRecords: {
                type: "array",
                items: {
                  type: "unknown"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#moderation"
              },
              invitedBy: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              },
              invitesDisabled: {
                type: "boolean"
              },
              inviteNote: {
                type: "string"
              }
            }
          },
          repoViewDetail: {
            type: "object",
            required: [
              "did",
              "handle",
              "relatedRecords",
              "indexedAt",
              "moderation"
            ],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              email: {
                type: "string"
              },
              relatedRecords: {
                type: "array",
                items: {
                  type: "unknown"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#moderationDetail"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              invitedBy: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              },
              invites: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                }
              },
              invitesDisabled: {
                type: "boolean"
              },
              inviteNote: {
                type: "string"
              },
              emailConfirmedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          accountView: {
            type: "object",
            required: ["did", "handle", "indexedAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              email: {
                type: "string"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              invitedBy: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              },
              invites: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                }
              },
              invitesDisabled: {
                type: "boolean"
              },
              emailConfirmedAt: {
                type: "string",
                format: "datetime"
              },
              inviteNote: {
                type: "string"
              }
            }
          },
          repoViewNotFound: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          repoRef: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          repoBlobRef: {
            type: "object",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              recordUri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          recordView: {
            type: "object",
            required: [
              "uri",
              "cid",
              "value",
              "blobCids",
              "indexedAt",
              "moderation",
              "repo"
            ],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              value: {
                type: "unknown"
              },
              blobCids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#moderation"
              },
              repo: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#repoView"
              }
            }
          },
          recordViewDetail: {
            type: "object",
            required: [
              "uri",
              "cid",
              "value",
              "blobs",
              "indexedAt",
              "moderation",
              "repo"
            ],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              value: {
                type: "unknown"
              },
              blobs: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#blobView"
                }
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#moderationDetail"
              },
              repo: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#repoView"
              }
            }
          },
          recordViewNotFound: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          moderation: {
            type: "object",
            properties: {
              subjectStatus: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#subjectStatusView"
              }
            }
          },
          moderationDetail: {
            type: "object",
            properties: {
              subjectStatus: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#subjectStatusView"
              }
            }
          },
          blobView: {
            type: "object",
            required: ["cid", "mimeType", "size", "createdAt"],
            properties: {
              cid: {
                type: "string",
                format: "cid"
              },
              mimeType: {
                type: "string"
              },
              size: {
                type: "integer"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              details: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#imageDetails",
                  "lex:com.atproto.admin.defs#videoDetails"
                ]
              },
              moderation: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#moderation"
              }
            }
          },
          imageDetails: {
            type: "object",
            required: ["width", "height"],
            properties: {
              width: {
                type: "integer"
              },
              height: {
                type: "integer"
              }
            }
          },
          videoDetails: {
            type: "object",
            required: ["width", "height", "length"],
            properties: {
              width: {
                type: "integer"
              },
              height: {
                type: "integer"
              },
              length: {
                type: "integer"
              }
            }
          },
          subjectReviewState: {
            type: "string",
            knownValues: [
              "lex:com.atproto.admin.defs#reviewOpen",
              "lex:com.atproto.admin.defs#reviewEscalated",
              "lex:com.atproto.admin.defs#reviewClosed"
            ]
          },
          reviewOpen: {
            type: "token",
            description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
          },
          reviewEscalated: {
            type: "token",
            description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
          },
          reviewClosed: {
            type: "token",
            description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
          },
          modEventTakedown: {
            type: "object",
            description: "Take down a subject permanently or temporarily",
            properties: {
              comment: {
                type: "string"
              },
              durationInHours: {
                type: "integer",
                description: "Indicates how long the takedown should be in effect before automatically expiring."
              }
            }
          },
          modEventReverseTakedown: {
            type: "object",
            description: "Revert take down action on a subject",
            properties: {
              comment: {
                type: "string",
                description: "Describe reasoning behind the reversal."
              }
            }
          },
          modEventComment: {
            type: "object",
            description: "Add a comment to a subject",
            required: ["comment"],
            properties: {
              comment: {
                type: "string"
              },
              sticky: {
                type: "boolean",
                description: "Make the comment persistent on the subject"
              }
            }
          },
          modEventReport: {
            type: "object",
            description: "Report a subject",
            required: ["reportType"],
            properties: {
              comment: {
                type: "string"
              },
              reportType: {
                type: "ref",
                ref: "lex:com.atproto.moderation.defs#reasonType"
              }
            }
          },
          modEventLabel: {
            type: "object",
            description: "Apply/Negate labels on a subject",
            required: ["createLabelVals", "negateLabelVals"],
            properties: {
              comment: {
                type: "string"
              },
              createLabelVals: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              negateLabelVals: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            }
          },
          modEventAcknowledge: {
            type: "object",
            properties: {
              comment: {
                type: "string"
              }
            }
          },
          modEventEscalate: {
            type: "object",
            properties: {
              comment: {
                type: "string"
              }
            }
          },
          modEventMute: {
            type: "object",
            description: "Mute incoming reports on a subject",
            required: ["durationInHours"],
            properties: {
              comment: {
                type: "string"
              },
              durationInHours: {
                type: "integer",
                description: "Indicates how long the subject should remain muted."
              }
            }
          },
          modEventUnmute: {
            type: "object",
            description: "Unmute action on a subject",
            properties: {
              comment: {
                type: "string",
                description: "Describe reasoning behind the reversal."
              }
            }
          },
          modEventEmail: {
            type: "object",
            description: "Keep a log of outgoing email to a user",
            required: ["subjectLine"],
            properties: {
              subjectLine: {
                type: "string",
                description: "The subject line of the email sent to the user."
              }
            }
          }
        }
      },
      ComAtprotoAdminDeleteAccount: {
        lexicon: 1,
        id: "com.atproto.admin.deleteAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Delete a user account as an administrator.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminDisableAccountInvites: {
        lexicon: 1,
        id: "com.atproto.admin.disableAccountInvites",
        defs: {
          main: {
            type: "procedure",
            description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["account"],
                properties: {
                  account: {
                    type: "string",
                    format: "did"
                  },
                  note: {
                    type: "string",
                    description: "Optional reason for disabled invites."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminDisableInviteCodes: {
        lexicon: 1,
        id: "com.atproto.admin.disableInviteCodes",
        defs: {
          main: {
            type: "procedure",
            description: "Disable some set of codes and/or all codes associated with a set of users.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  codes: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  accounts: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminEmitModerationEvent: {
        lexicon: 1,
        id: "com.atproto.admin.emitModerationEvent",
        defs: {
          main: {
            type: "procedure",
            description: "Take a moderation action on an actor.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["event", "subject", "createdBy"],
                properties: {
                  event: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#modEventTakedown",
                      "lex:com.atproto.admin.defs#modEventAcknowledge",
                      "lex:com.atproto.admin.defs#modEventEscalate",
                      "lex:com.atproto.admin.defs#modEventComment",
                      "lex:com.atproto.admin.defs#modEventLabel",
                      "lex:com.atproto.admin.defs#modEventReport",
                      "lex:com.atproto.admin.defs#modEventMute",
                      "lex:com.atproto.admin.defs#modEventReverseTakedown",
                      "lex:com.atproto.admin.defs#modEventUnmute",
                      "lex:com.atproto.admin.defs#modEventEmail"
                    ]
                  },
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef"
                    ]
                  },
                  subjectBlobCids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#modEventView"
              }
            },
            errors: [
              {
                name: "SubjectHasAction"
              }
            ]
          }
        }
      },
      ComAtprotoAdminEnableAccountInvites: {
        lexicon: 1,
        id: "com.atproto.admin.enableAccountInvites",
        defs: {
          main: {
            type: "procedure",
            description: "Re-enable an account's ability to receive invite codes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["account"],
                properties: {
                  account: {
                    type: "string",
                    format: "did"
                  },
                  note: {
                    type: "string",
                    description: "Optional reason for enabled invites."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminGetAccountInfo: {
        lexicon: 1,
        id: "com.atproto.admin.getAccountInfo",
        defs: {
          main: {
            type: "query",
            description: "Get details about an account.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#accountView"
              }
            }
          }
        }
      },
      ComAtprotoAdminGetInviteCodes: {
        lexicon: 1,
        id: "com.atproto.admin.getInviteCodes",
        defs: {
          main: {
            type: "query",
            description: "Get an admin view of invite codes.",
            parameters: {
              type: "params",
              properties: {
                sort: {
                  type: "string",
                  knownValues: ["recent", "usage"],
                  default: "recent"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 500,
                  default: 100
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codes"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  codes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.defs#inviteCode"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminGetModerationEvent: {
        lexicon: 1,
        id: "com.atproto.admin.getModerationEvent",
        defs: {
          main: {
            type: "query",
            description: "Get details about a moderation event.",
            parameters: {
              type: "params",
              required: ["id"],
              properties: {
                id: {
                  type: "integer"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#modEventViewDetail"
              }
            }
          }
        }
      },
      ComAtprotoAdminGetRecord: {
        lexicon: 1,
        id: "com.atproto.admin.getRecord",
        defs: {
          main: {
            type: "query",
            description: "Get details about a record.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#recordViewDetail"
              }
            },
            errors: [
              {
                name: "RecordNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoAdminGetRepo: {
        lexicon: 1,
        id: "com.atproto.admin.getRepo",
        defs: {
          main: {
            type: "query",
            description: "Get details about a repository.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#repoViewDetail"
              }
            },
            errors: [
              {
                name: "RepoNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoAdminGetSubjectStatus: {
        lexicon: 1,
        id: "com.atproto.admin.getSubjectStatus",
        defs: {
          main: {
            type: "query",
            description: "Get the service-specific admin status of a subject (account, record, or blob).",
            parameters: {
              type: "params",
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blob: {
                  type: "string",
                  format: "cid"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject"],
                properties: {
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef",
                      "lex:com.atproto.admin.defs#repoBlobRef"
                    ]
                  },
                  takedown: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminQueryModerationEvents: {
        lexicon: 1,
        id: "com.atproto.admin.queryModerationEvents",
        defs: {
          main: {
            type: "query",
            description: "List moderation events related to a subject.",
            parameters: {
              type: "params",
              properties: {
                types: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "The types of events (fully qualified string in the format of com.atproto.admin#modEvent<name>) to filter by. If not specified, all events are returned."
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                sortDirection: {
                  type: "string",
                  default: "desc",
                  enum: ["asc", "desc"],
                  description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                },
                subject: {
                  type: "string",
                  format: "uri"
                },
                includeAllUserRecords: {
                  type: "boolean",
                  default: false,
                  description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["events"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  events: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#modEventView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminQueryModerationStatuses: {
        lexicon: 1,
        id: "com.atproto.admin.queryModerationStatuses",
        defs: {
          main: {
            type: "query",
            description: "View moderation statuses of subjects (record or repo).",
            parameters: {
              type: "params",
              properties: {
                subject: {
                  type: "string",
                  format: "uri"
                },
                comment: {
                  type: "string",
                  description: "Search subjects by keyword from comments"
                },
                reportedAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reported after a given timestamp"
                },
                reportedBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reported before a given timestamp"
                },
                reviewedAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reviewed after a given timestamp"
                },
                reviewedBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reviewed before a given timestamp"
                },
                includeMuted: {
                  type: "boolean",
                  description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                },
                reviewState: {
                  type: "string",
                  description: "Specify when fetching subjects in a certain state"
                },
                ignoreSubjects: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "uri"
                  }
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did",
                  description: "Get all subject statuses that were reviewed by a specific moderator"
                },
                sortField: {
                  type: "string",
                  default: "lastReportedAt",
                  enum: ["lastReviewedAt", "lastReportedAt"]
                },
                sortDirection: {
                  type: "string",
                  default: "desc",
                  enum: ["asc", "desc"]
                },
                takendown: {
                  type: "boolean",
                  description: "Get subjects that were taken down"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subjectStatuses"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  subjectStatuses: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#subjectStatusView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminSearchRepos: {
        lexicon: 1,
        id: "com.atproto.admin.searchRepos",
        defs: {
          main: {
            type: "query",
            description: "Find repositories based on a search term.",
            parameters: {
              type: "params",
              properties: {
                term: {
                  type: "string",
                  description: "DEPRECATED: use 'q' instead"
                },
                q: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repos"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  repos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#repoView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminSendEmail: {
        lexicon: 1,
        id: "com.atproto.admin.sendEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Send email to a user's account email address.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["recipientDid", "content", "senderDid"],
                properties: {
                  recipientDid: {
                    type: "string",
                    format: "did"
                  },
                  content: {
                    type: "string"
                  },
                  subject: {
                    type: "string"
                  },
                  senderDid: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["sent"],
                properties: {
                  sent: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateAccountEmail: {
        lexicon: 1,
        id: "com.atproto.admin.updateAccountEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to update an account's email.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["account", "email"],
                properties: {
                  account: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  email: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateAccountHandle: {
        lexicon: 1,
        id: "com.atproto.admin.updateAccountHandle",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to update an account's handle.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "handle"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateSubjectStatus: {
        lexicon: 1,
        id: "com.atproto.admin.updateSubjectStatus",
        defs: {
          main: {
            type: "procedure",
            description: "Update the service-specific admin status of a subject (account, record, or blob).",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject"],
                properties: {
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef",
                      "lex:com.atproto.admin.defs#repoBlobRef"
                    ]
                  },
                  takedown: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject"],
                properties: {
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef",
                      "lex:com.atproto.admin.defs#repoBlobRef"
                    ]
                  },
                  takedown: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoIdentityResolveHandle: {
        lexicon: 1,
        id: "com.atproto.identity.resolveHandle",
        defs: {
          main: {
            type: "query",
            description: "Provides the DID of a repo.",
            parameters: {
              type: "params",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The handle to resolve."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoIdentityUpdateHandle: {
        lexicon: 1,
        id: "com.atproto.identity.updateHandle",
        defs: {
          main: {
            type: "procedure",
            description: "Updates the handle of the account.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoLabelDefs: {
        lexicon: 1,
        id: "com.atproto.label.defs",
        defs: {
          label: {
            type: "object",
            description: "Metadata tag on an atproto resource (eg, repo or record).",
            required: ["src", "uri", "val", "cts"],
            properties: {
              src: {
                type: "string",
                format: "did",
                description: "DID of the actor who created this label."
              },
              uri: {
                type: "string",
                format: "uri",
                description: "AT URI of the record, repository (account), or other resource that this label applies to."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
              },
              val: {
                type: "string",
                maxLength: 128,
                description: "The short string name of the value or type of this label."
              },
              neg: {
                type: "boolean",
                description: "If true, this is a negation label, overwriting a previous label."
              },
              cts: {
                type: "string",
                format: "datetime",
                description: "Timestamp when this label was created."
              }
            }
          },
          selfLabels: {
            type: "object",
            description: "Metadata tags on an atproto record, published by the author within the record.",
            required: ["values"],
            properties: {
              values: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#selfLabel"
                },
                maxLength: 10
              }
            }
          },
          selfLabel: {
            type: "object",
            description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
            required: ["val"],
            properties: {
              val: {
                type: "string",
                maxLength: 128,
                description: "The short string name of the value or type of this label."
              }
            }
          }
        }
      },
      ComAtprotoLabelQueryLabels: {
        lexicon: 1,
        id: "com.atproto.label.queryLabels",
        defs: {
          main: {
            type: "query",
            description: "Find labels relevant to the provided URI patterns.",
            parameters: {
              type: "params",
              required: ["uriPatterns"],
              properties: {
                uriPatterns: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                },
                sources: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  },
                  description: "Optional list of label sources (DIDs) to filter on."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 250,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["labels"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  labels: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.label.defs#label"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoLabelSubscribeLabels: {
        lexicon: 1,
        id: "com.atproto.label.subscribeLabels",
        defs: {
          main: {
            type: "subscription",
            description: "Subscribe to label updates.",
            parameters: {
              type: "params",
              properties: {
                cursor: {
                  type: "integer",
                  description: "The last known event to backfill from."
                }
              }
            },
            message: {
              schema: {
                type: "union",
                refs: [
                  "lex:com.atproto.label.subscribeLabels#labels",
                  "lex:com.atproto.label.subscribeLabels#info"
                ]
              }
            },
            errors: [
              {
                name: "FutureCursor"
              }
            ]
          },
          labels: {
            type: "object",
            required: ["seq", "labels"],
            properties: {
              seq: {
                type: "integer"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          },
          info: {
            type: "object",
            required: ["name"],
            properties: {
              name: {
                type: "string",
                knownValues: ["OutdatedCursor"]
              },
              message: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoModerationCreateReport: {
        lexicon: 1,
        id: "com.atproto.moderation.createReport",
        defs: {
          main: {
            type: "procedure",
            description: "Report a repo or a record.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["reasonType", "subject"],
                properties: {
                  reasonType: {
                    type: "ref",
                    ref: "lex:com.atproto.moderation.defs#reasonType"
                  },
                  reason: {
                    type: "string"
                  },
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef"
                    ]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [
                  "id",
                  "reasonType",
                  "subject",
                  "reportedBy",
                  "createdAt"
                ],
                properties: {
                  id: {
                    type: "integer"
                  },
                  reasonType: {
                    type: "ref",
                    ref: "lex:com.atproto.moderation.defs#reasonType"
                  },
                  reason: {
                    type: "string",
                    maxGraphemes: 2e3,
                    maxLength: 2e4
                  },
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef"
                    ]
                  },
                  reportedBy: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoModerationDefs: {
        lexicon: 1,
        id: "com.atproto.moderation.defs",
        defs: {
          reasonType: {
            type: "string",
            knownValues: [
              "com.atproto.moderation.defs#reasonSpam",
              "com.atproto.moderation.defs#reasonViolation",
              "com.atproto.moderation.defs#reasonMisleading",
              "com.atproto.moderation.defs#reasonSexual",
              "com.atproto.moderation.defs#reasonRude",
              "com.atproto.moderation.defs#reasonOther"
            ]
          },
          reasonSpam: {
            type: "token",
            description: "Spam: frequent unwanted promotion, replies, mentions"
          },
          reasonViolation: {
            type: "token",
            description: "Direct violation of server rules, laws, terms of service"
          },
          reasonMisleading: {
            type: "token",
            description: "Misleading identity, affiliation, or content"
          },
          reasonSexual: {
            type: "token",
            description: "Unwanted or mislabeled sexual content"
          },
          reasonRude: {
            type: "token",
            description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
          },
          reasonOther: {
            type: "token",
            description: "Other: reports not falling under another report category"
          }
        }
      },
      ComAtprotoRepoApplyWrites: {
        lexicon: 1,
        id: "com.atproto.repo.applyWrites",
        defs: {
          main: {
            type: "procedure",
            description: "Apply a batch transaction of creates, updates, and deletes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "writes"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  validate: {
                    type: "boolean",
                    default: true,
                    description: "Flag for validating the records."
                  },
                  writes: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.repo.applyWrites#create",
                        "lex:com.atproto.repo.applyWrites#update",
                        "lex:com.atproto.repo.applyWrites#delete"
                      ],
                      closed: true
                    }
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap"
              }
            ]
          },
          create: {
            type: "object",
            description: "Create a new record.",
            required: ["collection", "value"],
            properties: {
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                maxLength: 15
              },
              value: {
                type: "unknown"
              }
            }
          },
          update: {
            type: "object",
            description: "Update an existing record.",
            required: ["collection", "rkey", "value"],
            properties: {
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string"
              },
              value: {
                type: "unknown"
              }
            }
          },
          delete: {
            type: "object",
            description: "Delete an existing record.",
            required: ["collection", "rkey"],
            properties: {
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoRepoCreateRecord: {
        lexicon: 1,
        id: "com.atproto.repo.createRecord",
        defs: {
          main: {
            type: "procedure",
            description: "Create a new record.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "collection", "record"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The key of the record.",
                    maxLength: 15
                  },
                  validate: {
                    type: "boolean",
                    default: true,
                    description: "Flag for validating the record."
                  },
                  record: {
                    type: "unknown",
                    description: "The record to create."
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous commit by CID."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "cid"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap"
              }
            ]
          }
        }
      },
      ComAtprotoRepoDeleteRecord: {
        lexicon: 1,
        id: "com.atproto.repo.deleteRecord",
        defs: {
          main: {
            type: "procedure",
            description: "Delete a record, or ensure it doesn't exist.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The key of the record."
                  },
                  swapRecord: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous record by CID."
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous commit by CID."
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap"
              }
            ]
          }
        }
      },
      ComAtprotoRepoDescribeRepo: {
        lexicon: 1,
        id: "com.atproto.repo.describeRepo",
        defs: {
          main: {
            type: "query",
            description: "Get information about the repo, including the list of collections.",
            parameters: {
              type: "params",
              required: ["repo"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [
                  "handle",
                  "did",
                  "didDoc",
                  "collections",
                  "handleIsCorrect"
                ],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown"
                  },
                  collections: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  handleIsCorrect: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoRepoGetRecord: {
        lexicon: 1,
        id: "com.atproto.repo.getRecord",
        defs: {
          main: {
            type: "query",
            description: "Get a record.",
            parameters: {
              type: "params",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The key of the record."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "The CID of the version of the record. If not specified, then return the most recent version."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "value"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  value: {
                    type: "unknown"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoRepoListRecords: {
        lexicon: 1,
        id: "com.atproto.repo.listRecords",
        defs: {
          main: {
            type: "query",
            description: "List a range of records in a collection.",
            parameters: {
              type: "params",
              required: ["repo", "collection"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record type."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50,
                  description: "The number of records to return."
                },
                cursor: {
                  type: "string"
                },
                rkeyStart: {
                  type: "string",
                  description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
                },
                rkeyEnd: {
                  type: "string",
                  description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
                },
                reverse: {
                  type: "boolean",
                  description: "Flag to reverse the order of the returned records."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["records"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  records: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.listRecords#record"
                    }
                  }
                }
              }
            }
          },
          record: {
            type: "object",
            required: ["uri", "cid", "value"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              value: {
                type: "unknown"
              }
            }
          }
        }
      },
      ComAtprotoRepoPutRecord: {
        lexicon: 1,
        id: "com.atproto.repo.putRecord",
        defs: {
          main: {
            type: "procedure",
            description: "Write a record, creating or updating it as needed.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "collection", "rkey", "record"],
                nullable: ["swapRecord"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The key of the record.",
                    maxLength: 15
                  },
                  validate: {
                    type: "boolean",
                    default: true,
                    description: "Flag for validating the record."
                  },
                  record: {
                    type: "unknown",
                    description: "The record to write."
                  },
                  swapRecord: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous record by CID."
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous commit by CID."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "cid"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap"
              }
            ]
          }
        }
      },
      ComAtprotoRepoStrongRef: {
        lexicon: 1,
        id: "com.atproto.repo.strongRef",
        description: "A URI with a content-hash fingerprint.",
        defs: {
          main: {
            type: "object",
            required: ["uri", "cid"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          }
        }
      },
      ComAtprotoRepoUploadBlob: {
        lexicon: 1,
        id: "com.atproto.repo.uploadBlob",
        defs: {
          main: {
            type: "procedure",
            description: "Upload a new blob to be added to repo in a later request.",
            input: {
              encoding: "*/*"
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["blob"],
                properties: {
                  blob: {
                    type: "blob"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerConfirmEmail: {
        lexicon: 1,
        id: "com.atproto.server.confirmEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["email", "token"],
                properties: {
                  email: {
                    type: "string"
                  },
                  token: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountNotFound"
              },
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              },
              {
                name: "InvalidEmail"
              }
            ]
          }
        }
      },
      ComAtprotoServerCreateAccount: {
        lexicon: 1,
        id: "com.atproto.server.createAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Create an account.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle"],
                properties: {
                  email: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  inviteCode: {
                    type: "string"
                  },
                  password: {
                    type: "string"
                  },
                  recoveryKey: {
                    type: "string"
                  },
                  plcOp: {
                    type: "unknown"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown"
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidHandle"
              },
              {
                name: "InvalidPassword"
              },
              {
                name: "InvalidInviteCode"
              },
              {
                name: "HandleNotAvailable"
              },
              {
                name: "UnsupportedDomain"
              },
              {
                name: "UnresolvableDid"
              },
              {
                name: "IncompatibleDidDoc"
              }
            ]
          }
        }
      },
      ComAtprotoServerCreateAppPassword: {
        lexicon: 1,
        id: "com.atproto.server.createAppPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Create an App Password.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.server.createAppPassword#appPassword"
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          },
          appPassword: {
            type: "object",
            required: ["name", "password", "createdAt"],
            properties: {
              name: {
                type: "string"
              },
              password: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      },
      ComAtprotoServerCreateInviteCode: {
        lexicon: 1,
        id: "com.atproto.server.createInviteCode",
        defs: {
          main: {
            type: "procedure",
            description: "Create an invite code.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["useCount"],
                properties: {
                  useCount: {
                    type: "integer"
                  },
                  forAccount: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["code"],
                properties: {
                  code: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerCreateInviteCodes: {
        lexicon: 1,
        id: "com.atproto.server.createInviteCodes",
        defs: {
          main: {
            type: "procedure",
            description: "Create invite codes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codeCount", "useCount"],
                properties: {
                  codeCount: {
                    type: "integer",
                    default: 1
                  },
                  useCount: {
                    type: "integer"
                  },
                  forAccounts: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codes"],
                properties: {
                  codes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                    }
                  }
                }
              }
            }
          },
          accountCodes: {
            type: "object",
            required: ["account", "codes"],
            properties: {
              account: {
                type: "string"
              },
              codes: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            }
          }
        }
      },
      ComAtprotoServerCreateSession: {
        lexicon: 1,
        id: "com.atproto.server.createSession",
        defs: {
          main: {
            type: "procedure",
            description: "Create an authentication session.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["identifier", "password"],
                properties: {
                  identifier: {
                    type: "string",
                    description: "Handle or other identifier supported by the server for the authenticating user."
                  },
                  password: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown"
                  },
                  email: {
                    type: "string"
                  },
                  emailConfirmed: {
                    type: "boolean"
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          }
        }
      },
      ComAtprotoServerDefs: {
        lexicon: 1,
        id: "com.atproto.server.defs",
        defs: {
          inviteCode: {
            type: "object",
            required: [
              "code",
              "available",
              "disabled",
              "forAccount",
              "createdBy",
              "createdAt",
              "uses"
            ],
            properties: {
              code: {
                type: "string"
              },
              available: {
                type: "integer"
              },
              disabled: {
                type: "boolean"
              },
              forAccount: {
                type: "string"
              },
              createdBy: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              uses: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCodeUse"
                }
              }
            }
          },
          inviteCodeUse: {
            type: "object",
            required: ["usedBy", "usedAt"],
            properties: {
              usedBy: {
                type: "string",
                format: "did"
              },
              usedAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      },
      ComAtprotoServerDeleteAccount: {
        lexicon: 1,
        id: "com.atproto.server.deleteAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Delete an actor's account with a token and password.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "password", "token"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  password: {
                    type: "string"
                  },
                  token: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              }
            ]
          }
        }
      },
      ComAtprotoServerDeleteSession: {
        lexicon: 1,
        id: "com.atproto.server.deleteSession",
        defs: {
          main: {
            type: "procedure",
            description: "Delete the current session."
          }
        }
      },
      ComAtprotoServerDescribeServer: {
        lexicon: 1,
        id: "com.atproto.server.describeServer",
        defs: {
          main: {
            type: "query",
            description: "Get a document describing the service's accounts configuration.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["availableUserDomains"],
                properties: {
                  inviteCodeRequired: {
                    type: "boolean"
                  },
                  availableUserDomains: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  links: {
                    type: "ref",
                    ref: "lex:com.atproto.server.describeServer#links"
                  }
                }
              }
            }
          },
          links: {
            type: "object",
            properties: {
              privacyPolicy: {
                type: "string"
              },
              termsOfService: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoServerGetAccountInviteCodes: {
        lexicon: 1,
        id: "com.atproto.server.getAccountInviteCodes",
        defs: {
          main: {
            type: "query",
            description: "Get all invite codes for a given account.",
            parameters: {
              type: "params",
              properties: {
                includeUsed: {
                  type: "boolean",
                  default: true
                },
                createAvailable: {
                  type: "boolean",
                  default: true
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codes"],
                properties: {
                  codes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.defs#inviteCode"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "DuplicateCreate"
              }
            ]
          }
        }
      },
      ComAtprotoServerGetSession: {
        lexicon: 1,
        id: "com.atproto.server.getSession",
        defs: {
          main: {
            type: "query",
            description: "Get information about the current session.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle", "did"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  email: {
                    type: "string"
                  },
                  emailConfirmed: {
                    type: "boolean"
                  },
                  didDoc: {
                    type: "unknown"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerListAppPasswords: {
        lexicon: 1,
        id: "com.atproto.server.listAppPasswords",
        defs: {
          main: {
            type: "query",
            description: "List all App Passwords.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["passwords"],
                properties: {
                  passwords: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          },
          appPassword: {
            type: "object",
            required: ["name", "createdAt"],
            properties: {
              name: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      },
      ComAtprotoServerRefreshSession: {
        lexicon: 1,
        id: "com.atproto.server.refreshSession",
        defs: {
          main: {
            type: "procedure",
            description: "Refresh an authentication session.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown"
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          }
        }
      },
      ComAtprotoServerRequestAccountDelete: {
        lexicon: 1,
        id: "com.atproto.server.requestAccountDelete",
        defs: {
          main: {
            type: "procedure",
            description: "Initiate a user account deletion via email."
          }
        }
      },
      ComAtprotoServerRequestEmailConfirmation: {
        lexicon: 1,
        id: "com.atproto.server.requestEmailConfirmation",
        defs: {
          main: {
            type: "procedure",
            description: "Request an email with a code to confirm ownership of email."
          }
        }
      },
      ComAtprotoServerRequestEmailUpdate: {
        lexicon: 1,
        id: "com.atproto.server.requestEmailUpdate",
        defs: {
          main: {
            type: "procedure",
            description: "Request a token in order to update email.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["tokenRequired"],
                properties: {
                  tokenRequired: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerRequestPasswordReset: {
        lexicon: 1,
        id: "com.atproto.server.requestPasswordReset",
        defs: {
          main: {
            type: "procedure",
            description: "Initiate a user account password reset via email.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["email"],
                properties: {
                  email: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerReserveSigningKey: {
        lexicon: 1,
        id: "com.atproto.server.reserveSigningKey",
        defs: {
          main: {
            type: "procedure",
            description: "Reserve a repo signing key for account creation.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  did: {
                    type: "string",
                    description: "The did to reserve a new did:key for"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["signingKey"],
                properties: {
                  signingKey: {
                    type: "string",
                    description: "Public signing key in the form of a did:key."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerResetPassword: {
        lexicon: 1,
        id: "com.atproto.server.resetPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Reset a user account password using a token.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["token", "password"],
                properties: {
                  token: {
                    type: "string"
                  },
                  password: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              }
            ]
          }
        }
      },
      ComAtprotoServerRevokeAppPassword: {
        lexicon: 1,
        id: "com.atproto.server.revokeAppPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Revoke an App Password by name.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerUpdateEmail: {
        lexicon: 1,
        id: "com.atproto.server.updateEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Update an account's email.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["email"],
                properties: {
                  email: {
                    type: "string"
                  },
                  token: {
                    type: "string",
                    description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                  }
                }
              }
            },
            errors: [
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              },
              {
                name: "TokenRequired"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetBlob: {
        lexicon: 1,
        id: "com.atproto.sync.getBlob",
        defs: {
          main: {
            type: "query",
            description: "Get a blob associated with a given repo.",
            parameters: {
              type: "params",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "The CID of the blob to fetch"
                }
              }
            },
            output: {
              encoding: "*/*"
            }
          }
        }
      },
      ComAtprotoSyncGetBlocks: {
        lexicon: 1,
        id: "com.atproto.sync.getBlocks",
        defs: {
          main: {
            type: "query",
            description: "Get blocks from a given repo.",
            parameters: {
              type: "params",
              required: ["did", "cids"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            }
          }
        }
      },
      ComAtprotoSyncGetCheckout: {
        lexicon: 1,
        id: "com.atproto.sync.getCheckout",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            }
          }
        }
      },
      ComAtprotoSyncGetHead: {
        lexicon: 1,
        id: "com.atproto.sync.getHead",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["root"],
                properties: {
                  root: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            errors: [
              {
                name: "HeadNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetLatestCommit: {
        lexicon: 1,
        id: "com.atproto.sync.getLatestCommit",
        defs: {
          main: {
            type: "query",
            description: "Get the current commit CID & revision of the repo.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["cid", "rev"],
                properties: {
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  rev: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "RepoNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetRecord: {
        lexicon: 1,
        id: "com.atproto.sync.getRecord",
        defs: {
          main: {
            type: "query",
            description: "Get blocks needed for existence or non-existence of record.",
            parameters: {
              type: "params",
              required: ["did", "collection", "rkey"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                },
                commit: {
                  type: "string",
                  format: "cid",
                  description: "An optional past commit CID."
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            }
          }
        }
      },
      ComAtprotoSyncGetRepo: {
        lexicon: 1,
        id: "com.atproto.sync.getRepo",
        defs: {
          main: {
            type: "query",
            description: "Gets the DID's repo, optionally catching up from a specific revision.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                since: {
                  type: "string",
                  description: "The revision of the repo to catch up from."
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            }
          }
        }
      },
      ComAtprotoSyncListBlobs: {
        lexicon: 1,
        id: "com.atproto.sync.listBlobs",
        defs: {
          main: {
            type: "query",
            description: "List blob CIDs since some revision.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                since: {
                  type: "string",
                  description: "Optional revision of the repo to list blobs since."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 500
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["cids"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoSyncListRepos: {
        lexicon: 1,
        id: "com.atproto.sync.listRepos",
        defs: {
          main: {
            type: "query",
            description: "List DIDs and root CIDs of hosted repos.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 500
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repos"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  repos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.sync.listRepos#repo"
                    }
                  }
                }
              }
            }
          },
          repo: {
            type: "object",
            required: ["did", "head", "rev"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              head: {
                type: "string",
                format: "cid"
              },
              rev: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoSyncNotifyOfUpdate: {
        lexicon: 1,
        id: "com.atproto.sync.notifyOfUpdate",
        defs: {
          main: {
            type: "procedure",
            description: "Notify a crawling service of a recent update; often when a long break between updates causes the connection with the crawling service to break.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["hostname"],
                properties: {
                  hostname: {
                    type: "string",
                    description: "Hostname of the service that is notifying of update."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoSyncRequestCrawl: {
        lexicon: 1,
        id: "com.atproto.sync.requestCrawl",
        defs: {
          main: {
            type: "procedure",
            description: "Request a service to persistently crawl hosted repos.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["hostname"],
                properties: {
                  hostname: {
                    type: "string",
                    description: "Hostname of the service that is requesting to be crawled."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoSyncSubscribeRepos: {
        lexicon: 1,
        id: "com.atproto.sync.subscribeRepos",
        defs: {
          main: {
            type: "subscription",
            description: "Subscribe to repo updates.",
            parameters: {
              type: "params",
              properties: {
                cursor: {
                  type: "integer",
                  description: "The last known event to backfill from."
                }
              }
            },
            message: {
              schema: {
                type: "union",
                refs: [
                  "lex:com.atproto.sync.subscribeRepos#commit",
                  "lex:com.atproto.sync.subscribeRepos#handle",
                  "lex:com.atproto.sync.subscribeRepos#migrate",
                  "lex:com.atproto.sync.subscribeRepos#tombstone",
                  "lex:com.atproto.sync.subscribeRepos#info"
                ]
              }
            },
            errors: [
              {
                name: "FutureCursor"
              },
              {
                name: "ConsumerTooSlow"
              }
            ]
          },
          commit: {
            type: "object",
            required: [
              "seq",
              "rebase",
              "tooBig",
              "repo",
              "commit",
              "rev",
              "since",
              "blocks",
              "ops",
              "blobs",
              "time"
            ],
            nullable: ["prev", "since"],
            properties: {
              seq: {
                type: "integer"
              },
              rebase: {
                type: "boolean"
              },
              tooBig: {
                type: "boolean"
              },
              repo: {
                type: "string",
                format: "did"
              },
              commit: {
                type: "cid-link"
              },
              prev: {
                type: "cid-link"
              },
              rev: {
                type: "string",
                description: "The rev of the emitted commit."
              },
              since: {
                type: "string",
                description: "The rev of the last emitted commit from this repo."
              },
              blocks: {
                type: "bytes",
                description: "CAR file containing relevant blocks.",
                maxLength: 1e6
              },
              ops: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.sync.subscribeRepos#repoOp"
                },
                maxLength: 200
              },
              blobs: {
                type: "array",
                items: {
                  type: "cid-link"
                }
              },
              time: {
                type: "string",
                format: "datetime"
              }
            }
          },
          handle: {
            type: "object",
            required: ["seq", "did", "handle", "time"],
            properties: {
              seq: {
                type: "integer"
              },
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              time: {
                type: "string",
                format: "datetime"
              }
            }
          },
          migrate: {
            type: "object",
            required: ["seq", "did", "migrateTo", "time"],
            nullable: ["migrateTo"],
            properties: {
              seq: {
                type: "integer"
              },
              did: {
                type: "string",
                format: "did"
              },
              migrateTo: {
                type: "string"
              },
              time: {
                type: "string",
                format: "datetime"
              }
            }
          },
          tombstone: {
            type: "object",
            required: ["seq", "did", "time"],
            properties: {
              seq: {
                type: "integer"
              },
              did: {
                type: "string",
                format: "did"
              },
              time: {
                type: "string",
                format: "datetime"
              }
            }
          },
          info: {
            type: "object",
            required: ["name"],
            properties: {
              name: {
                type: "string",
                knownValues: ["OutdatedCursor"]
              },
              message: {
                type: "string"
              }
            }
          },
          repoOp: {
            type: "object",
            description: "A repo operation, ie a write of a single record. For creates and updates, CID is the record's CID as of this operation. For deletes, it's null.",
            required: ["action", "path", "cid"],
            nullable: ["cid"],
            properties: {
              action: {
                type: "string",
                knownValues: ["create", "update", "delete"]
              },
              path: {
                type: "string"
              },
              cid: {
                type: "cid-link"
              }
            }
          }
        }
      },
      ComAtprotoTempFetchLabels: {
        lexicon: 1,
        id: "com.atproto.temp.fetchLabels",
        defs: {
          main: {
            type: "query",
            description: "Fetch all labels from a labeler created after a certain date.",
            parameters: {
              type: "params",
              properties: {
                since: {
                  type: "integer"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 250,
                  default: 50
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["labels"],
                properties: {
                  labels: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.label.defs#label"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoTempImportRepo: {
        lexicon: 1,
        id: "com.atproto.temp.importRepo",
        defs: {
          main: {
            type: "procedure",
            description: "Gets the did's repo, optionally catching up from a specific revision.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            input: {
              encoding: "application/vnd.ipld.car"
            },
            output: {
              encoding: "text/plain"
            }
          }
        }
      },
      ComAtprotoTempPushBlob: {
        lexicon: 1,
        id: "com.atproto.temp.pushBlob",
        defs: {
          main: {
            type: "procedure",
            description: "Gets the did's repo, optionally catching up from a specific revision.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            input: {
              encoding: "*/*"
            }
          }
        }
      },
      ComAtprotoTempTransferAccount: {
        lexicon: 1,
        id: "com.atproto.temp.transferAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Transfer an account.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle", "did", "plcOp"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  plcOp: {
                    type: "unknown"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidHandle"
              },
              {
                name: "InvalidPassword"
              },
              {
                name: "InvalidInviteCode"
              },
              {
                name: "HandleNotAvailable"
              },
              {
                name: "UnsupportedDomain"
              },
              {
                name: "UnresolvableDid"
              },
              {
                name: "IncompatibleDidDoc"
              }
            ]
          }
        }
      },
      AppBskyActorDefs: {
        lexicon: 1,
        id: "app.bsky.actor.defs",
        description: "A reference to an actor in the network.",
        defs: {
          profileViewBasic: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              avatar: {
                type: "string"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          },
          profileView: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "string"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          },
          profileViewDetailed: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "string"
              },
              banner: {
                type: "string"
              },
              followersCount: {
                type: "integer"
              },
              followsCount: {
                type: "integer"
              },
              postsCount: {
                type: "integer"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          },
          viewerState: {
            type: "object",
            properties: {
              muted: {
                type: "boolean"
              },
              mutedByList: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              },
              blockedBy: {
                type: "boolean"
              },
              blocking: {
                type: "string",
                format: "at-uri"
              },
              blockingByList: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              },
              following: {
                type: "string",
                format: "at-uri"
              },
              followedBy: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          preferences: {
            type: "array",
            items: {
              type: "union",
              refs: [
                "lex:app.bsky.actor.defs#adultContentPref",
                "lex:app.bsky.actor.defs#contentLabelPref",
                "lex:app.bsky.actor.defs#savedFeedsPref",
                "lex:app.bsky.actor.defs#personalDetailsPref",
                "lex:app.bsky.actor.defs#feedViewPref",
                "lex:app.bsky.actor.defs#threadViewPref"
              ]
            }
          },
          adultContentPref: {
            type: "object",
            required: ["enabled"],
            properties: {
              enabled: {
                type: "boolean",
                default: false
              }
            }
          },
          contentLabelPref: {
            type: "object",
            required: ["label", "visibility"],
            properties: {
              label: {
                type: "string"
              },
              visibility: {
                type: "string",
                knownValues: ["show", "warn", "hide"]
              }
            }
          },
          savedFeedsPref: {
            type: "object",
            required: ["pinned", "saved"],
            properties: {
              pinned: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              },
              saved: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          },
          personalDetailsPref: {
            type: "object",
            properties: {
              birthDate: {
                type: "string",
                format: "datetime",
                description: "The birth date of account owner."
              }
            }
          },
          feedViewPref: {
            type: "object",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                description: "The URI of the feed, or an identifier which describes the feed."
              },
              hideReplies: {
                type: "boolean",
                description: "Hide replies in the feed."
              },
              hideRepliesByUnfollowed: {
                type: "boolean",
                description: "Hide replies in the feed if they are not by followed users."
              },
              hideRepliesByLikeCount: {
                type: "integer",
                description: "Hide replies in the feed if they do not have this number of likes."
              },
              hideReposts: {
                type: "boolean",
                description: "Hide reposts in the feed."
              },
              hideQuotePosts: {
                type: "boolean",
                description: "Hide quote posts in the feed."
              }
            }
          },
          threadViewPref: {
            type: "object",
            properties: {
              sort: {
                type: "string",
                description: "Sorting mode for threads.",
                knownValues: ["oldest", "newest", "most-likes", "random"]
              },
              prioritizeFollowedUsers: {
                type: "boolean",
                description: "Show followed users at the top of all replies."
              }
            }
          }
        }
      },
      AppBskyActorGetPreferences: {
        lexicon: 1,
        id: "app.bsky.actor.getPreferences",
        defs: {
          main: {
            type: "query",
            description: "Get private preferences attached to the account.",
            parameters: {
              type: "params",
              properties: {}
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["preferences"],
                properties: {
                  preferences: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#preferences"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorGetProfile: {
        lexicon: 1,
        id: "app.bsky.actor.getProfile",
        defs: {
          main: {
            type: "query",
            description: "Get detailed profile view of an actor.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewDetailed"
              }
            }
          }
        }
      },
      AppBskyActorGetProfiles: {
        lexicon: 1,
        id: "app.bsky.actor.getProfiles",
        defs: {
          main: {
            type: "query",
            description: "Get detailed profile views of multiple actors.",
            parameters: {
              type: "params",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-identifier"
                  },
                  maxLength: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["profiles"],
                properties: {
                  profiles: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorGetSuggestions: {
        lexicon: 1,
        id: "app.bsky.actor.getSuggestions",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested actors, used for discovery.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorProfile: {
        lexicon: 1,
        id: "app.bsky.actor.profile",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a profile.",
            key: "literal:self",
            record: {
              type: "object",
              properties: {
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "blob",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                banner: {
                  type: "blob",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                labels: {
                  type: "union",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                }
              }
            }
          }
        }
      },
      AppBskyActorPutPreferences: {
        lexicon: 1,
        id: "app.bsky.actor.putPreferences",
        defs: {
          main: {
            type: "procedure",
            description: "Set the private preferences attached to the account.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["preferences"],
                properties: {
                  preferences: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#preferences"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorSearchActors: {
        lexicon: 1,
        id: "app.bsky.actor.searchActors",
        defs: {
          main: {
            type: "query",
            description: "Find actors (profiles) matching search criteria.",
            parameters: {
              type: "params",
              properties: {
                term: {
                  type: "string",
                  description: "DEPRECATED: use 'q' instead."
                },
                q: {
                  type: "string",
                  description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorSearchActorsTypeahead: {
        lexicon: 1,
        id: "app.bsky.actor.searchActorsTypeahead",
        defs: {
          main: {
            type: "query",
            description: "Find actor suggestions for a prefix search term.",
            parameters: {
              type: "params",
              properties: {
                term: {
                  type: "string",
                  description: "DEPRECATED: use 'q' instead."
                },
                q: {
                  type: "string",
                  description: "Search query prefix; not a full query string."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileViewBasic"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyEmbedExternal: {
        lexicon: 1,
        id: "app.bsky.embed.external",
        description: "A representation of some externally linked content, embedded in another form of content.",
        defs: {
          main: {
            type: "object",
            required: ["external"],
            properties: {
              external: {
                type: "ref",
                ref: "lex:app.bsky.embed.external#external"
              }
            }
          },
          external: {
            type: "object",
            required: ["uri", "title", "description"],
            properties: {
              uri: {
                type: "string",
                format: "uri"
              },
              title: {
                type: "string"
              },
              description: {
                type: "string"
              },
              thumb: {
                type: "blob",
                accept: ["image/*"],
                maxSize: 1e6
              }
            }
          },
          view: {
            type: "object",
            required: ["external"],
            properties: {
              external: {
                type: "ref",
                ref: "lex:app.bsky.embed.external#viewExternal"
              }
            }
          },
          viewExternal: {
            type: "object",
            required: ["uri", "title", "description"],
            properties: {
              uri: {
                type: "string",
                format: "uri"
              },
              title: {
                type: "string"
              },
              description: {
                type: "string"
              },
              thumb: {
                type: "string"
              }
            }
          }
        }
      },
      AppBskyEmbedImages: {
        lexicon: 1,
        id: "app.bsky.embed.images",
        description: "A set of images embedded in some other form of content.",
        defs: {
          main: {
            type: "object",
            required: ["images"],
            properties: {
              images: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#image"
                },
                maxLength: 4
              }
            }
          },
          image: {
            type: "object",
            required: ["image", "alt"],
            properties: {
              image: {
                type: "blob",
                accept: ["image/*"],
                maxSize: 1e6
              },
              alt: {
                type: "string"
              },
              aspectRatio: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#aspectRatio"
              }
            }
          },
          aspectRatio: {
            type: "object",
            description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
            required: ["width", "height"],
            properties: {
              width: {
                type: "integer",
                minimum: 1
              },
              height: {
                type: "integer",
                minimum: 1
              }
            }
          },
          view: {
            type: "object",
            required: ["images"],
            properties: {
              images: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#viewImage"
                },
                maxLength: 4
              }
            }
          },
          viewImage: {
            type: "object",
            required: ["thumb", "fullsize", "alt"],
            properties: {
              thumb: {
                type: "string"
              },
              fullsize: {
                type: "string"
              },
              alt: {
                type: "string"
              },
              aspectRatio: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#aspectRatio"
              }
            }
          }
        }
      },
      AppBskyEmbedRecord: {
        lexicon: 1,
        id: "app.bsky.embed.record",
        description: "A representation of a record embedded in another form of content.",
        defs: {
          main: {
            type: "object",
            required: ["record"],
            properties: {
              record: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              }
            }
          },
          view: {
            type: "object",
            required: ["record"],
            properties: {
              record: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.record#viewRecord",
                  "lex:app.bsky.embed.record#viewNotFound",
                  "lex:app.bsky.embed.record#viewBlocked",
                  "lex:app.bsky.feed.defs#generatorView",
                  "lex:app.bsky.graph.defs#listView"
                ]
              }
            }
          },
          viewRecord: {
            type: "object",
            required: ["uri", "cid", "author", "value", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              value: {
                type: "unknown"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              embeds: {
                type: "array",
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          viewNotFound: {
            type: "object",
            required: ["uri", "notFound"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              notFound: {
                type: "boolean",
                const: true
              }
            }
          },
          viewBlocked: {
            type: "object",
            required: ["uri", "blocked", "author"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              blocked: {
                type: "boolean",
                const: true
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#blockedAuthor"
              }
            }
          }
        }
      },
      AppBskyEmbedRecordWithMedia: {
        lexicon: 1,
        id: "app.bsky.embed.recordWithMedia",
        description: "A representation of a record embedded in another form of content, alongside other compatible embeds.",
        defs: {
          main: {
            type: "object",
            required: ["record", "media"],
            properties: {
              record: {
                type: "ref",
                ref: "lex:app.bsky.embed.record"
              },
              media: {
                type: "union",
                refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
              }
            }
          },
          view: {
            type: "object",
            required: ["record", "media"],
            properties: {
              record: {
                type: "ref",
                ref: "lex:app.bsky.embed.record#view"
              },
              media: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view"
                ]
              }
            }
          }
        }
      },
      AppBskyFeedDefs: {
        lexicon: 1,
        id: "app.bsky.feed.defs",
        defs: {
          postView: {
            type: "object",
            required: ["uri", "cid", "author", "record", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              record: {
                type: "unknown"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              },
              replyCount: {
                type: "integer"
              },
              repostCount: {
                type: "integer"
              },
              likeCount: {
                type: "integer"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              threadgate: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#threadgateView"
              }
            }
          },
          viewerState: {
            type: "object",
            properties: {
              repost: {
                type: "string",
                format: "at-uri"
              },
              like: {
                type: "string",
                format: "at-uri"
              },
              replyDisabled: {
                type: "boolean"
              }
            }
          },
          feedViewPost: {
            type: "object",
            required: ["post"],
            properties: {
              post: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#postView"
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#replyRef"
              },
              reason: {
                type: "union",
                refs: ["lex:app.bsky.feed.defs#reasonRepost"]
              }
            }
          },
          replyRef: {
            type: "object",
            required: ["root", "parent"],
            properties: {
              root: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#postView",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              },
              parent: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#postView",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              }
            }
          },
          reasonRepost: {
            type: "object",
            required: ["by", "indexedAt"],
            properties: {
              by: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          threadViewPost: {
            type: "object",
            required: ["post"],
            properties: {
              post: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#postView"
              },
              parent: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              },
              replies: {
                type: "array",
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            }
          },
          notFoundPost: {
            type: "object",
            required: ["uri", "notFound"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              notFound: {
                type: "boolean",
                const: true
              }
            }
          },
          blockedPost: {
            type: "object",
            required: ["uri", "blocked", "author"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              blocked: {
                type: "boolean",
                const: true
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#blockedAuthor"
              }
            }
          },
          blockedAuthor: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              }
            }
          },
          generatorView: {
            type: "object",
            required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              did: {
                type: "string",
                format: "did"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              displayName: {
                type: "string"
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "string"
              },
              likeCount: {
                type: "integer",
                minimum: 0
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#generatorViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          generatorViewerState: {
            type: "object",
            properties: {
              like: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          skeletonFeedPost: {
            type: "object",
            required: ["post"],
            properties: {
              post: {
                type: "string",
                format: "at-uri"
              },
              reason: {
                type: "union",
                refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
              }
            }
          },
          skeletonReasonRepost: {
            type: "object",
            required: ["repost"],
            properties: {
              repost: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          threadgateView: {
            type: "object",
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              record: {
                type: "unknown"
              },
              lists: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                }
              }
            }
          }
        }
      },
      AppBskyFeedDescribeFeedGenerator: {
        lexicon: 1,
        id: "app.bsky.feed.describeFeedGenerator",
        defs: {
          main: {
            type: "query",
            description: "Get information about a feed generator, including policies and offered feed URIs.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "feeds"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                    }
                  },
                  links: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                  }
                }
              }
            }
          },
          feed: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          links: {
            type: "object",
            properties: {
              privacyPolicy: {
                type: "string"
              },
              termsOfService: {
                type: "string"
              }
            }
          }
        }
      },
      AppBskyFeedGenerator: {
        lexicon: 1,
        id: "app.bsky.feed.generator",
        defs: {
          main: {
            type: "record",
            description: "A declaration of the existence of a feed generator.",
            key: "any",
            record: {
              type: "object",
              required: ["did", "displayName", "createdAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 24,
                  maxLength: 240
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "blob",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                labels: {
                  type: "union",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetActorFeeds: {
        lexicon: 1,
        id: "app.bsky.feed.getActorFeeds",
        defs: {
          main: {
            type: "query",
            description: "Get a list of feeds created by the actor.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetActorLikes: {
        lexicon: 1,
        id: "app.bsky.feed.getActorLikes",
        defs: {
          main: {
            type: "query",
            description: "Get a list of posts liked by an actor.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BlockedActor"
              },
              {
                name: "BlockedByActor"
              }
            ]
          }
        }
      },
      AppBskyFeedGetAuthorFeed: {
        lexicon: 1,
        id: "app.bsky.feed.getAuthorFeed",
        defs: {
          main: {
            type: "query",
            description: "Get a view of an actor's feed.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                filter: {
                  type: "string",
                  knownValues: [
                    "posts_with_replies",
                    "posts_no_replies",
                    "posts_with_media",
                    "posts_and_author_threads"
                  ],
                  default: "posts_with_replies"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BlockedActor"
              },
              {
                name: "BlockedByActor"
              }
            ]
          }
        }
      },
      AppBskyFeedGetFeed: {
        lexicon: 1,
        id: "app.bsky.feed.getFeed",
        defs: {
          main: {
            type: "query",
            description: "Get a hydrated feed from an actor's selected feed generator.",
            parameters: {
              type: "params",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  format: "at-uri"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownFeed"
              }
            ]
          }
        }
      },
      AppBskyFeedGetFeedGenerator: {
        lexicon: 1,
        id: "app.bsky.feed.getFeedGenerator",
        defs: {
          main: {
            type: "query",
            description: "Get information about a feed generator.",
            parameters: {
              type: "params",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["view", "isOnline", "isValid"],
                properties: {
                  view: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  },
                  isOnline: {
                    type: "boolean"
                  },
                  isValid: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetFeedGenerators: {
        lexicon: 1,
        id: "app.bsky.feed.getFeedGenerators",
        defs: {
          main: {
            type: "query",
            description: "Get information about a list of feed generators.",
            parameters: {
              type: "params",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetFeedSkeleton: {
        lexicon: 1,
        id: "app.bsky.feed.getFeedSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get a skeleton of a feed provided by a feed generator.",
            parameters: {
              type: "params",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  format: "at-uri"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownFeed"
              }
            ]
          }
        }
      },
      AppBskyFeedGetLikes: {
        lexicon: 1,
        id: "app.bsky.feed.getLikes",
        defs: {
          main: {
            type: "query",
            description: "Get the list of likes.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "likes"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  cursor: {
                    type: "string"
                  },
                  likes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.getLikes#like"
                    }
                  }
                }
              }
            }
          },
          like: {
            type: "object",
            required: ["indexedAt", "createdAt", "actor"],
            properties: {
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              actor: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              }
            }
          }
        }
      },
      AppBskyFeedGetListFeed: {
        lexicon: 1,
        id: "app.bsky.feed.getListFeed",
        defs: {
          main: {
            type: "query",
            description: "Get a view of a recent posts from actors in a list.",
            parameters: {
              type: "params",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownList"
              }
            ]
          }
        }
      },
      AppBskyFeedGetPostThread: {
        lexicon: 1,
        id: "app.bsky.feed.getPostThread",
        defs: {
          main: {
            type: "query",
            description: "Get posts in a thread.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                depth: {
                  type: "integer",
                  default: 6,
                  minimum: 0,
                  maximum: 1e3
                },
                parentHeight: {
                  type: "integer",
                  default: 80,
                  minimum: 0,
                  maximum: 1e3
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["thread"],
                properties: {
                  thread: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  }
                }
              }
            },
            errors: [
              {
                name: "NotFound"
              }
            ]
          }
        }
      },
      AppBskyFeedGetPosts: {
        lexicon: 1,
        id: "app.bsky.feed.getPosts",
        defs: {
          main: {
            type: "query",
            description: "Get a view of an actor's feed.",
            parameters: {
              type: "params",
              required: ["uris"],
              properties: {
                uris: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  maxLength: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["posts"],
                properties: {
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#postView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetRepostedBy: {
        lexicon: 1,
        id: "app.bsky.feed.getRepostedBy",
        defs: {
          main: {
            type: "query",
            description: "Get a list of reposts.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "repostedBy"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  cursor: {
                    type: "string"
                  },
                  repostedBy: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetSuggestedFeeds: {
        lexicon: 1,
        id: "app.bsky.feed.getSuggestedFeeds",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested feeds for the viewer.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetTimeline: {
        lexicon: 1,
        id: "app.bsky.feed.getTimeline",
        defs: {
          main: {
            type: "query",
            description: "Get a view of the actor's home timeline.",
            parameters: {
              type: "params",
              properties: {
                algorithm: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedLike: {
        lexicon: 1,
        id: "app.bsky.feed.like",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a like.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyFeedPost: {
        lexicon: 1,
        id: "app.bsky.feed.post",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a post.",
            key: "tid",
            record: {
              type: "object",
              required: ["text", "createdAt"],
              properties: {
                text: {
                  type: "string",
                  maxLength: 3e3,
                  maxGraphemes: 300
                },
                entities: {
                  type: "array",
                  description: "Deprecated: replaced by app.bsky.richtext.facet.",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#entity"
                  }
                },
                facets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#replyRef"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images",
                    "lex:app.bsky.embed.external",
                    "lex:app.bsky.embed.record",
                    "lex:app.bsky.embed.recordWithMedia"
                  ]
                },
                langs: {
                  type: "array",
                  maxLength: 3,
                  items: {
                    type: "string",
                    format: "language"
                  }
                },
                labels: {
                  type: "union",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                tags: {
                  type: "array",
                  maxLength: 8,
                  items: {
                    type: "string",
                    maxLength: 640,
                    maxGraphemes: 64
                  },
                  description: "Additional non-inline tags describing this post."
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          },
          replyRef: {
            type: "object",
            required: ["root", "parent"],
            properties: {
              root: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              parent: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              }
            }
          },
          entity: {
            type: "object",
            description: "Deprecated: use facets instead.",
            required: ["index", "type", "value"],
            properties: {
              index: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#textSlice"
              },
              type: {
                type: "string",
                description: "Expected values are 'mention' and 'link'."
              },
              value: {
                type: "string"
              }
            }
          },
          textSlice: {
            type: "object",
            description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
            required: ["start", "end"],
            properties: {
              start: {
                type: "integer",
                minimum: 0
              },
              end: {
                type: "integer",
                minimum: 0
              }
            }
          }
        }
      },
      AppBskyFeedRepost: {
        lexicon: 1,
        id: "app.bsky.feed.repost",
        defs: {
          main: {
            description: "A declaration of a repost.",
            type: "record",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyFeedSearchPosts: {
        lexicon: 1,
        id: "app.bsky.feed.searchPosts",
        defs: {
          main: {
            type: "query",
            description: "Find posts matching search criteria.",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["posts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#postView"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      },
      AppBskyFeedThreadgate: {
        lexicon: 1,
        id: "app.bsky.feed.threadgate",
        defs: {
          main: {
            type: "record",
            key: "tid",
            description: "Defines interaction gating rules for a thread. The rkey of the threadgate record should match the rkey of the thread's root post.",
            record: {
              type: "object",
              required: ["post", "createdAt"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri"
                },
                allow: {
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.threadgate#mentionRule",
                      "lex:app.bsky.feed.threadgate#followingRule",
                      "lex:app.bsky.feed.threadgate#listRule"
                    ]
                  }
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          },
          mentionRule: {
            type: "object",
            description: "Allow replies from actors mentioned in your post.",
            properties: {}
          },
          followingRule: {
            type: "object",
            description: "Allow replies from actors you follow.",
            properties: {}
          },
          listRule: {
            type: "object",
            description: "Allow replies from actors on a list.",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri"
              }
            }
          }
        }
      },
      AppBskyGraphBlock: {
        lexicon: 1,
        id: "app.bsky.graph.block",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a block.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphDefs: {
        lexicon: 1,
        id: "app.bsky.graph.defs",
        defs: {
          listViewBasic: {
            type: "object",
            required: ["uri", "cid", "name", "purpose"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1
              },
              purpose: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              avatar: {
                type: "string"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          listView: {
            type: "object",
            required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1
              },
              purpose: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "string"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          listItemView: {
            type: "object",
            required: ["uri", "subject"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              subject: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              }
            }
          },
          listPurpose: {
            type: "string",
            knownValues: [
              "app.bsky.graph.defs#modlist",
              "app.bsky.graph.defs#curatelist"
            ]
          },
          modlist: {
            type: "token",
            description: "A list of actors to apply an aggregate moderation action (mute/block) on."
          },
          curatelist: {
            type: "token",
            description: "A list of actors used for curation purposes such as list feeds or interaction gating."
          },
          listViewerState: {
            type: "object",
            properties: {
              muted: {
                type: "boolean"
              },
              blocked: {
                type: "string",
                format: "at-uri"
              }
            }
          }
        }
      },
      AppBskyGraphFollow: {
        lexicon: 1,
        id: "app.bsky.graph.follow",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a social follow.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetBlocks: {
        lexicon: 1,
        id: "app.bsky.graph.getBlocks",
        defs: {
          main: {
            type: "query",
            description: "Get a list of who the actor is blocking.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["blocks"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  blocks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetFollowers: {
        lexicon: 1,
        id: "app.bsky.graph.getFollowers",
        defs: {
          main: {
            type: "query",
            description: "Get a list of an actor's followers.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject", "followers"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  },
                  cursor: {
                    type: "string"
                  },
                  followers: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetFollows: {
        lexicon: 1,
        id: "app.bsky.graph.getFollows",
        defs: {
          main: {
            type: "query",
            description: "Get a list of who the actor follows.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject", "follows"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  },
                  cursor: {
                    type: "string"
                  },
                  follows: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetList: {
        lexicon: 1,
        id: "app.bsky.graph.getList",
        defs: {
          main: {
            type: "query",
            description: "Get a list of actors.",
            parameters: {
              type: "params",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["list", "items"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  list: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  },
                  items: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listItemView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetListBlocks: {
        lexicon: 1,
        id: "app.bsky.graph.getListBlocks",
        defs: {
          main: {
            type: "query",
            description: "Get lists that the actor is blocking.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["lists"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  lists: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetListMutes: {
        lexicon: 1,
        id: "app.bsky.graph.getListMutes",
        defs: {
          main: {
            type: "query",
            description: "Get lists that the actor is muting.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["lists"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  lists: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetLists: {
        lexicon: 1,
        id: "app.bsky.graph.getLists",
        defs: {
          main: {
            type: "query",
            description: "Get a list of lists that belong to an actor.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["lists"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  lists: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetMutes: {
        lexicon: 1,
        id: "app.bsky.graph.getMutes",
        defs: {
          main: {
            type: "query",
            description: "Get a list of who the actor mutes.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["mutes"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  mutes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetSuggestedFollowsByActor: {
        lexicon: 1,
        id: "app.bsky.graph.getSuggestedFollowsByActor",
        defs: {
          main: {
            type: "query",
            description: "Get suggested follows related to a given actor.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["suggestions"],
                properties: {
                  suggestions: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphList: {
        lexicon: 1,
        id: "app.bsky.graph.list",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a list of actors.",
            key: "tid",
            record: {
              type: "object",
              required: ["name", "purpose", "createdAt"],
              properties: {
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "blob",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                labels: {
                  type: "union",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphListblock: {
        lexicon: 1,
        id: "app.bsky.graph.listblock",
        defs: {
          main: {
            type: "record",
            description: "A block of an entire list of actors.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "at-uri"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphListitem: {
        lexicon: 1,
        id: "app.bsky.graph.listitem",
        defs: {
          main: {
            type: "record",
            description: "An item under a declared list of actors.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "list", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "did"
                },
                list: {
                  type: "string",
                  format: "at-uri"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphMuteActor: {
        lexicon: 1,
        id: "app.bsky.graph.muteActor",
        defs: {
          main: {
            type: "procedure",
            description: "Mute an actor by DID or handle.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphMuteActorList: {
        lexicon: 1,
        id: "app.bsky.graph.muteActorList",
        defs: {
          main: {
            type: "procedure",
            description: "Mute a list of actors.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphUnmuteActor: {
        lexicon: 1,
        id: "app.bsky.graph.unmuteActor",
        defs: {
          main: {
            type: "procedure",
            description: "Unmute an actor by DID or handle.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphUnmuteActorList: {
        lexicon: 1,
        id: "app.bsky.graph.unmuteActorList",
        defs: {
          main: {
            type: "procedure",
            description: "Unmute a list of actors.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationGetUnreadCount: {
        lexicon: 1,
        id: "app.bsky.notification.getUnreadCount",
        defs: {
          main: {
            type: "query",
            description: "Get the count of unread notifications.",
            parameters: {
              type: "params",
              properties: {
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["count"],
                properties: {
                  count: {
                    type: "integer"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationListNotifications: {
        lexicon: 1,
        id: "app.bsky.notification.listNotifications",
        defs: {
          main: {
            type: "query",
            description: "Get a list of notifications.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["notifications"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  notifications: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.notification.listNotifications#notification"
                    }
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          },
          notification: {
            type: "object",
            required: [
              "uri",
              "cid",
              "author",
              "reason",
              "record",
              "isRead",
              "indexedAt"
            ],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              reason: {
                type: "string",
                description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.",
                knownValues: [
                  "like",
                  "repost",
                  "follow",
                  "mention",
                  "reply",
                  "quote"
                ]
              },
              reasonSubject: {
                type: "string",
                format: "at-uri"
              },
              record: {
                type: "unknown"
              },
              isRead: {
                type: "boolean"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          }
        }
      },
      AppBskyNotificationRegisterPush: {
        lexicon: 1,
        id: "app.bsky.notification.registerPush",
        defs: {
          main: {
            type: "procedure",
            description: "Register for push notifications with a service.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["serviceDid", "token", "platform", "appId"],
                properties: {
                  serviceDid: {
                    type: "string",
                    format: "did"
                  },
                  token: {
                    type: "string"
                  },
                  platform: {
                    type: "string",
                    knownValues: ["ios", "android", "web"]
                  },
                  appId: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationUpdateSeen: {
        lexicon: 1,
        id: "app.bsky.notification.updateSeen",
        defs: {
          main: {
            type: "procedure",
            description: "Notify server that the user has seen notifications.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["seenAt"],
                properties: {
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyRichtextFacet: {
        lexicon: 1,
        id: "app.bsky.richtext.facet",
        defs: {
          main: {
            type: "object",
            required: ["index", "features"],
            properties: {
              index: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet#byteSlice"
              },
              features: {
                type: "array",
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.richtext.facet#mention",
                    "lex:app.bsky.richtext.facet#link",
                    "lex:app.bsky.richtext.facet#tag"
                  ]
                }
              }
            }
          },
          mention: {
            type: "object",
            description: "A facet feature for actor mentions.",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          link: {
            type: "object",
            description: "A facet feature for links.",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "uri"
              }
            }
          },
          tag: {
            type: "object",
            description: "A hashtag.",
            required: ["tag"],
            properties: {
              tag: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              }
            }
          },
          byteSlice: {
            type: "object",
            description: "A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.",
            required: ["byteStart", "byteEnd"],
            properties: {
              byteStart: {
                type: "integer",
                minimum: 0
              },
              byteEnd: {
                type: "integer",
                minimum: 0
              }
            }
          }
        }
      },
      AppBskyUnspeccedDefs: {
        lexicon: 1,
        id: "app.bsky.unspecced.defs",
        defs: {
          skeletonSearchPost: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          skeletonSearchActor: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetPopular: {
        lexicon: 1,
        id: "app.bsky.unspecced.getPopular",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED: will be removed soon. Use a feed generator alternative.",
            parameters: {
              type: "params",
              properties: {
                includeNsfw: {
                  type: "boolean",
                  default: false
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetPopularFeedGenerators: {
        lexicon: 1,
        id: "app.bsky.unspecced.getPopularFeedGenerators",
        defs: {
          main: {
            type: "query",
            description: "An unspecced view of globally popular feed generators.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                query: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetTimelineSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.getTimelineSkeleton",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED: a skeleton of a timeline. Unspecced and will be unavailable soon.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownFeed"
              }
            ]
          }
        }
      },
      AppBskyUnspeccedSearchActorsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.searchActorsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Backend Actors (profile) search, returns only skeleton.",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                },
                typeahead: {
                  type: "boolean",
                  description: "If true, acts as fast/simple 'typeahead' query."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      },
      AppBskyUnspeccedSearchPostsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.searchPostsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Backend Posts search, returns only skeleton",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["posts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      }
    };
    var schemas = Object.values(schemaDict);
    var lexicons = new Lexicons(schemas);
    var deleteAccount_exports = {};
    __export2(deleteAccount_exports, {
      toKnownErr: () => toKnownErr
    });
    function toKnownErr(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var disableAccountInvites_exports = {};
    __export2(disableAccountInvites_exports, {
      toKnownErr: () => toKnownErr2
    });
    function toKnownErr2(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var disableInviteCodes_exports = {};
    __export2(disableInviteCodes_exports, {
      toKnownErr: () => toKnownErr3
    });
    function toKnownErr3(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var emitModerationEvent_exports = {};
    __export2(emitModerationEvent_exports, {
      SubjectHasActionError: () => SubjectHasActionError,
      toKnownErr: () => toKnownErr4
    });
    var SubjectHasActionError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr4(e) {
      if (e instanceof XRPCError) {
        if (e.error === "SubjectHasAction")
          return new SubjectHasActionError(e);
      }
      return e;
    }
    var enableAccountInvites_exports = {};
    __export2(enableAccountInvites_exports, {
      toKnownErr: () => toKnownErr5
    });
    function toKnownErr5(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getAccountInfo_exports = {};
    __export2(getAccountInfo_exports, {
      toKnownErr: () => toKnownErr6
    });
    function toKnownErr6(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getInviteCodes_exports = {};
    __export2(getInviteCodes_exports, {
      toKnownErr: () => toKnownErr7
    });
    function toKnownErr7(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getModerationEvent_exports = {};
    __export2(getModerationEvent_exports, {
      toKnownErr: () => toKnownErr8
    });
    function toKnownErr8(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getRecord_exports = {};
    __export2(getRecord_exports, {
      RecordNotFoundError: () => RecordNotFoundError,
      toKnownErr: () => toKnownErr9
    });
    var RecordNotFoundError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr9(e) {
      if (e instanceof XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
      }
      return e;
    }
    var getRepo_exports = {};
    __export2(getRepo_exports, {
      RepoNotFoundError: () => RepoNotFoundError,
      toKnownErr: () => toKnownErr10
    });
    var RepoNotFoundError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr10(e) {
      if (e instanceof XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
      }
      return e;
    }
    var getSubjectStatus_exports = {};
    __export2(getSubjectStatus_exports, {
      toKnownErr: () => toKnownErr11
    });
    function toKnownErr11(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var queryModerationEvents_exports = {};
    __export2(queryModerationEvents_exports, {
      toKnownErr: () => toKnownErr12
    });
    function toKnownErr12(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var queryModerationStatuses_exports = {};
    __export2(queryModerationStatuses_exports, {
      toKnownErr: () => toKnownErr13
    });
    function toKnownErr13(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var searchRepos_exports = {};
    __export2(searchRepos_exports, {
      toKnownErr: () => toKnownErr14
    });
    function toKnownErr14(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var sendEmail_exports = {};
    __export2(sendEmail_exports, {
      toKnownErr: () => toKnownErr15
    });
    function toKnownErr15(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var updateAccountEmail_exports = {};
    __export2(updateAccountEmail_exports, {
      toKnownErr: () => toKnownErr16
    });
    function toKnownErr16(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var updateAccountHandle_exports = {};
    __export2(updateAccountHandle_exports, {
      toKnownErr: () => toKnownErr17
    });
    function toKnownErr17(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var updateSubjectStatus_exports = {};
    __export2(updateSubjectStatus_exports, {
      toKnownErr: () => toKnownErr18
    });
    function toKnownErr18(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var resolveHandle_exports = {};
    __export2(resolveHandle_exports, {
      toKnownErr: () => toKnownErr19
    });
    function toKnownErr19(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var updateHandle_exports = {};
    __export2(updateHandle_exports, {
      toKnownErr: () => toKnownErr20
    });
    function toKnownErr20(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var queryLabels_exports = {};
    __export2(queryLabels_exports, {
      toKnownErr: () => toKnownErr21
    });
    function toKnownErr21(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var createReport_exports = {};
    __export2(createReport_exports, {
      toKnownErr: () => toKnownErr22
    });
    function toKnownErr22(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var applyWrites_exports = {};
    __export2(applyWrites_exports, {
      InvalidSwapError: () => InvalidSwapError,
      isCreate: () => isCreate,
      isDelete: () => isDelete,
      isUpdate: () => isUpdate,
      toKnownErr: () => toKnownErr23,
      validateCreate: () => validateCreate,
      validateDelete: () => validateDelete,
      validateUpdate: () => validateUpdate
    });
    function isObj2(v) {
      return typeof v === "object" && v !== null;
    }
    function hasProp2(data, prop) {
      return prop in data;
    }
    var InvalidSwapError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr23(e) {
      if (e instanceof XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    function isCreate(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#create";
    }
    function validateCreate(v) {
      return lexicons.validate("com.atproto.repo.applyWrites#create", v);
    }
    function isUpdate(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#update";
    }
    function validateUpdate(v) {
      return lexicons.validate("com.atproto.repo.applyWrites#update", v);
    }
    function isDelete(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#delete";
    }
    function validateDelete(v) {
      return lexicons.validate("com.atproto.repo.applyWrites#delete", v);
    }
    var createRecord_exports = {};
    __export2(createRecord_exports, {
      InvalidSwapError: () => InvalidSwapError2,
      toKnownErr: () => toKnownErr24
    });
    var InvalidSwapError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr24(e) {
      if (e instanceof XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError2(e);
      }
      return e;
    }
    var deleteRecord_exports = {};
    __export2(deleteRecord_exports, {
      InvalidSwapError: () => InvalidSwapError3,
      toKnownErr: () => toKnownErr25
    });
    var InvalidSwapError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr25(e) {
      if (e instanceof XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError3(e);
      }
      return e;
    }
    var describeRepo_exports = {};
    __export2(describeRepo_exports, {
      toKnownErr: () => toKnownErr26
    });
    function toKnownErr26(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getRecord_exports2 = {};
    __export2(getRecord_exports2, {
      toKnownErr: () => toKnownErr27
    });
    function toKnownErr27(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var listRecords_exports = {};
    __export2(listRecords_exports, {
      isRecord: () => isRecord,
      toKnownErr: () => toKnownErr28,
      validateRecord: () => validateRecord
    });
    function toKnownErr28(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isRecord(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.listRecords#record";
    }
    function validateRecord(v) {
      return lexicons.validate("com.atproto.repo.listRecords#record", v);
    }
    var putRecord_exports = {};
    __export2(putRecord_exports, {
      InvalidSwapError: () => InvalidSwapError4,
      toKnownErr: () => toKnownErr29
    });
    var InvalidSwapError4 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr29(e) {
      if (e instanceof XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError4(e);
      }
      return e;
    }
    var uploadBlob_exports = {};
    __export2(uploadBlob_exports, {
      toKnownErr: () => toKnownErr30
    });
    function toKnownErr30(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var confirmEmail_exports = {};
    __export2(confirmEmail_exports, {
      AccountNotFoundError: () => AccountNotFoundError,
      ExpiredTokenError: () => ExpiredTokenError,
      InvalidEmailError: () => InvalidEmailError,
      InvalidTokenError: () => InvalidTokenError,
      toKnownErr: () => toKnownErr31
    });
    var AccountNotFoundError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var ExpiredTokenError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidTokenError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidEmailError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr31(e) {
      if (e instanceof XRPCError) {
        if (e.error === "AccountNotFound")
          return new AccountNotFoundError(e);
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
        if (e.error === "InvalidEmail")
          return new InvalidEmailError(e);
      }
      return e;
    }
    var createAccount_exports = {};
    __export2(createAccount_exports, {
      HandleNotAvailableError: () => HandleNotAvailableError,
      IncompatibleDidDocError: () => IncompatibleDidDocError,
      InvalidHandleError: () => InvalidHandleError2,
      InvalidInviteCodeError: () => InvalidInviteCodeError,
      InvalidPasswordError: () => InvalidPasswordError,
      UnresolvableDidError: () => UnresolvableDidError,
      UnsupportedDomainError: () => UnsupportedDomainError,
      toKnownErr: () => toKnownErr32
    });
    var InvalidHandleError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidPasswordError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidInviteCodeError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var HandleNotAvailableError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var UnsupportedDomainError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var UnresolvableDidError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var IncompatibleDidDocError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr32(e) {
      if (e instanceof XRPCError) {
        if (e.error === "InvalidHandle")
          return new InvalidHandleError2(e);
        if (e.error === "InvalidPassword")
          return new InvalidPasswordError(e);
        if (e.error === "InvalidInviteCode")
          return new InvalidInviteCodeError(e);
        if (e.error === "HandleNotAvailable")
          return new HandleNotAvailableError(e);
        if (e.error === "UnsupportedDomain")
          return new UnsupportedDomainError(e);
        if (e.error === "UnresolvableDid")
          return new UnresolvableDidError(e);
        if (e.error === "IncompatibleDidDoc")
          return new IncompatibleDidDocError(e);
      }
      return e;
    }
    var createAppPassword_exports = {};
    __export2(createAppPassword_exports, {
      AccountTakedownError: () => AccountTakedownError,
      isAppPassword: () => isAppPassword,
      toKnownErr: () => toKnownErr33,
      validateAppPassword: () => validateAppPassword
    });
    var AccountTakedownError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr33(e) {
      if (e instanceof XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    function isAppPassword(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createAppPassword#appPassword";
    }
    function validateAppPassword(v) {
      return lexicons.validate("com.atproto.server.createAppPassword#appPassword", v);
    }
    var createInviteCode_exports = {};
    __export2(createInviteCode_exports, {
      toKnownErr: () => toKnownErr34
    });
    function toKnownErr34(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var createInviteCodes_exports = {};
    __export2(createInviteCodes_exports, {
      isAccountCodes: () => isAccountCodes,
      toKnownErr: () => toKnownErr35,
      validateAccountCodes: () => validateAccountCodes
    });
    function toKnownErr35(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isAccountCodes(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createInviteCodes#accountCodes";
    }
    function validateAccountCodes(v) {
      return lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", v);
    }
    var createSession_exports = {};
    __export2(createSession_exports, {
      AccountTakedownError: () => AccountTakedownError2,
      toKnownErr: () => toKnownErr36
    });
    var AccountTakedownError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr36(e) {
      if (e instanceof XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError2(e);
      }
      return e;
    }
    var deleteAccount_exports2 = {};
    __export2(deleteAccount_exports2, {
      ExpiredTokenError: () => ExpiredTokenError2,
      InvalidTokenError: () => InvalidTokenError2,
      toKnownErr: () => toKnownErr37
    });
    var ExpiredTokenError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidTokenError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr37(e) {
      if (e instanceof XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError2(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError2(e);
      }
      return e;
    }
    var deleteSession_exports = {};
    __export2(deleteSession_exports, {
      toKnownErr: () => toKnownErr38
    });
    function toKnownErr38(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var describeServer_exports = {};
    __export2(describeServer_exports, {
      isLinks: () => isLinks,
      toKnownErr: () => toKnownErr39,
      validateLinks: () => validateLinks
    });
    function toKnownErr39(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isLinks(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.describeServer#links";
    }
    function validateLinks(v) {
      return lexicons.validate("com.atproto.server.describeServer#links", v);
    }
    var getAccountInviteCodes_exports = {};
    __export2(getAccountInviteCodes_exports, {
      DuplicateCreateError: () => DuplicateCreateError,
      toKnownErr: () => toKnownErr40
    });
    var DuplicateCreateError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr40(e) {
      if (e instanceof XRPCError) {
        if (e.error === "DuplicateCreate")
          return new DuplicateCreateError(e);
      }
      return e;
    }
    var getSession_exports = {};
    __export2(getSession_exports, {
      toKnownErr: () => toKnownErr41
    });
    function toKnownErr41(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var listAppPasswords_exports = {};
    __export2(listAppPasswords_exports, {
      AccountTakedownError: () => AccountTakedownError3,
      isAppPassword: () => isAppPassword2,
      toKnownErr: () => toKnownErr42,
      validateAppPassword: () => validateAppPassword2
    });
    var AccountTakedownError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr42(e) {
      if (e instanceof XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError3(e);
      }
      return e;
    }
    function isAppPassword2(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.listAppPasswords#appPassword";
    }
    function validateAppPassword2(v) {
      return lexicons.validate("com.atproto.server.listAppPasswords#appPassword", v);
    }
    var refreshSession_exports = {};
    __export2(refreshSession_exports, {
      AccountTakedownError: () => AccountTakedownError4,
      toKnownErr: () => toKnownErr43
    });
    var AccountTakedownError4 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr43(e) {
      if (e instanceof XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError4(e);
      }
      return e;
    }
    var requestAccountDelete_exports = {};
    __export2(requestAccountDelete_exports, {
      toKnownErr: () => toKnownErr44
    });
    function toKnownErr44(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var requestEmailConfirmation_exports = {};
    __export2(requestEmailConfirmation_exports, {
      toKnownErr: () => toKnownErr45
    });
    function toKnownErr45(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var requestEmailUpdate_exports = {};
    __export2(requestEmailUpdate_exports, {
      toKnownErr: () => toKnownErr46
    });
    function toKnownErr46(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var requestPasswordReset_exports = {};
    __export2(requestPasswordReset_exports, {
      toKnownErr: () => toKnownErr47
    });
    function toKnownErr47(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var reserveSigningKey_exports = {};
    __export2(reserveSigningKey_exports, {
      toKnownErr: () => toKnownErr48
    });
    function toKnownErr48(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var resetPassword_exports = {};
    __export2(resetPassword_exports, {
      ExpiredTokenError: () => ExpiredTokenError3,
      InvalidTokenError: () => InvalidTokenError3,
      toKnownErr: () => toKnownErr49
    });
    var ExpiredTokenError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidTokenError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr49(e) {
      if (e instanceof XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError3(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError3(e);
      }
      return e;
    }
    var revokeAppPassword_exports = {};
    __export2(revokeAppPassword_exports, {
      toKnownErr: () => toKnownErr50
    });
    function toKnownErr50(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var updateEmail_exports = {};
    __export2(updateEmail_exports, {
      ExpiredTokenError: () => ExpiredTokenError4,
      InvalidTokenError: () => InvalidTokenError4,
      TokenRequiredError: () => TokenRequiredError,
      toKnownErr: () => toKnownErr51
    });
    var ExpiredTokenError4 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidTokenError4 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var TokenRequiredError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr51(e) {
      if (e instanceof XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError4(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError4(e);
        if (e.error === "TokenRequired")
          return new TokenRequiredError(e);
      }
      return e;
    }
    var getBlob_exports = {};
    __export2(getBlob_exports, {
      toKnownErr: () => toKnownErr52
    });
    function toKnownErr52(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getBlocks_exports = {};
    __export2(getBlocks_exports, {
      toKnownErr: () => toKnownErr53
    });
    function toKnownErr53(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getCheckout_exports = {};
    __export2(getCheckout_exports, {
      toKnownErr: () => toKnownErr54
    });
    function toKnownErr54(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getHead_exports = {};
    __export2(getHead_exports, {
      HeadNotFoundError: () => HeadNotFoundError,
      toKnownErr: () => toKnownErr55
    });
    var HeadNotFoundError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr55(e) {
      if (e instanceof XRPCError) {
        if (e.error === "HeadNotFound")
          return new HeadNotFoundError(e);
      }
      return e;
    }
    var getLatestCommit_exports = {};
    __export2(getLatestCommit_exports, {
      RepoNotFoundError: () => RepoNotFoundError2,
      toKnownErr: () => toKnownErr56
    });
    var RepoNotFoundError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr56(e) {
      if (e instanceof XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError2(e);
      }
      return e;
    }
    var getRecord_exports3 = {};
    __export2(getRecord_exports3, {
      toKnownErr: () => toKnownErr57
    });
    function toKnownErr57(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getRepo_exports2 = {};
    __export2(getRepo_exports2, {
      toKnownErr: () => toKnownErr58
    });
    function toKnownErr58(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var listBlobs_exports = {};
    __export2(listBlobs_exports, {
      toKnownErr: () => toKnownErr59
    });
    function toKnownErr59(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var listRepos_exports = {};
    __export2(listRepos_exports, {
      isRepo: () => isRepo,
      toKnownErr: () => toKnownErr60,
      validateRepo: () => validateRepo
    });
    function toKnownErr60(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isRepo(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.listRepos#repo";
    }
    function validateRepo(v) {
      return lexicons.validate("com.atproto.sync.listRepos#repo", v);
    }
    var notifyOfUpdate_exports = {};
    __export2(notifyOfUpdate_exports, {
      toKnownErr: () => toKnownErr61
    });
    function toKnownErr61(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var requestCrawl_exports = {};
    __export2(requestCrawl_exports, {
      toKnownErr: () => toKnownErr62
    });
    function toKnownErr62(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var fetchLabels_exports = {};
    __export2(fetchLabels_exports, {
      toKnownErr: () => toKnownErr63
    });
    function toKnownErr63(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var importRepo_exports = {};
    __export2(importRepo_exports, {
      toKnownErr: () => toKnownErr64
    });
    function toKnownErr64(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var pushBlob_exports = {};
    __export2(pushBlob_exports, {
      toKnownErr: () => toKnownErr65
    });
    function toKnownErr65(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var transferAccount_exports = {};
    __export2(transferAccount_exports, {
      HandleNotAvailableError: () => HandleNotAvailableError2,
      IncompatibleDidDocError: () => IncompatibleDidDocError2,
      InvalidHandleError: () => InvalidHandleError3,
      InvalidInviteCodeError: () => InvalidInviteCodeError2,
      InvalidPasswordError: () => InvalidPasswordError2,
      UnresolvableDidError: () => UnresolvableDidError2,
      UnsupportedDomainError: () => UnsupportedDomainError2,
      toKnownErr: () => toKnownErr66
    });
    var InvalidHandleError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidPasswordError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var InvalidInviteCodeError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var HandleNotAvailableError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var UnsupportedDomainError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var UnresolvableDidError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var IncompatibleDidDocError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr66(e) {
      if (e instanceof XRPCError) {
        if (e.error === "InvalidHandle")
          return new InvalidHandleError3(e);
        if (e.error === "InvalidPassword")
          return new InvalidPasswordError2(e);
        if (e.error === "InvalidInviteCode")
          return new InvalidInviteCodeError2(e);
        if (e.error === "HandleNotAvailable")
          return new HandleNotAvailableError2(e);
        if (e.error === "UnsupportedDomain")
          return new UnsupportedDomainError2(e);
        if (e.error === "UnresolvableDid")
          return new UnresolvableDidError2(e);
        if (e.error === "IncompatibleDidDoc")
          return new IncompatibleDidDocError2(e);
      }
      return e;
    }
    var getPreferences_exports = {};
    __export2(getPreferences_exports, {
      toKnownErr: () => toKnownErr67
    });
    function toKnownErr67(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getProfile_exports = {};
    __export2(getProfile_exports, {
      toKnownErr: () => toKnownErr68
    });
    function toKnownErr68(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getProfiles_exports = {};
    __export2(getProfiles_exports, {
      toKnownErr: () => toKnownErr69
    });
    function toKnownErr69(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getSuggestions_exports = {};
    __export2(getSuggestions_exports, {
      toKnownErr: () => toKnownErr70
    });
    function toKnownErr70(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var putPreferences_exports = {};
    __export2(putPreferences_exports, {
      toKnownErr: () => toKnownErr71
    });
    function toKnownErr71(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var searchActors_exports = {};
    __export2(searchActors_exports, {
      toKnownErr: () => toKnownErr72
    });
    function toKnownErr72(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var searchActorsTypeahead_exports = {};
    __export2(searchActorsTypeahead_exports, {
      toKnownErr: () => toKnownErr73
    });
    function toKnownErr73(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var describeFeedGenerator_exports = {};
    __export2(describeFeedGenerator_exports, {
      isFeed: () => isFeed,
      isLinks: () => isLinks2,
      toKnownErr: () => toKnownErr74,
      validateFeed: () => validateFeed,
      validateLinks: () => validateLinks2
    });
    function toKnownErr74(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isFeed(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#feed";
    }
    function validateFeed(v) {
      return lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", v);
    }
    function isLinks2(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#links";
    }
    function validateLinks2(v) {
      return lexicons.validate("app.bsky.feed.describeFeedGenerator#links", v);
    }
    var getActorFeeds_exports = {};
    __export2(getActorFeeds_exports, {
      toKnownErr: () => toKnownErr75
    });
    function toKnownErr75(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getActorLikes_exports = {};
    __export2(getActorLikes_exports, {
      BlockedActorError: () => BlockedActorError,
      BlockedByActorError: () => BlockedByActorError,
      toKnownErr: () => toKnownErr76
    });
    var BlockedActorError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var BlockedByActorError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr76(e) {
      if (e instanceof XRPCError) {
        if (e.error === "BlockedActor")
          return new BlockedActorError(e);
        if (e.error === "BlockedByActor")
          return new BlockedByActorError(e);
      }
      return e;
    }
    var getAuthorFeed_exports = {};
    __export2(getAuthorFeed_exports, {
      BlockedActorError: () => BlockedActorError2,
      BlockedByActorError: () => BlockedByActorError2,
      toKnownErr: () => toKnownErr77
    });
    var BlockedActorError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    var BlockedByActorError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr77(e) {
      if (e instanceof XRPCError) {
        if (e.error === "BlockedActor")
          return new BlockedActorError2(e);
        if (e.error === "BlockedByActor")
          return new BlockedByActorError2(e);
      }
      return e;
    }
    var getFeed_exports = {};
    __export2(getFeed_exports, {
      UnknownFeedError: () => UnknownFeedError,
      toKnownErr: () => toKnownErr78
    });
    var UnknownFeedError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr78(e) {
      if (e instanceof XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError(e);
      }
      return e;
    }
    var getFeedGenerator_exports = {};
    __export2(getFeedGenerator_exports, {
      toKnownErr: () => toKnownErr79
    });
    function toKnownErr79(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getFeedGenerators_exports = {};
    __export2(getFeedGenerators_exports, {
      toKnownErr: () => toKnownErr80
    });
    function toKnownErr80(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getFeedSkeleton_exports = {};
    __export2(getFeedSkeleton_exports, {
      UnknownFeedError: () => UnknownFeedError2,
      toKnownErr: () => toKnownErr81
    });
    var UnknownFeedError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr81(e) {
      if (e instanceof XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError2(e);
      }
      return e;
    }
    var getLikes_exports = {};
    __export2(getLikes_exports, {
      isLike: () => isLike,
      toKnownErr: () => toKnownErr82,
      validateLike: () => validateLike
    });
    function toKnownErr82(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isLike(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.getLikes#like";
    }
    function validateLike(v) {
      return lexicons.validate("app.bsky.feed.getLikes#like", v);
    }
    var getListFeed_exports = {};
    __export2(getListFeed_exports, {
      UnknownListError: () => UnknownListError,
      toKnownErr: () => toKnownErr83
    });
    var UnknownListError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr83(e) {
      if (e instanceof XRPCError) {
        if (e.error === "UnknownList")
          return new UnknownListError(e);
      }
      return e;
    }
    var getPostThread_exports = {};
    __export2(getPostThread_exports, {
      NotFoundError: () => NotFoundError,
      toKnownErr: () => toKnownErr84
    });
    var NotFoundError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr84(e) {
      if (e instanceof XRPCError) {
        if (e.error === "NotFound")
          return new NotFoundError(e);
      }
      return e;
    }
    var getPosts_exports = {};
    __export2(getPosts_exports, {
      toKnownErr: () => toKnownErr85
    });
    function toKnownErr85(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getRepostedBy_exports = {};
    __export2(getRepostedBy_exports, {
      toKnownErr: () => toKnownErr86
    });
    function toKnownErr86(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getSuggestedFeeds_exports = {};
    __export2(getSuggestedFeeds_exports, {
      toKnownErr: () => toKnownErr87
    });
    function toKnownErr87(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getTimeline_exports = {};
    __export2(getTimeline_exports, {
      toKnownErr: () => toKnownErr88
    });
    function toKnownErr88(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var searchPosts_exports = {};
    __export2(searchPosts_exports, {
      BadQueryStringError: () => BadQueryStringError,
      toKnownErr: () => toKnownErr89
    });
    var BadQueryStringError = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr89(e) {
      if (e instanceof XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    var getBlocks_exports2 = {};
    __export2(getBlocks_exports2, {
      toKnownErr: () => toKnownErr90
    });
    function toKnownErr90(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getFollowers_exports = {};
    __export2(getFollowers_exports, {
      toKnownErr: () => toKnownErr91
    });
    function toKnownErr91(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getFollows_exports = {};
    __export2(getFollows_exports, {
      toKnownErr: () => toKnownErr92
    });
    function toKnownErr92(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getList_exports = {};
    __export2(getList_exports, {
      toKnownErr: () => toKnownErr93
    });
    function toKnownErr93(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getListBlocks_exports = {};
    __export2(getListBlocks_exports, {
      toKnownErr: () => toKnownErr94
    });
    function toKnownErr94(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getListMutes_exports = {};
    __export2(getListMutes_exports, {
      toKnownErr: () => toKnownErr95
    });
    function toKnownErr95(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getLists_exports = {};
    __export2(getLists_exports, {
      toKnownErr: () => toKnownErr96
    });
    function toKnownErr96(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getMutes_exports = {};
    __export2(getMutes_exports, {
      toKnownErr: () => toKnownErr97
    });
    function toKnownErr97(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getSuggestedFollowsByActor_exports = {};
    __export2(getSuggestedFollowsByActor_exports, {
      toKnownErr: () => toKnownErr98
    });
    function toKnownErr98(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var muteActor_exports = {};
    __export2(muteActor_exports, {
      toKnownErr: () => toKnownErr99
    });
    function toKnownErr99(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var muteActorList_exports = {};
    __export2(muteActorList_exports, {
      toKnownErr: () => toKnownErr100
    });
    function toKnownErr100(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var unmuteActor_exports = {};
    __export2(unmuteActor_exports, {
      toKnownErr: () => toKnownErr101
    });
    function toKnownErr101(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var unmuteActorList_exports = {};
    __export2(unmuteActorList_exports, {
      toKnownErr: () => toKnownErr102
    });
    function toKnownErr102(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getUnreadCount_exports = {};
    __export2(getUnreadCount_exports, {
      toKnownErr: () => toKnownErr103
    });
    function toKnownErr103(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var listNotifications_exports = {};
    __export2(listNotifications_exports, {
      isNotification: () => isNotification,
      toKnownErr: () => toKnownErr104,
      validateNotification: () => validateNotification
    });
    function toKnownErr104(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    function isNotification(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.notification.listNotifications#notification";
    }
    function validateNotification(v) {
      return lexicons.validate("app.bsky.notification.listNotifications#notification", v);
    }
    var registerPush_exports = {};
    __export2(registerPush_exports, {
      toKnownErr: () => toKnownErr105
    });
    function toKnownErr105(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var updateSeen_exports = {};
    __export2(updateSeen_exports, {
      toKnownErr: () => toKnownErr106
    });
    function toKnownErr106(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getPopular_exports = {};
    __export2(getPopular_exports, {
      toKnownErr: () => toKnownErr107
    });
    function toKnownErr107(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getPopularFeedGenerators_exports = {};
    __export2(getPopularFeedGenerators_exports, {
      toKnownErr: () => toKnownErr108
    });
    function toKnownErr108(e) {
      if (e instanceof XRPCError) {
      }
      return e;
    }
    var getTimelineSkeleton_exports = {};
    __export2(getTimelineSkeleton_exports, {
      UnknownFeedError: () => UnknownFeedError3,
      toKnownErr: () => toKnownErr109
    });
    var UnknownFeedError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr109(e) {
      if (e instanceof XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError3(e);
      }
      return e;
    }
    var searchActorsSkeleton_exports = {};
    __export2(searchActorsSkeleton_exports, {
      BadQueryStringError: () => BadQueryStringError2,
      toKnownErr: () => toKnownErr110
    });
    var BadQueryStringError2 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr110(e) {
      if (e instanceof XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError2(e);
      }
      return e;
    }
    var searchPostsSkeleton_exports = {};
    __export2(searchPostsSkeleton_exports, {
      BadQueryStringError: () => BadQueryStringError3,
      toKnownErr: () => toKnownErr111
    });
    var BadQueryStringError3 = class extends XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers);
      }
    };
    function toKnownErr111(e) {
      if (e instanceof XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError3(e);
      }
      return e;
    }
    var defs_exports = {};
    __export2(defs_exports, {
      REVIEWCLOSED: () => REVIEWCLOSED,
      REVIEWESCALATED: () => REVIEWESCALATED,
      REVIEWOPEN: () => REVIEWOPEN,
      isAccountView: () => isAccountView,
      isBlobView: () => isBlobView,
      isImageDetails: () => isImageDetails,
      isModEventAcknowledge: () => isModEventAcknowledge,
      isModEventComment: () => isModEventComment,
      isModEventEmail: () => isModEventEmail,
      isModEventEscalate: () => isModEventEscalate,
      isModEventLabel: () => isModEventLabel,
      isModEventMute: () => isModEventMute,
      isModEventReport: () => isModEventReport,
      isModEventReverseTakedown: () => isModEventReverseTakedown,
      isModEventTakedown: () => isModEventTakedown,
      isModEventUnmute: () => isModEventUnmute,
      isModEventView: () => isModEventView,
      isModEventViewDetail: () => isModEventViewDetail,
      isModeration: () => isModeration,
      isModerationDetail: () => isModerationDetail,
      isRecordView: () => isRecordView,
      isRecordViewDetail: () => isRecordViewDetail,
      isRecordViewNotFound: () => isRecordViewNotFound,
      isRepoBlobRef: () => isRepoBlobRef,
      isRepoRef: () => isRepoRef,
      isRepoView: () => isRepoView,
      isRepoViewDetail: () => isRepoViewDetail,
      isRepoViewNotFound: () => isRepoViewNotFound,
      isReportView: () => isReportView,
      isReportViewDetail: () => isReportViewDetail,
      isStatusAttr: () => isStatusAttr,
      isSubjectStatusView: () => isSubjectStatusView,
      isVideoDetails: () => isVideoDetails,
      validateAccountView: () => validateAccountView,
      validateBlobView: () => validateBlobView,
      validateImageDetails: () => validateImageDetails,
      validateModEventAcknowledge: () => validateModEventAcknowledge,
      validateModEventComment: () => validateModEventComment,
      validateModEventEmail: () => validateModEventEmail,
      validateModEventEscalate: () => validateModEventEscalate,
      validateModEventLabel: () => validateModEventLabel,
      validateModEventMute: () => validateModEventMute,
      validateModEventReport: () => validateModEventReport,
      validateModEventReverseTakedown: () => validateModEventReverseTakedown,
      validateModEventTakedown: () => validateModEventTakedown,
      validateModEventUnmute: () => validateModEventUnmute,
      validateModEventView: () => validateModEventView,
      validateModEventViewDetail: () => validateModEventViewDetail,
      validateModeration: () => validateModeration,
      validateModerationDetail: () => validateModerationDetail,
      validateRecordView: () => validateRecordView,
      validateRecordViewDetail: () => validateRecordViewDetail,
      validateRecordViewNotFound: () => validateRecordViewNotFound,
      validateRepoBlobRef: () => validateRepoBlobRef,
      validateRepoRef: () => validateRepoRef,
      validateRepoView: () => validateRepoView,
      validateRepoViewDetail: () => validateRepoViewDetail,
      validateRepoViewNotFound: () => validateRepoViewNotFound,
      validateReportView: () => validateReportView,
      validateReportViewDetail: () => validateReportViewDetail,
      validateStatusAttr: () => validateStatusAttr,
      validateSubjectStatusView: () => validateSubjectStatusView,
      validateVideoDetails: () => validateVideoDetails
    });
    function isStatusAttr(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#statusAttr";
    }
    function validateStatusAttr(v) {
      return lexicons.validate("com.atproto.admin.defs#statusAttr", v);
    }
    function isModEventView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventView";
    }
    function validateModEventView(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventView", v);
    }
    function isModEventViewDetail(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventViewDetail";
    }
    function validateModEventViewDetail(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventViewDetail", v);
    }
    function isReportView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportView";
    }
    function validateReportView(v) {
      return lexicons.validate("com.atproto.admin.defs#reportView", v);
    }
    function isSubjectStatusView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#subjectStatusView";
    }
    function validateSubjectStatusView(v) {
      return lexicons.validate("com.atproto.admin.defs#subjectStatusView", v);
    }
    function isReportViewDetail(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportViewDetail";
    }
    function validateReportViewDetail(v) {
      return lexicons.validate("com.atproto.admin.defs#reportViewDetail", v);
    }
    function isRepoView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoView";
    }
    function validateRepoView(v) {
      return lexicons.validate("com.atproto.admin.defs#repoView", v);
    }
    function isRepoViewDetail(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewDetail";
    }
    function validateRepoViewDetail(v) {
      return lexicons.validate("com.atproto.admin.defs#repoViewDetail", v);
    }
    function isAccountView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#accountView";
    }
    function validateAccountView(v) {
      return lexicons.validate("com.atproto.admin.defs#accountView", v);
    }
    function isRepoViewNotFound(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewNotFound";
    }
    function validateRepoViewNotFound(v) {
      return lexicons.validate("com.atproto.admin.defs#repoViewNotFound", v);
    }
    function isRepoRef(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoRef";
    }
    function validateRepoRef(v) {
      return lexicons.validate("com.atproto.admin.defs#repoRef", v);
    }
    function isRepoBlobRef(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoBlobRef";
    }
    function validateRepoBlobRef(v) {
      return lexicons.validate("com.atproto.admin.defs#repoBlobRef", v);
    }
    function isRecordView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordView";
    }
    function validateRecordView(v) {
      return lexicons.validate("com.atproto.admin.defs#recordView", v);
    }
    function isRecordViewDetail(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewDetail";
    }
    function validateRecordViewDetail(v) {
      return lexicons.validate("com.atproto.admin.defs#recordViewDetail", v);
    }
    function isRecordViewNotFound(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewNotFound";
    }
    function validateRecordViewNotFound(v) {
      return lexicons.validate("com.atproto.admin.defs#recordViewNotFound", v);
    }
    function isModeration(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderation";
    }
    function validateModeration(v) {
      return lexicons.validate("com.atproto.admin.defs#moderation", v);
    }
    function isModerationDetail(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderationDetail";
    }
    function validateModerationDetail(v) {
      return lexicons.validate("com.atproto.admin.defs#moderationDetail", v);
    }
    function isBlobView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#blobView";
    }
    function validateBlobView(v) {
      return lexicons.validate("com.atproto.admin.defs#blobView", v);
    }
    function isImageDetails(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#imageDetails";
    }
    function validateImageDetails(v) {
      return lexicons.validate("com.atproto.admin.defs#imageDetails", v);
    }
    function isVideoDetails(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#videoDetails";
    }
    function validateVideoDetails(v) {
      return lexicons.validate("com.atproto.admin.defs#videoDetails", v);
    }
    var REVIEWOPEN = "com.atproto.admin.defs#reviewOpen";
    var REVIEWESCALATED = "com.atproto.admin.defs#reviewEscalated";
    var REVIEWCLOSED = "com.atproto.admin.defs#reviewClosed";
    function isModEventTakedown(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventTakedown";
    }
    function validateModEventTakedown(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventTakedown", v);
    }
    function isModEventReverseTakedown(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReverseTakedown";
    }
    function validateModEventReverseTakedown(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventReverseTakedown", v);
    }
    function isModEventComment(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventComment";
    }
    function validateModEventComment(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventComment", v);
    }
    function isModEventReport(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReport";
    }
    function validateModEventReport(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventReport", v);
    }
    function isModEventLabel(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventLabel";
    }
    function validateModEventLabel(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventLabel", v);
    }
    function isModEventAcknowledge(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventAcknowledge";
    }
    function validateModEventAcknowledge(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventAcknowledge", v);
    }
    function isModEventEscalate(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEscalate";
    }
    function validateModEventEscalate(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventEscalate", v);
    }
    function isModEventMute(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventMute";
    }
    function validateModEventMute(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventMute", v);
    }
    function isModEventUnmute(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventUnmute";
    }
    function validateModEventUnmute(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventUnmute", v);
    }
    function isModEventEmail(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEmail";
    }
    function validateModEventEmail(v) {
      return lexicons.validate("com.atproto.admin.defs#modEventEmail", v);
    }
    var defs_exports2 = {};
    __export2(defs_exports2, {
      isLabel: () => isLabel,
      isSelfLabel: () => isSelfLabel,
      isSelfLabels: () => isSelfLabels,
      validateLabel: () => validateLabel,
      validateSelfLabel: () => validateSelfLabel,
      validateSelfLabels: () => validateSelfLabels
    });
    function isLabel(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#label";
    }
    function validateLabel(v) {
      return lexicons.validate("com.atproto.label.defs#label", v);
    }
    function isSelfLabels(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabels";
    }
    function validateSelfLabels(v) {
      return lexicons.validate("com.atproto.label.defs#selfLabels", v);
    }
    function isSelfLabel(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabel";
    }
    function validateSelfLabel(v) {
      return lexicons.validate("com.atproto.label.defs#selfLabel", v);
    }
    var subscribeLabels_exports = {};
    __export2(subscribeLabels_exports, {
      isInfo: () => isInfo,
      isLabels: () => isLabels,
      validateInfo: () => validateInfo,
      validateLabels: () => validateLabels
    });
    function isLabels(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#labels";
    }
    function validateLabels(v) {
      return lexicons.validate("com.atproto.label.subscribeLabels#labels", v);
    }
    function isInfo(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#info";
    }
    function validateInfo(v) {
      return lexicons.validate("com.atproto.label.subscribeLabels#info", v);
    }
    var defs_exports3 = {};
    __export2(defs_exports3, {
      REASONMISLEADING: () => REASONMISLEADING,
      REASONOTHER: () => REASONOTHER,
      REASONRUDE: () => REASONRUDE,
      REASONSEXUAL: () => REASONSEXUAL,
      REASONSPAM: () => REASONSPAM,
      REASONVIOLATION: () => REASONVIOLATION
    });
    var REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
    var REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
    var REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
    var REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
    var REASONRUDE = "com.atproto.moderation.defs#reasonRude";
    var REASONOTHER = "com.atproto.moderation.defs#reasonOther";
    var strongRef_exports = {};
    __export2(strongRef_exports, {
      isMain: () => isMain,
      validateMain: () => validateMain
    });
    function isMain(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "com.atproto.repo.strongRef#main" || v.$type === "com.atproto.repo.strongRef");
    }
    function validateMain(v) {
      return lexicons.validate("com.atproto.repo.strongRef#main", v);
    }
    var defs_exports4 = {};
    __export2(defs_exports4, {
      isInviteCode: () => isInviteCode,
      isInviteCodeUse: () => isInviteCodeUse,
      validateInviteCode: () => validateInviteCode,
      validateInviteCodeUse: () => validateInviteCodeUse
    });
    function isInviteCode(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCode";
    }
    function validateInviteCode(v) {
      return lexicons.validate("com.atproto.server.defs#inviteCode", v);
    }
    function isInviteCodeUse(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCodeUse";
    }
    function validateInviteCodeUse(v) {
      return lexicons.validate("com.atproto.server.defs#inviteCodeUse", v);
    }
    var subscribeRepos_exports = {};
    __export2(subscribeRepos_exports, {
      isCommit: () => isCommit,
      isHandle: () => isHandle,
      isInfo: () => isInfo2,
      isMigrate: () => isMigrate,
      isRepoOp: () => isRepoOp,
      isTombstone: () => isTombstone,
      validateCommit: () => validateCommit,
      validateHandle: () => validateHandle,
      validateInfo: () => validateInfo2,
      validateMigrate: () => validateMigrate,
      validateRepoOp: () => validateRepoOp,
      validateTombstone: () => validateTombstone
    });
    function isCommit(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#commit";
    }
    function validateCommit(v) {
      return lexicons.validate("com.atproto.sync.subscribeRepos#commit", v);
    }
    function isHandle(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#handle";
    }
    function validateHandle(v) {
      return lexicons.validate("com.atproto.sync.subscribeRepos#handle", v);
    }
    function isMigrate(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#migrate";
    }
    function validateMigrate(v) {
      return lexicons.validate("com.atproto.sync.subscribeRepos#migrate", v);
    }
    function isTombstone(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#tombstone";
    }
    function validateTombstone(v) {
      return lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", v);
    }
    function isInfo2(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#info";
    }
    function validateInfo2(v) {
      return lexicons.validate("com.atproto.sync.subscribeRepos#info", v);
    }
    function isRepoOp(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#repoOp";
    }
    function validateRepoOp(v) {
      return lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", v);
    }
    var defs_exports5 = {};
    __export2(defs_exports5, {
      isAdultContentPref: () => isAdultContentPref,
      isContentLabelPref: () => isContentLabelPref,
      isFeedViewPref: () => isFeedViewPref,
      isPersonalDetailsPref: () => isPersonalDetailsPref,
      isProfileView: () => isProfileView,
      isProfileViewBasic: () => isProfileViewBasic,
      isProfileViewDetailed: () => isProfileViewDetailed,
      isSavedFeedsPref: () => isSavedFeedsPref,
      isThreadViewPref: () => isThreadViewPref,
      isViewerState: () => isViewerState,
      validateAdultContentPref: () => validateAdultContentPref,
      validateContentLabelPref: () => validateContentLabelPref,
      validateFeedViewPref: () => validateFeedViewPref,
      validatePersonalDetailsPref: () => validatePersonalDetailsPref,
      validateProfileView: () => validateProfileView,
      validateProfileViewBasic: () => validateProfileViewBasic,
      validateProfileViewDetailed: () => validateProfileViewDetailed,
      validateSavedFeedsPref: () => validateSavedFeedsPref,
      validateThreadViewPref: () => validateThreadViewPref,
      validateViewerState: () => validateViewerState
    });
    function isProfileViewBasic(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewBasic";
    }
    function validateProfileViewBasic(v) {
      return lexicons.validate("app.bsky.actor.defs#profileViewBasic", v);
    }
    function isProfileView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileView";
    }
    function validateProfileView(v) {
      return lexicons.validate("app.bsky.actor.defs#profileView", v);
    }
    function isProfileViewDetailed(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewDetailed";
    }
    function validateProfileViewDetailed(v) {
      return lexicons.validate("app.bsky.actor.defs#profileViewDetailed", v);
    }
    function isViewerState(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#viewerState";
    }
    function validateViewerState(v) {
      return lexicons.validate("app.bsky.actor.defs#viewerState", v);
    }
    function isAdultContentPref(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#adultContentPref";
    }
    function validateAdultContentPref(v) {
      return lexicons.validate("app.bsky.actor.defs#adultContentPref", v);
    }
    function isContentLabelPref(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#contentLabelPref";
    }
    function validateContentLabelPref(v) {
      return lexicons.validate("app.bsky.actor.defs#contentLabelPref", v);
    }
    function isSavedFeedsPref(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#savedFeedsPref";
    }
    function validateSavedFeedsPref(v) {
      return lexicons.validate("app.bsky.actor.defs#savedFeedsPref", v);
    }
    function isPersonalDetailsPref(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#personalDetailsPref";
    }
    function validatePersonalDetailsPref(v) {
      return lexicons.validate("app.bsky.actor.defs#personalDetailsPref", v);
    }
    function isFeedViewPref(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#feedViewPref";
    }
    function validateFeedViewPref(v) {
      return lexicons.validate("app.bsky.actor.defs#feedViewPref", v);
    }
    function isThreadViewPref(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#threadViewPref";
    }
    function validateThreadViewPref(v) {
      return lexicons.validate("app.bsky.actor.defs#threadViewPref", v);
    }
    var profile_exports = {};
    __export2(profile_exports, {
      isRecord: () => isRecord2,
      validateRecord: () => validateRecord2
    });
    function isRecord2(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.actor.profile#main" || v.$type === "app.bsky.actor.profile");
    }
    function validateRecord2(v) {
      return lexicons.validate("app.bsky.actor.profile#main", v);
    }
    var external_exports = {};
    __export2(external_exports, {
      isExternal: () => isExternal,
      isMain: () => isMain2,
      isView: () => isView,
      isViewExternal: () => isViewExternal,
      validateExternal: () => validateExternal,
      validateMain: () => validateMain2,
      validateView: () => validateView,
      validateViewExternal: () => validateViewExternal
    });
    function isMain2(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.external#main" || v.$type === "app.bsky.embed.external");
    }
    function validateMain2(v) {
      return lexicons.validate("app.bsky.embed.external#main", v);
    }
    function isExternal(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#external";
    }
    function validateExternal(v) {
      return lexicons.validate("app.bsky.embed.external#external", v);
    }
    function isView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#view";
    }
    function validateView(v) {
      return lexicons.validate("app.bsky.embed.external#view", v);
    }
    function isViewExternal(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#viewExternal";
    }
    function validateViewExternal(v) {
      return lexicons.validate("app.bsky.embed.external#viewExternal", v);
    }
    var images_exports = {};
    __export2(images_exports, {
      isAspectRatio: () => isAspectRatio,
      isImage: () => isImage,
      isMain: () => isMain3,
      isView: () => isView2,
      isViewImage: () => isViewImage,
      validateAspectRatio: () => validateAspectRatio,
      validateImage: () => validateImage,
      validateMain: () => validateMain3,
      validateView: () => validateView2,
      validateViewImage: () => validateViewImage
    });
    function isMain3(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.images#main" || v.$type === "app.bsky.embed.images");
    }
    function validateMain3(v) {
      return lexicons.validate("app.bsky.embed.images#main", v);
    }
    function isImage(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#image";
    }
    function validateImage(v) {
      return lexicons.validate("app.bsky.embed.images#image", v);
    }
    function isAspectRatio(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#aspectRatio";
    }
    function validateAspectRatio(v) {
      return lexicons.validate("app.bsky.embed.images#aspectRatio", v);
    }
    function isView2(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#view";
    }
    function validateView2(v) {
      return lexicons.validate("app.bsky.embed.images#view", v);
    }
    function isViewImage(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#viewImage";
    }
    function validateViewImage(v) {
      return lexicons.validate("app.bsky.embed.images#viewImage", v);
    }
    var record_exports = {};
    __export2(record_exports, {
      isMain: () => isMain4,
      isView: () => isView3,
      isViewBlocked: () => isViewBlocked,
      isViewNotFound: () => isViewNotFound,
      isViewRecord: () => isViewRecord,
      validateMain: () => validateMain4,
      validateView: () => validateView3,
      validateViewBlocked: () => validateViewBlocked,
      validateViewNotFound: () => validateViewNotFound,
      validateViewRecord: () => validateViewRecord
    });
    function isMain4(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.record#main" || v.$type === "app.bsky.embed.record");
    }
    function validateMain4(v) {
      return lexicons.validate("app.bsky.embed.record#main", v);
    }
    function isView3(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#view";
    }
    function validateView3(v) {
      return lexicons.validate("app.bsky.embed.record#view", v);
    }
    function isViewRecord(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewRecord";
    }
    function validateViewRecord(v) {
      return lexicons.validate("app.bsky.embed.record#viewRecord", v);
    }
    function isViewNotFound(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewNotFound";
    }
    function validateViewNotFound(v) {
      return lexicons.validate("app.bsky.embed.record#viewNotFound", v);
    }
    function isViewBlocked(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewBlocked";
    }
    function validateViewBlocked(v) {
      return lexicons.validate("app.bsky.embed.record#viewBlocked", v);
    }
    var recordWithMedia_exports = {};
    __export2(recordWithMedia_exports, {
      isMain: () => isMain5,
      isView: () => isView4,
      validateMain: () => validateMain5,
      validateView: () => validateView4
    });
    function isMain5(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.recordWithMedia#main" || v.$type === "app.bsky.embed.recordWithMedia");
    }
    function validateMain5(v) {
      return lexicons.validate("app.bsky.embed.recordWithMedia#main", v);
    }
    function isView4(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.recordWithMedia#view";
    }
    function validateView4(v) {
      return lexicons.validate("app.bsky.embed.recordWithMedia#view", v);
    }
    var defs_exports6 = {};
    __export2(defs_exports6, {
      isBlockedAuthor: () => isBlockedAuthor,
      isBlockedPost: () => isBlockedPost,
      isFeedViewPost: () => isFeedViewPost,
      isGeneratorView: () => isGeneratorView,
      isGeneratorViewerState: () => isGeneratorViewerState,
      isNotFoundPost: () => isNotFoundPost,
      isPostView: () => isPostView,
      isReasonRepost: () => isReasonRepost,
      isReplyRef: () => isReplyRef,
      isSkeletonFeedPost: () => isSkeletonFeedPost,
      isSkeletonReasonRepost: () => isSkeletonReasonRepost,
      isThreadViewPost: () => isThreadViewPost,
      isThreadgateView: () => isThreadgateView,
      isViewerState: () => isViewerState2,
      validateBlockedAuthor: () => validateBlockedAuthor,
      validateBlockedPost: () => validateBlockedPost,
      validateFeedViewPost: () => validateFeedViewPost,
      validateGeneratorView: () => validateGeneratorView,
      validateGeneratorViewerState: () => validateGeneratorViewerState,
      validateNotFoundPost: () => validateNotFoundPost,
      validatePostView: () => validatePostView,
      validateReasonRepost: () => validateReasonRepost,
      validateReplyRef: () => validateReplyRef,
      validateSkeletonFeedPost: () => validateSkeletonFeedPost,
      validateSkeletonReasonRepost: () => validateSkeletonReasonRepost,
      validateThreadViewPost: () => validateThreadViewPost,
      validateThreadgateView: () => validateThreadgateView,
      validateViewerState: () => validateViewerState2
    });
    function isPostView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#postView";
    }
    function validatePostView(v) {
      return lexicons.validate("app.bsky.feed.defs#postView", v);
    }
    function isViewerState2(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#viewerState";
    }
    function validateViewerState2(v) {
      return lexicons.validate("app.bsky.feed.defs#viewerState", v);
    }
    function isFeedViewPost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#feedViewPost";
    }
    function validateFeedViewPost(v) {
      return lexicons.validate("app.bsky.feed.defs#feedViewPost", v);
    }
    function isReplyRef(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#replyRef";
    }
    function validateReplyRef(v) {
      return lexicons.validate("app.bsky.feed.defs#replyRef", v);
    }
    function isReasonRepost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#reasonRepost";
    }
    function validateReasonRepost(v) {
      return lexicons.validate("app.bsky.feed.defs#reasonRepost", v);
    }
    function isThreadViewPost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadViewPost";
    }
    function validateThreadViewPost(v) {
      return lexicons.validate("app.bsky.feed.defs#threadViewPost", v);
    }
    function isNotFoundPost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#notFoundPost";
    }
    function validateNotFoundPost(v) {
      return lexicons.validate("app.bsky.feed.defs#notFoundPost", v);
    }
    function isBlockedPost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedPost";
    }
    function validateBlockedPost(v) {
      return lexicons.validate("app.bsky.feed.defs#blockedPost", v);
    }
    function isBlockedAuthor(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedAuthor";
    }
    function validateBlockedAuthor(v) {
      return lexicons.validate("app.bsky.feed.defs#blockedAuthor", v);
    }
    function isGeneratorView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorView";
    }
    function validateGeneratorView(v) {
      return lexicons.validate("app.bsky.feed.defs#generatorView", v);
    }
    function isGeneratorViewerState(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorViewerState";
    }
    function validateGeneratorViewerState(v) {
      return lexicons.validate("app.bsky.feed.defs#generatorViewerState", v);
    }
    function isSkeletonFeedPost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonFeedPost";
    }
    function validateSkeletonFeedPost(v) {
      return lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", v);
    }
    function isSkeletonReasonRepost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonReasonRepost";
    }
    function validateSkeletonReasonRepost(v) {
      return lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", v);
    }
    function isThreadgateView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadgateView";
    }
    function validateThreadgateView(v) {
      return lexicons.validate("app.bsky.feed.defs#threadgateView", v);
    }
    var generator_exports = {};
    __export2(generator_exports, {
      isRecord: () => isRecord3,
      validateRecord: () => validateRecord3
    });
    function isRecord3(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.generator#main" || v.$type === "app.bsky.feed.generator");
    }
    function validateRecord3(v) {
      return lexicons.validate("app.bsky.feed.generator#main", v);
    }
    var like_exports = {};
    __export2(like_exports, {
      isRecord: () => isRecord4,
      validateRecord: () => validateRecord4
    });
    function isRecord4(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.like#main" || v.$type === "app.bsky.feed.like");
    }
    function validateRecord4(v) {
      return lexicons.validate("app.bsky.feed.like#main", v);
    }
    var post_exports = {};
    __export2(post_exports, {
      isEntity: () => isEntity,
      isRecord: () => isRecord5,
      isReplyRef: () => isReplyRef2,
      isTextSlice: () => isTextSlice,
      validateEntity: () => validateEntity,
      validateRecord: () => validateRecord5,
      validateReplyRef: () => validateReplyRef2,
      validateTextSlice: () => validateTextSlice
    });
    function isRecord5(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.post#main" || v.$type === "app.bsky.feed.post");
    }
    function validateRecord5(v) {
      return lexicons.validate("app.bsky.feed.post#main", v);
    }
    function isReplyRef2(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#replyRef";
    }
    function validateReplyRef2(v) {
      return lexicons.validate("app.bsky.feed.post#replyRef", v);
    }
    function isEntity(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#entity";
    }
    function validateEntity(v) {
      return lexicons.validate("app.bsky.feed.post#entity", v);
    }
    function isTextSlice(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#textSlice";
    }
    function validateTextSlice(v) {
      return lexicons.validate("app.bsky.feed.post#textSlice", v);
    }
    var repost_exports = {};
    __export2(repost_exports, {
      isRecord: () => isRecord6,
      validateRecord: () => validateRecord6
    });
    function isRecord6(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.repost#main" || v.$type === "app.bsky.feed.repost");
    }
    function validateRecord6(v) {
      return lexicons.validate("app.bsky.feed.repost#main", v);
    }
    var threadgate_exports = {};
    __export2(threadgate_exports, {
      isFollowingRule: () => isFollowingRule,
      isListRule: () => isListRule,
      isMentionRule: () => isMentionRule,
      isRecord: () => isRecord7,
      validateFollowingRule: () => validateFollowingRule,
      validateListRule: () => validateListRule,
      validateMentionRule: () => validateMentionRule,
      validateRecord: () => validateRecord7
    });
    function isRecord7(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.threadgate#main" || v.$type === "app.bsky.feed.threadgate");
    }
    function validateRecord7(v) {
      return lexicons.validate("app.bsky.feed.threadgate#main", v);
    }
    function isMentionRule(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#mentionRule";
    }
    function validateMentionRule(v) {
      return lexicons.validate("app.bsky.feed.threadgate#mentionRule", v);
    }
    function isFollowingRule(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#followingRule";
    }
    function validateFollowingRule(v) {
      return lexicons.validate("app.bsky.feed.threadgate#followingRule", v);
    }
    function isListRule(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#listRule";
    }
    function validateListRule(v) {
      return lexicons.validate("app.bsky.feed.threadgate#listRule", v);
    }
    var block_exports = {};
    __export2(block_exports, {
      isRecord: () => isRecord8,
      validateRecord: () => validateRecord8
    });
    function isRecord8(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.block#main" || v.$type === "app.bsky.graph.block");
    }
    function validateRecord8(v) {
      return lexicons.validate("app.bsky.graph.block#main", v);
    }
    var defs_exports7 = {};
    __export2(defs_exports7, {
      CURATELIST: () => CURATELIST,
      MODLIST: () => MODLIST,
      isListItemView: () => isListItemView,
      isListView: () => isListView,
      isListViewBasic: () => isListViewBasic,
      isListViewerState: () => isListViewerState,
      validateListItemView: () => validateListItemView,
      validateListView: () => validateListView,
      validateListViewBasic: () => validateListViewBasic,
      validateListViewerState: () => validateListViewerState
    });
    function isListViewBasic(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewBasic";
    }
    function validateListViewBasic(v) {
      return lexicons.validate("app.bsky.graph.defs#listViewBasic", v);
    }
    function isListView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listView";
    }
    function validateListView(v) {
      return lexicons.validate("app.bsky.graph.defs#listView", v);
    }
    function isListItemView(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listItemView";
    }
    function validateListItemView(v) {
      return lexicons.validate("app.bsky.graph.defs#listItemView", v);
    }
    var MODLIST = "app.bsky.graph.defs#modlist";
    var CURATELIST = "app.bsky.graph.defs#curatelist";
    function isListViewerState(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewerState";
    }
    function validateListViewerState(v) {
      return lexicons.validate("app.bsky.graph.defs#listViewerState", v);
    }
    var follow_exports = {};
    __export2(follow_exports, {
      isRecord: () => isRecord9,
      validateRecord: () => validateRecord9
    });
    function isRecord9(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.follow#main" || v.$type === "app.bsky.graph.follow");
    }
    function validateRecord9(v) {
      return lexicons.validate("app.bsky.graph.follow#main", v);
    }
    var list_exports = {};
    __export2(list_exports, {
      isRecord: () => isRecord10,
      validateRecord: () => validateRecord10
    });
    function isRecord10(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.list#main" || v.$type === "app.bsky.graph.list");
    }
    function validateRecord10(v) {
      return lexicons.validate("app.bsky.graph.list#main", v);
    }
    var listblock_exports = {};
    __export2(listblock_exports, {
      isRecord: () => isRecord11,
      validateRecord: () => validateRecord11
    });
    function isRecord11(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listblock#main" || v.$type === "app.bsky.graph.listblock");
    }
    function validateRecord11(v) {
      return lexicons.validate("app.bsky.graph.listblock#main", v);
    }
    var listitem_exports = {};
    __export2(listitem_exports, {
      isRecord: () => isRecord12,
      validateRecord: () => validateRecord12
    });
    function isRecord12(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listitem#main" || v.$type === "app.bsky.graph.listitem");
    }
    function validateRecord12(v) {
      return lexicons.validate("app.bsky.graph.listitem#main", v);
    }
    var facet_exports = {};
    __export2(facet_exports, {
      isByteSlice: () => isByteSlice,
      isLink: () => isLink,
      isMain: () => isMain6,
      isMention: () => isMention,
      isTag: () => isTag,
      validateByteSlice: () => validateByteSlice,
      validateLink: () => validateLink,
      validateMain: () => validateMain6,
      validateMention: () => validateMention,
      validateTag: () => validateTag
    });
    function isMain6(v) {
      return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.richtext.facet#main" || v.$type === "app.bsky.richtext.facet");
    }
    function validateMain6(v) {
      return lexicons.validate("app.bsky.richtext.facet#main", v);
    }
    function isMention(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#mention";
    }
    function validateMention(v) {
      return lexicons.validate("app.bsky.richtext.facet#mention", v);
    }
    function isLink(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#link";
    }
    function validateLink(v) {
      return lexicons.validate("app.bsky.richtext.facet#link", v);
    }
    function isTag(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#tag";
    }
    function validateTag(v) {
      return lexicons.validate("app.bsky.richtext.facet#tag", v);
    }
    function isByteSlice(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#byteSlice";
    }
    function validateByteSlice(v) {
      return lexicons.validate("app.bsky.richtext.facet#byteSlice", v);
    }
    var defs_exports8 = {};
    __export2(defs_exports8, {
      isSkeletonSearchActor: () => isSkeletonSearchActor,
      isSkeletonSearchPost: () => isSkeletonSearchPost,
      validateSkeletonSearchActor: () => validateSkeletonSearchActor,
      validateSkeletonSearchPost: () => validateSkeletonSearchPost
    });
    function isSkeletonSearchPost(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
    }
    function validateSkeletonSearchPost(v) {
      return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", v);
    }
    function isSkeletonSearchActor(v) {
      return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
    }
    function validateSkeletonSearchActor(v) {
      return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", v);
    }
    var COM_ATPROTO_ADMIN = {
      DefsReviewOpen: "com.atproto.admin.defs#reviewOpen",
      DefsReviewEscalated: "com.atproto.admin.defs#reviewEscalated",
      DefsReviewClosed: "com.atproto.admin.defs#reviewClosed"
    };
    var COM_ATPROTO_MODERATION = {
      DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
      DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
      DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
      DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
      DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
      DefsReasonOther: "com.atproto.moderation.defs#reasonOther"
    };
    var APP_BSKY_GRAPH = {
      DefsModlist: "app.bsky.graph.defs#modlist",
      DefsCuratelist: "app.bsky.graph.defs#curatelist"
    };
    var AtpBaseClient = class {
      constructor() {
        this.xrpc = new Client();
        this.xrpc.addLexicons(schemas);
      }
      service(serviceUri) {
        return new AtpServiceClient(this, this.xrpc.service(serviceUri));
      }
    };
    var AtpServiceClient = class {
      constructor(baseClient, xrpcService) {
        this._baseClient = baseClient;
        this.xrpc = xrpcService;
        this.com = new ComNS(this);
        this.app = new AppNS(this);
      }
      setHeader(key, value) {
        this.xrpc.setHeader(key, value);
      }
    };
    var ComNS = class {
      constructor(service2) {
        this._service = service2;
        this.atproto = new AtprotoNS(service2);
      }
    };
    var AtprotoNS = class {
      constructor(service2) {
        this._service = service2;
        this.admin = new AdminNS(service2);
        this.identity = new IdentityNS(service2);
        this.label = new LabelNS(service2);
        this.moderation = new ModerationNS(service2);
        this.repo = new RepoNS(service2);
        this.server = new ServerNS(service2);
        this.sync = new SyncNS(service2);
        this.temp = new TempNS(service2);
      }
    };
    var AdminNS = class {
      constructor(service2) {
        this._service = service2;
      }
      deleteAccount(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr(e);
        });
      }
      disableAccountInvites(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr2(e);
        });
      }
      disableInviteCodes(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr3(e);
        });
      }
      emitModerationEvent(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.emitModerationEvent", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr4(e);
        });
      }
      enableAccountInvites(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr5(e);
        });
      }
      getAccountInfo(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.getAccountInfo", params2, void 0, opts).catch((e) => {
          throw toKnownErr6(e);
        });
      }
      getInviteCodes(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.getInviteCodes", params2, void 0, opts).catch((e) => {
          throw toKnownErr7(e);
        });
      }
      getModerationEvent(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.getModerationEvent", params2, void 0, opts).catch((e) => {
          throw toKnownErr8(e);
        });
      }
      getRecord(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.getRecord", params2, void 0, opts).catch((e) => {
          throw toKnownErr9(e);
        });
      }
      getRepo(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.getRepo", params2, void 0, opts).catch((e) => {
          throw toKnownErr10(e);
        });
      }
      getSubjectStatus(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", params2, void 0, opts).catch((e) => {
          throw toKnownErr11(e);
        });
      }
      queryModerationEvents(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.queryModerationEvents", params2, void 0, opts).catch((e) => {
          throw toKnownErr12(e);
        });
      }
      queryModerationStatuses(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.queryModerationStatuses", params2, void 0, opts).catch((e) => {
          throw toKnownErr13(e);
        });
      }
      searchRepos(params2, opts) {
        return this._service.xrpc.call("com.atproto.admin.searchRepos", params2, void 0, opts).catch((e) => {
          throw toKnownErr14(e);
        });
      }
      sendEmail(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.sendEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr15(e);
        });
      }
      updateAccountEmail(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr16(e);
        });
      }
      updateAccountHandle(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr17(e);
        });
      }
      updateSubjectStatus(data, opts) {
        return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr18(e);
        });
      }
    };
    var IdentityNS = class {
      constructor(service2) {
        this._service = service2;
      }
      resolveHandle(params2, opts) {
        return this._service.xrpc.call("com.atproto.identity.resolveHandle", params2, void 0, opts).catch((e) => {
          throw toKnownErr19(e);
        });
      }
      updateHandle(data, opts) {
        return this._service.xrpc.call("com.atproto.identity.updateHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr20(e);
        });
      }
    };
    var LabelNS = class {
      constructor(service2) {
        this._service = service2;
      }
      queryLabels(params2, opts) {
        return this._service.xrpc.call("com.atproto.label.queryLabels", params2, void 0, opts).catch((e) => {
          throw toKnownErr21(e);
        });
      }
    };
    var ModerationNS = class {
      constructor(service2) {
        this._service = service2;
      }
      createReport(data, opts) {
        return this._service.xrpc.call("com.atproto.moderation.createReport", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr22(e);
        });
      }
    };
    var RepoNS = class {
      constructor(service2) {
        this._service = service2;
      }
      applyWrites(data, opts) {
        return this._service.xrpc.call("com.atproto.repo.applyWrites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr23(e);
        });
      }
      createRecord(data, opts) {
        return this._service.xrpc.call("com.atproto.repo.createRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr24(e);
        });
      }
      deleteRecord(data, opts) {
        return this._service.xrpc.call("com.atproto.repo.deleteRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr25(e);
        });
      }
      describeRepo(params2, opts) {
        return this._service.xrpc.call("com.atproto.repo.describeRepo", params2, void 0, opts).catch((e) => {
          throw toKnownErr26(e);
        });
      }
      getRecord(params2, opts) {
        return this._service.xrpc.call("com.atproto.repo.getRecord", params2, void 0, opts).catch((e) => {
          throw toKnownErr27(e);
        });
      }
      listRecords(params2, opts) {
        return this._service.xrpc.call("com.atproto.repo.listRecords", params2, void 0, opts).catch((e) => {
          throw toKnownErr28(e);
        });
      }
      putRecord(data, opts) {
        return this._service.xrpc.call("com.atproto.repo.putRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr29(e);
        });
      }
      uploadBlob(data, opts) {
        return this._service.xrpc.call("com.atproto.repo.uploadBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr30(e);
        });
      }
    };
    var ServerNS = class {
      constructor(service2) {
        this._service = service2;
      }
      confirmEmail(data, opts) {
        return this._service.xrpc.call("com.atproto.server.confirmEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr31(e);
        });
      }
      createAccount(data, opts) {
        return this._service.xrpc.call("com.atproto.server.createAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr32(e);
        });
      }
      createAppPassword(data, opts) {
        return this._service.xrpc.call("com.atproto.server.createAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr33(e);
        });
      }
      createInviteCode(data, opts) {
        return this._service.xrpc.call("com.atproto.server.createInviteCode", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr34(e);
        });
      }
      createInviteCodes(data, opts) {
        return this._service.xrpc.call("com.atproto.server.createInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr35(e);
        });
      }
      createSession(data, opts) {
        return this._service.xrpc.call("com.atproto.server.createSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr36(e);
        });
      }
      deleteAccount(data, opts) {
        return this._service.xrpc.call("com.atproto.server.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr37(e);
        });
      }
      deleteSession(data, opts) {
        return this._service.xrpc.call("com.atproto.server.deleteSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr38(e);
        });
      }
      describeServer(params2, opts) {
        return this._service.xrpc.call("com.atproto.server.describeServer", params2, void 0, opts).catch((e) => {
          throw toKnownErr39(e);
        });
      }
      getAccountInviteCodes(params2, opts) {
        return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", params2, void 0, opts).catch((e) => {
          throw toKnownErr40(e);
        });
      }
      getSession(params2, opts) {
        return this._service.xrpc.call("com.atproto.server.getSession", params2, void 0, opts).catch((e) => {
          throw toKnownErr41(e);
        });
      }
      listAppPasswords(params2, opts) {
        return this._service.xrpc.call("com.atproto.server.listAppPasswords", params2, void 0, opts).catch((e) => {
          throw toKnownErr42(e);
        });
      }
      refreshSession(data, opts) {
        return this._service.xrpc.call("com.atproto.server.refreshSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr43(e);
        });
      }
      requestAccountDelete(data, opts) {
        return this._service.xrpc.call("com.atproto.server.requestAccountDelete", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr44(e);
        });
      }
      requestEmailConfirmation(data, opts) {
        return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr45(e);
        });
      }
      requestEmailUpdate(data, opts) {
        return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr46(e);
        });
      }
      requestPasswordReset(data, opts) {
        return this._service.xrpc.call("com.atproto.server.requestPasswordReset", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr47(e);
        });
      }
      reserveSigningKey(data, opts) {
        return this._service.xrpc.call("com.atproto.server.reserveSigningKey", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr48(e);
        });
      }
      resetPassword(data, opts) {
        return this._service.xrpc.call("com.atproto.server.resetPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr49(e);
        });
      }
      revokeAppPassword(data, opts) {
        return this._service.xrpc.call("com.atproto.server.revokeAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr50(e);
        });
      }
      updateEmail(data, opts) {
        return this._service.xrpc.call("com.atproto.server.updateEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr51(e);
        });
      }
    };
    var SyncNS = class {
      constructor(service2) {
        this._service = service2;
      }
      getBlob(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getBlob", params2, void 0, opts).catch((e) => {
          throw toKnownErr52(e);
        });
      }
      getBlocks(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getBlocks", params2, void 0, opts).catch((e) => {
          throw toKnownErr53(e);
        });
      }
      getCheckout(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getCheckout", params2, void 0, opts).catch((e) => {
          throw toKnownErr54(e);
        });
      }
      getHead(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getHead", params2, void 0, opts).catch((e) => {
          throw toKnownErr55(e);
        });
      }
      getLatestCommit(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getLatestCommit", params2, void 0, opts).catch((e) => {
          throw toKnownErr56(e);
        });
      }
      getRecord(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getRecord", params2, void 0, opts).catch((e) => {
          throw toKnownErr57(e);
        });
      }
      getRepo(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.getRepo", params2, void 0, opts).catch((e) => {
          throw toKnownErr58(e);
        });
      }
      listBlobs(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.listBlobs", params2, void 0, opts).catch((e) => {
          throw toKnownErr59(e);
        });
      }
      listRepos(params2, opts) {
        return this._service.xrpc.call("com.atproto.sync.listRepos", params2, void 0, opts).catch((e) => {
          throw toKnownErr60(e);
        });
      }
      notifyOfUpdate(data, opts) {
        return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr61(e);
        });
      }
      requestCrawl(data, opts) {
        return this._service.xrpc.call("com.atproto.sync.requestCrawl", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr62(e);
        });
      }
    };
    var TempNS = class {
      constructor(service2) {
        this._service = service2;
      }
      fetchLabels(params2, opts) {
        return this._service.xrpc.call("com.atproto.temp.fetchLabels", params2, void 0, opts).catch((e) => {
          throw toKnownErr63(e);
        });
      }
      importRepo(data, opts) {
        return this._service.xrpc.call("com.atproto.temp.importRepo", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr64(e);
        });
      }
      pushBlob(data, opts) {
        return this._service.xrpc.call("com.atproto.temp.pushBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr65(e);
        });
      }
      transferAccount(data, opts) {
        return this._service.xrpc.call("com.atproto.temp.transferAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr66(e);
        });
      }
    };
    var AppNS = class {
      constructor(service2) {
        this._service = service2;
        this.bsky = new BskyNS(service2);
      }
    };
    var BskyNS = class {
      constructor(service2) {
        this._service = service2;
        this.actor = new ActorNS(service2);
        this.embed = new EmbedNS(service2);
        this.feed = new FeedNS(service2);
        this.graph = new GraphNS(service2);
        this.notification = new NotificationNS(service2);
        this.richtext = new RichtextNS(service2);
        this.unspecced = new UnspeccedNS(service2);
      }
    };
    var ActorNS = class {
      constructor(service2) {
        this._service = service2;
        this.profile = new ProfileRecord(service2);
      }
      getPreferences(params2, opts) {
        return this._service.xrpc.call("app.bsky.actor.getPreferences", params2, void 0, opts).catch((e) => {
          throw toKnownErr67(e);
        });
      }
      getProfile(params2, opts) {
        return this._service.xrpc.call("app.bsky.actor.getProfile", params2, void 0, opts).catch((e) => {
          throw toKnownErr68(e);
        });
      }
      getProfiles(params2, opts) {
        return this._service.xrpc.call("app.bsky.actor.getProfiles", params2, void 0, opts).catch((e) => {
          throw toKnownErr69(e);
        });
      }
      getSuggestions(params2, opts) {
        return this._service.xrpc.call("app.bsky.actor.getSuggestions", params2, void 0, opts).catch((e) => {
          throw toKnownErr70(e);
        });
      }
      putPreferences(data, opts) {
        return this._service.xrpc.call("app.bsky.actor.putPreferences", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr71(e);
        });
      }
      searchActors(params2, opts) {
        return this._service.xrpc.call("app.bsky.actor.searchActors", params2, void 0, opts).catch((e) => {
          throw toKnownErr72(e);
        });
      }
      searchActorsTypeahead(params2, opts) {
        return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", params2, void 0, opts).catch((e) => {
          throw toKnownErr73(e);
        });
      }
    };
    var ProfileRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.actor.profile",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.actor.profile",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.actor.profile";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.actor.profile", rkey: "self", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...params2 }, { headers });
      }
    };
    var EmbedNS = class {
      constructor(service2) {
        this._service = service2;
      }
    };
    var FeedNS = class {
      constructor(service2) {
        this._service = service2;
        this.generator = new GeneratorRecord(service2);
        this.like = new LikeRecord(service2);
        this.post = new PostRecord(service2);
        this.repost = new RepostRecord(service2);
        this.threadgate = new ThreadgateRecord(service2);
      }
      describeFeedGenerator(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", params2, void 0, opts).catch((e) => {
          throw toKnownErr74(e);
        });
      }
      getActorFeeds(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getActorFeeds", params2, void 0, opts).catch((e) => {
          throw toKnownErr75(e);
        });
      }
      getActorLikes(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getActorLikes", params2, void 0, opts).catch((e) => {
          throw toKnownErr76(e);
        });
      }
      getAuthorFeed(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", params2, void 0, opts).catch((e) => {
          throw toKnownErr77(e);
        });
      }
      getFeed(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getFeed", params2, void 0, opts).catch((e) => {
          throw toKnownErr78(e);
        });
      }
      getFeedGenerator(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", params2, void 0, opts).catch((e) => {
          throw toKnownErr79(e);
        });
      }
      getFeedGenerators(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", params2, void 0, opts).catch((e) => {
          throw toKnownErr80(e);
        });
      }
      getFeedSkeleton(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", params2, void 0, opts).catch((e) => {
          throw toKnownErr81(e);
        });
      }
      getLikes(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getLikes", params2, void 0, opts).catch((e) => {
          throw toKnownErr82(e);
        });
      }
      getListFeed(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getListFeed", params2, void 0, opts).catch((e) => {
          throw toKnownErr83(e);
        });
      }
      getPostThread(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getPostThread", params2, void 0, opts).catch((e) => {
          throw toKnownErr84(e);
        });
      }
      getPosts(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getPosts", params2, void 0, opts).catch((e) => {
          throw toKnownErr85(e);
        });
      }
      getRepostedBy(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getRepostedBy", params2, void 0, opts).catch((e) => {
          throw toKnownErr86(e);
        });
      }
      getSuggestedFeeds(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", params2, void 0, opts).catch((e) => {
          throw toKnownErr87(e);
        });
      }
      getTimeline(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.getTimeline", params2, void 0, opts).catch((e) => {
          throw toKnownErr88(e);
        });
      }
      searchPosts(params2, opts) {
        return this._service.xrpc.call("app.bsky.feed.searchPosts", params2, void 0, opts).catch((e) => {
          throw toKnownErr89(e);
        });
      }
    };
    var GeneratorRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.generator",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.generator",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.feed.generator";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.generator", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...params2 }, { headers });
      }
    };
    var LikeRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.like",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.like",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.feed.like";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.like", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...params2 }, { headers });
      }
    };
    var PostRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.post",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.post",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.feed.post";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.post", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...params2 }, { headers });
      }
    };
    var RepostRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.repost",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.repost",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.feed.repost";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.repost", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...params2 }, { headers });
      }
    };
    var ThreadgateRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.threadgate",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.threadgate",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.feed.threadgate";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.threadgate", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...params2 }, { headers });
      }
    };
    var GraphNS = class {
      constructor(service2) {
        this._service = service2;
        this.block = new BlockRecord(service2);
        this.follow = new FollowRecord(service2);
        this.list = new ListRecord(service2);
        this.listblock = new ListblockRecord(service2);
        this.listitem = new ListitemRecord(service2);
      }
      getBlocks(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getBlocks", params2, void 0, opts).catch((e) => {
          throw toKnownErr90(e);
        });
      }
      getFollowers(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getFollowers", params2, void 0, opts).catch((e) => {
          throw toKnownErr91(e);
        });
      }
      getFollows(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getFollows", params2, void 0, opts).catch((e) => {
          throw toKnownErr92(e);
        });
      }
      getList(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getList", params2, void 0, opts).catch((e) => {
          throw toKnownErr93(e);
        });
      }
      getListBlocks(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getListBlocks", params2, void 0, opts).catch((e) => {
          throw toKnownErr94(e);
        });
      }
      getListMutes(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getListMutes", params2, void 0, opts).catch((e) => {
          throw toKnownErr95(e);
        });
      }
      getLists(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getLists", params2, void 0, opts).catch((e) => {
          throw toKnownErr96(e);
        });
      }
      getMutes(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getMutes", params2, void 0, opts).catch((e) => {
          throw toKnownErr97(e);
        });
      }
      getSuggestedFollowsByActor(params2, opts) {
        return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", params2, void 0, opts).catch((e) => {
          throw toKnownErr98(e);
        });
      }
      muteActor(data, opts) {
        return this._service.xrpc.call("app.bsky.graph.muteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr99(e);
        });
      }
      muteActorList(data, opts) {
        return this._service.xrpc.call("app.bsky.graph.muteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr100(e);
        });
      }
      unmuteActor(data, opts) {
        return this._service.xrpc.call("app.bsky.graph.unmuteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr101(e);
        });
      }
      unmuteActorList(data, opts) {
        return this._service.xrpc.call("app.bsky.graph.unmuteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr102(e);
        });
      }
    };
    var BlockRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.block",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.block",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.graph.block";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.block", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...params2 }, { headers });
      }
    };
    var FollowRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.follow",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.follow",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.graph.follow";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.follow", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...params2 }, { headers });
      }
    };
    var ListRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.list",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.list",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.graph.list";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.list", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...params2 }, { headers });
      }
    };
    var ListblockRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.listblock",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.listblock",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.graph.listblock";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listblock", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...params2 }, { headers });
      }
    };
    var ListitemRecord = class {
      constructor(service2) {
        this._service = service2;
      }
      async list(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.listitem",
          ...params2
        });
        return res.data;
      }
      async get(params2) {
        const res = await this._service.xrpc.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.listitem",
          ...params2
        });
        return res.data;
      }
      async create(params2, record, headers) {
        record.$type = "app.bsky.graph.listitem";
        const res = await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listitem", ...params2, record }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params2, headers) {
        await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...params2 }, { headers });
      }
    };
    var NotificationNS = class {
      constructor(service2) {
        this._service = service2;
      }
      getUnreadCount(params2, opts) {
        return this._service.xrpc.call("app.bsky.notification.getUnreadCount", params2, void 0, opts).catch((e) => {
          throw toKnownErr103(e);
        });
      }
      listNotifications(params2, opts) {
        return this._service.xrpc.call("app.bsky.notification.listNotifications", params2, void 0, opts).catch((e) => {
          throw toKnownErr104(e);
        });
      }
      registerPush(data, opts) {
        return this._service.xrpc.call("app.bsky.notification.registerPush", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr105(e);
        });
      }
      updateSeen(data, opts) {
        return this._service.xrpc.call("app.bsky.notification.updateSeen", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
          throw toKnownErr106(e);
        });
      }
    };
    var RichtextNS = class {
      constructor(service2) {
        this._service = service2;
      }
    };
    var UnspeccedNS = class {
      constructor(service2) {
        this._service = service2;
      }
      getPopular(params2, opts) {
        return this._service.xrpc.call("app.bsky.unspecced.getPopular", params2, void 0, opts).catch((e) => {
          throw toKnownErr107(e);
        });
      }
      getPopularFeedGenerators(params2, opts) {
        return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", params2, void 0, opts).catch((e) => {
          throw toKnownErr108(e);
        });
      }
      getTimelineSkeleton(params2, opts) {
        return this._service.xrpc.call("app.bsky.unspecced.getTimelineSkeleton", params2, void 0, opts).catch((e) => {
          throw toKnownErr109(e);
        });
      }
      searchActorsSkeleton(params2, opts) {
        return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", params2, void 0, opts).catch((e) => {
          throw toKnownErr110(e);
        });
      }
      searchPostsSkeleton(params2, opts) {
        return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", params2, void 0, opts).catch((e) => {
          throw toKnownErr111(e);
        });
      }
    };
    var REFRESH_SESSION = "com.atproto.server.refreshSession";
    var _AtpAgent = class {
      constructor(opts) {
        this.uploadBlob = (data, opts2) => this.api.com.atproto.repo.uploadBlob(data, opts2);
        this.resolveHandle = (params2, opts2) => this.api.com.atproto.identity.resolveHandle(params2, opts2);
        this.updateHandle = (data, opts2) => this.api.com.atproto.identity.updateHandle(data, opts2);
        this.createModerationReport = (data, opts2) => this.api.com.atproto.moderation.createReport(data, opts2);
        this.service = opts.service instanceof URL ? opts.service : new URL(opts.service);
        this._persistSession = opts.persistSession;
        this._baseClient = new AtpBaseClient();
        this._baseClient.xrpc.fetch = this._fetch.bind(this);
        this.api = this._baseClient.service(opts.service);
      }
      get com() {
        return this.api.com;
      }
      static configure(opts) {
        _AtpAgent.fetch = opts.fetch;
      }
      get hasSession() {
        return !!this.session;
      }
      setPersistSessionHandler(handler) {
        this._persistSession = handler;
      }
      async createAccount(opts) {
        var _a, _b;
        try {
          const res = await this.api.com.atproto.server.createAccount({
            handle: opts.handle,
            password: opts.password,
            email: opts.email,
            inviteCode: opts.inviteCode
          });
          this.session = {
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did,
            email: opts.email,
            emailConfirmed: false
          };
          this._updateApiEndpoint(res.data.didDoc);
          return res;
        } catch (e) {
          this.session = void 0;
          throw e;
        } finally {
          if (this.session) {
            (_a = this._persistSession) == null ? void 0 : _a.call(this, "create", this.session);
          } else {
            (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
          }
        }
      }
      async login(opts) {
        var _a, _b;
        try {
          const res = await this.api.com.atproto.server.createSession({
            identifier: opts.identifier,
            password: opts.password
          });
          this.session = {
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did,
            email: res.data.email,
            emailConfirmed: res.data.emailConfirmed
          };
          this._updateApiEndpoint(res.data.didDoc);
          return res;
        } catch (e) {
          this.session = void 0;
          throw e;
        } finally {
          if (this.session) {
            (_a = this._persistSession) == null ? void 0 : _a.call(this, "create", this.session);
          } else {
            (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
          }
        }
      }
      async resumeSession(session) {
        var _a, _b;
        try {
          this.session = session;
          const res = await this.api.com.atproto.server.getSession();
          if (!res.success || res.data.did !== this.session.did) {
            throw new Error("Invalid session");
          }
          this.session.email = res.data.email;
          this.session.handle = res.data.handle;
          this.session.emailConfirmed = res.data.emailConfirmed;
          this._updateApiEndpoint(res.data.didDoc);
          return res;
        } catch (e) {
          this.session = void 0;
          throw e;
        } finally {
          if (this.session) {
            (_a = this._persistSession) == null ? void 0 : _a.call(this, "create", this.session);
          } else {
            (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
          }
        }
      }
      _addAuthHeader(reqHeaders) {
        var _a;
        if (!reqHeaders.authorization && ((_a = this.session) == null ? void 0 : _a.accessJwt)) {
          return {
            ...reqHeaders,
            authorization: `Bearer ${this.session.accessJwt}`
          };
        }
        return reqHeaders;
      }
      async _fetch(reqUri, reqMethod, reqHeaders, reqBody) {
        var _a;
        if (!_AtpAgent.fetch) {
          throw new Error("AtpAgent fetch() method not configured");
        }
        await this._refreshSessionPromise;
        let res = await _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
        if (isErrorResponse(res, ["ExpiredToken"]) && ((_a = this.session) == null ? void 0 : _a.refreshJwt)) {
          await this._refreshSession();
          res = await _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
        }
        return res;
      }
      async _refreshSession() {
        if (this._refreshSessionPromise) {
          return this._refreshSessionPromise;
        }
        this._refreshSessionPromise = this._refreshSessionInner();
        try {
          await this._refreshSessionPromise;
        } finally {
          this._refreshSessionPromise = void 0;
        }
      }
      async _refreshSessionInner() {
        var _a, _b, _c;
        if (!_AtpAgent.fetch) {
          throw new Error("AtpAgent fetch() method not configured");
        }
        if (!((_a = this.session) == null ? void 0 : _a.refreshJwt)) {
          return;
        }
        const url = new URL((this.pdsUrl || this.service).origin);
        url.pathname = `/xrpc/${REFRESH_SESSION}`;
        const res = await _AtpAgent.fetch(url.toString(), "POST", {
          authorization: `Bearer ${this.session.refreshJwt}`
        }, void 0);
        if (isErrorResponse(res, ["ExpiredToken", "InvalidToken"])) {
          this.session = void 0;
          (_b = this._persistSession) == null ? void 0 : _b.call(this, "expired", void 0);
        } else if (isNewSessionObject(this._baseClient, res.body)) {
          this.session = {
            ...this.session || {},
            accessJwt: res.body.accessJwt,
            refreshJwt: res.body.refreshJwt,
            handle: res.body.handle,
            did: res.body.did
          };
          this._updateApiEndpoint(res.body.didDoc);
          (_c = this._persistSession) == null ? void 0 : _c.call(this, "update", this.session);
        }
      }
      _updateApiEndpoint(didDoc) {
        if (isValidDidDoc(didDoc)) {
          const endpoint = getPdsEndpoint(didDoc);
          this.pdsUrl = endpoint ? new URL(endpoint) : void 0;
        }
        this.api.xrpc.uri = this.pdsUrl || this.service;
      }
    };
    var AtpAgent = _AtpAgent;
    AtpAgent.fetch = defaultFetchHandler;
    function isErrorObject(v) {
      return errorResponseBody.safeParse(v).success;
    }
    function isErrorResponse(res, errorNames) {
      if (res.status !== 400) {
        return false;
      }
      if (!isErrorObject(res.body)) {
        return false;
      }
      return typeof res.body.error === "string" && errorNames.includes(res.body.error);
    }
    function isNewSessionObject(client, v) {
      try {
        client.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", v);
        return true;
      } catch {
        return false;
      }
    }
    var encoder = new TextEncoder();
    var decoder = new TextDecoder();
    var UnicodeString = class {
      constructor(utf16) {
        this.utf16 = utf16;
        this.utf8 = encoder.encode(utf16);
      }
      get length() {
        return this.utf8.byteLength;
      }
      get graphemeLength() {
        if (!this._graphemeLen) {
          this._graphemeLen = graphemeLen(this.utf16);
        }
        return this._graphemeLen;
      }
      slice(start, end) {
        return decoder.decode(this.utf8.slice(start, end));
      }
      utf16IndexToUtf8Index(i) {
        return encoder.encode(this.utf16.slice(0, i)).byteLength;
      }
      toString() {
        return this.utf16;
      }
    };
    var EXCESS_SPACE_RE = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/;
    var REPLACEMENT_STR = "\n\n";
    function sanitizeRichText(richText, opts) {
      if (opts.cleanNewlines) {
        richText = clean(richText, EXCESS_SPACE_RE, REPLACEMENT_STR);
      }
      return richText;
    }
    function clean(richText, targetRegexp, replacementString) {
      richText = richText.clone();
      let match = richText.unicodeText.utf16.match(targetRegexp);
      while (match && typeof match.index !== "undefined") {
        const oldText = richText.unicodeText;
        const removeStartIndex = richText.unicodeText.utf16IndexToUtf8Index(match.index);
        const removeEndIndex = removeStartIndex + new UnicodeString(match[0]).length;
        richText.delete(removeStartIndex, removeEndIndex);
        if (richText.unicodeText.utf16 === oldText.utf16) {
          break;
        }
        richText.insert(removeStartIndex, replacementString);
        match = richText.unicodeText.utf16.match(targetRegexp);
      }
      return richText;
    }
    var tlds_default = [
      "aaa",
      "aarp",
      "abarth",
      "abb",
      "abbott",
      "abbvie",
      "abc",
      "able",
      "abogado",
      "abudhabi",
      "ac",
      "academy",
      "accenture",
      "accountant",
      "accountants",
      "aco",
      "actor",
      "ad",
      "ads",
      "adult",
      "ae",
      "aeg",
      "aero",
      "aetna",
      "af",
      "afl",
      "africa",
      "ag",
      "agakhan",
      "agency",
      "ai",
      "aig",
      "airbus",
      "airforce",
      "airtel",
      "akdn",
      "al",
      "alfaromeo",
      "alibaba",
      "alipay",
      "allfinanz",
      "allstate",
      "ally",
      "alsace",
      "alstom",
      "am",
      "amazon",
      "americanexpress",
      "americanfamily",
      "amex",
      "amfam",
      "amica",
      "amsterdam",
      "analytics",
      "android",
      "anquan",
      "anz",
      "ao",
      "aol",
      "apartments",
      "app",
      "apple",
      "aq",
      "aquarelle",
      "ar",
      "arab",
      "aramco",
      "archi",
      "army",
      "arpa",
      "art",
      "arte",
      "as",
      "asda",
      "asia",
      "associates",
      "at",
      "athleta",
      "attorney",
      "au",
      "auction",
      "audi",
      "audible",
      "audio",
      "auspost",
      "author",
      "auto",
      "autos",
      "avianca",
      "aw",
      "aws",
      "ax",
      "axa",
      "az",
      "azure",
      "ba",
      "baby",
      "baidu",
      "banamex",
      "bananarepublic",
      "band",
      "bank",
      "bar",
      "barcelona",
      "barclaycard",
      "barclays",
      "barefoot",
      "bargains",
      "baseball",
      "basketball",
      "bauhaus",
      "bayern",
      "bb",
      "bbc",
      "bbt",
      "bbva",
      "bcg",
      "bcn",
      "bd",
      "be",
      "beats",
      "beauty",
      "beer",
      "bentley",
      "berlin",
      "best",
      "bestbuy",
      "bet",
      "bf",
      "bg",
      "bh",
      "bharti",
      "bi",
      "bible",
      "bid",
      "bike",
      "bing",
      "bingo",
      "bio",
      "biz",
      "bj",
      "black",
      "blackfriday",
      "blockbuster",
      "blog",
      "bloomberg",
      "blue",
      "bm",
      "bms",
      "bmw",
      "bn",
      "bnpparibas",
      "bo",
      "boats",
      "boehringer",
      "bofa",
      "bom",
      "bond",
      "boo",
      "book",
      "booking",
      "bosch",
      "bostik",
      "boston",
      "bot",
      "boutique",
      "box",
      "br",
      "bradesco",
      "bridgestone",
      "broadway",
      "broker",
      "brother",
      "brussels",
      "bs",
      "bt",
      "build",
      "builders",
      "business",
      "buy",
      "buzz",
      "bv",
      "bw",
      "by",
      "bz",
      "bzh",
      "ca",
      "cab",
      "cafe",
      "cal",
      "call",
      "calvinklein",
      "cam",
      "camera",
      "camp",
      "canon",
      "capetown",
      "capital",
      "capitalone",
      "car",
      "caravan",
      "cards",
      "care",
      "career",
      "careers",
      "cars",
      "casa",
      "case",
      "cash",
      "casino",
      "cat",
      "catering",
      "catholic",
      "cba",
      "cbn",
      "cbre",
      "cbs",
      "cc",
      "cd",
      "center",
      "ceo",
      "cern",
      "cf",
      "cfa",
      "cfd",
      "cg",
      "ch",
      "chanel",
      "channel",
      "charity",
      "chase",
      "chat",
      "cheap",
      "chintai",
      "christmas",
      "chrome",
      "church",
      "ci",
      "cipriani",
      "circle",
      "cisco",
      "citadel",
      "citi",
      "citic",
      "city",
      "cityeats",
      "ck",
      "cl",
      "claims",
      "cleaning",
      "click",
      "clinic",
      "clinique",
      "clothing",
      "cloud",
      "club",
      "clubmed",
      "cm",
      "cn",
      "co",
      "coach",
      "codes",
      "coffee",
      "college",
      "cologne",
      "com",
      "comcast",
      "commbank",
      "community",
      "company",
      "compare",
      "computer",
      "comsec",
      "condos",
      "construction",
      "consulting",
      "contact",
      "contractors",
      "cooking",
      "cookingchannel",
      "cool",
      "coop",
      "corsica",
      "country",
      "coupon",
      "coupons",
      "courses",
      "cpa",
      "cr",
      "credit",
      "creditcard",
      "creditunion",
      "cricket",
      "crown",
      "crs",
      "cruise",
      "cruises",
      "cu",
      "cuisinella",
      "cv",
      "cw",
      "cx",
      "cy",
      "cymru",
      "cyou",
      "cz",
      "dabur",
      "dad",
      "dance",
      "data",
      "date",
      "dating",
      "datsun",
      "day",
      "dclk",
      "dds",
      "de",
      "deal",
      "dealer",
      "deals",
      "degree",
      "delivery",
      "dell",
      "deloitte",
      "delta",
      "democrat",
      "dental",
      "dentist",
      "desi",
      "design",
      "dev",
      "dhl",
      "diamonds",
      "diet",
      "digital",
      "direct",
      "directory",
      "discount",
      "discover",
      "dish",
      "diy",
      "dj",
      "dk",
      "dm",
      "dnp",
      "do",
      "docs",
      "doctor",
      "dog",
      "domains",
      "dot",
      "download",
      "drive",
      "dtv",
      "dubai",
      "dunlop",
      "dupont",
      "durban",
      "dvag",
      "dvr",
      "dz",
      "earth",
      "eat",
      "ec",
      "eco",
      "edeka",
      "edu",
      "education",
      "ee",
      "eg",
      "email",
      "emerck",
      "energy",
      "engineer",
      "engineering",
      "enterprises",
      "epson",
      "equipment",
      "er",
      "ericsson",
      "erni",
      "es",
      "esq",
      "estate",
      "et",
      "etisalat",
      "eu",
      "eurovision",
      "eus",
      "events",
      "exchange",
      "expert",
      "exposed",
      "express",
      "extraspace",
      "fage",
      "fail",
      "fairwinds",
      "faith",
      "family",
      "fan",
      "fans",
      "farm",
      "farmers",
      "fashion",
      "fast",
      "fedex",
      "feedback",
      "ferrari",
      "ferrero",
      "fi",
      "fiat",
      "fidelity",
      "fido",
      "film",
      "final",
      "finance",
      "financial",
      "fire",
      "firestone",
      "firmdale",
      "fish",
      "fishing",
      "fit",
      "fitness",
      "fj",
      "fk",
      "flickr",
      "flights",
      "flir",
      "florist",
      "flowers",
      "fly",
      "fm",
      "fo",
      "foo",
      "food",
      "foodnetwork",
      "football",
      "ford",
      "forex",
      "forsale",
      "forum",
      "foundation",
      "fox",
      "fr",
      "free",
      "fresenius",
      "frl",
      "frogans",
      "frontdoor",
      "frontier",
      "ftr",
      "fujitsu",
      "fun",
      "fund",
      "furniture",
      "futbol",
      "fyi",
      "ga",
      "gal",
      "gallery",
      "gallo",
      "gallup",
      "game",
      "games",
      "gap",
      "garden",
      "gay",
      "gb",
      "gbiz",
      "gd",
      "gdn",
      "ge",
      "gea",
      "gent",
      "genting",
      "george",
      "gf",
      "gg",
      "ggee",
      "gh",
      "gi",
      "gift",
      "gifts",
      "gives",
      "giving",
      "gl",
      "glass",
      "gle",
      "global",
      "globo",
      "gm",
      "gmail",
      "gmbh",
      "gmo",
      "gmx",
      "gn",
      "godaddy",
      "gold",
      "goldpoint",
      "golf",
      "goo",
      "goodyear",
      "goog",
      "google",
      "gop",
      "got",
      "gov",
      "gp",
      "gq",
      "gr",
      "grainger",
      "graphics",
      "gratis",
      "green",
      "gripe",
      "grocery",
      "group",
      "gs",
      "gt",
      "gu",
      "guardian",
      "gucci",
      "guge",
      "guide",
      "guitars",
      "guru",
      "gw",
      "gy",
      "hair",
      "hamburg",
      "hangout",
      "haus",
      "hbo",
      "hdfc",
      "hdfcbank",
      "health",
      "healthcare",
      "help",
      "helsinki",
      "here",
      "hermes",
      "hgtv",
      "hiphop",
      "hisamitsu",
      "hitachi",
      "hiv",
      "hk",
      "hkt",
      "hm",
      "hn",
      "hockey",
      "holdings",
      "holiday",
      "homedepot",
      "homegoods",
      "homes",
      "homesense",
      "honda",
      "horse",
      "hospital",
      "host",
      "hosting",
      "hot",
      "hoteles",
      "hotels",
      "hotmail",
      "house",
      "how",
      "hr",
      "hsbc",
      "ht",
      "hu",
      "hughes",
      "hyatt",
      "hyundai",
      "ibm",
      "icbc",
      "ice",
      "icu",
      "id",
      "ie",
      "ieee",
      "ifm",
      "ikano",
      "il",
      "im",
      "imamat",
      "imdb",
      "immo",
      "immobilien",
      "in",
      "inc",
      "industries",
      "infiniti",
      "info",
      "ing",
      "ink",
      "institute",
      "insurance",
      "insure",
      "int",
      "international",
      "intuit",
      "investments",
      "io",
      "ipiranga",
      "iq",
      "ir",
      "irish",
      "is",
      "ismaili",
      "ist",
      "istanbul",
      "it",
      "itau",
      "itv",
      "jaguar",
      "java",
      "jcb",
      "je",
      "jeep",
      "jetzt",
      "jewelry",
      "jio",
      "jll",
      "jm",
      "jmp",
      "jnj",
      "jo",
      "jobs",
      "joburg",
      "jot",
      "joy",
      "jp",
      "jpmorgan",
      "jprs",
      "juegos",
      "juniper",
      "kaufen",
      "kddi",
      "ke",
      "kerryhotels",
      "kerrylogistics",
      "kerryproperties",
      "kfh",
      "kg",
      "kh",
      "ki",
      "kia",
      "kids",
      "kim",
      "kinder",
      "kindle",
      "kitchen",
      "kiwi",
      "km",
      "kn",
      "koeln",
      "komatsu",
      "kosher",
      "kp",
      "kpmg",
      "kpn",
      "kr",
      "krd",
      "kred",
      "kuokgroup",
      "kw",
      "ky",
      "kyoto",
      "kz",
      "la",
      "lacaixa",
      "lamborghini",
      "lamer",
      "lancaster",
      "lancia",
      "land",
      "landrover",
      "lanxess",
      "lasalle",
      "lat",
      "latino",
      "latrobe",
      "law",
      "lawyer",
      "lb",
      "lc",
      "lds",
      "lease",
      "leclerc",
      "lefrak",
      "legal",
      "lego",
      "lexus",
      "lgbt",
      "li",
      "lidl",
      "life",
      "lifeinsurance",
      "lifestyle",
      "lighting",
      "like",
      "lilly",
      "limited",
      "limo",
      "lincoln",
      "linde",
      "link",
      "lipsy",
      "live",
      "living",
      "lk",
      "llc",
      "llp",
      "loan",
      "loans",
      "locker",
      "locus",
      "loft",
      "lol",
      "london",
      "lotte",
      "lotto",
      "love",
      "lpl",
      "lplfinancial",
      "lr",
      "ls",
      "lt",
      "ltd",
      "ltda",
      "lu",
      "lundbeck",
      "luxe",
      "luxury",
      "lv",
      "ly",
      "ma",
      "macys",
      "madrid",
      "maif",
      "maison",
      "makeup",
      "man",
      "management",
      "mango",
      "map",
      "market",
      "marketing",
      "markets",
      "marriott",
      "marshalls",
      "maserati",
      "mattel",
      "mba",
      "mc",
      "mckinsey",
      "md",
      "me",
      "med",
      "media",
      "meet",
      "melbourne",
      "meme",
      "memorial",
      "men",
      "menu",
      "merckmsd",
      "mg",
      "mh",
      "miami",
      "microsoft",
      "mil",
      "mini",
      "mint",
      "mit",
      "mitsubishi",
      "mk",
      "ml",
      "mlb",
      "mls",
      "mm",
      "mma",
      "mn",
      "mo",
      "mobi",
      "mobile",
      "moda",
      "moe",
      "moi",
      "mom",
      "monash",
      "money",
      "monster",
      "mormon",
      "mortgage",
      "moscow",
      "moto",
      "motorcycles",
      "mov",
      "movie",
      "mp",
      "mq",
      "mr",
      "ms",
      "msd",
      "mt",
      "mtn",
      "mtr",
      "mu",
      "museum",
      "music",
      "mutual",
      "mv",
      "mw",
      "mx",
      "my",
      "mz",
      "na",
      "nab",
      "nagoya",
      "name",
      "natura",
      "navy",
      "nba",
      "nc",
      "ne",
      "nec",
      "net",
      "netbank",
      "netflix",
      "network",
      "neustar",
      "new",
      "news",
      "next",
      "nextdirect",
      "nexus",
      "nf",
      "nfl",
      "ng",
      "ngo",
      "nhk",
      "ni",
      "nico",
      "nike",
      "nikon",
      "ninja",
      "nissan",
      "nissay",
      "nl",
      "no",
      "nokia",
      "northwesternmutual",
      "norton",
      "now",
      "nowruz",
      "nowtv",
      "np",
      "nr",
      "nra",
      "nrw",
      "ntt",
      "nu",
      "nyc",
      "nz",
      "obi",
      "observer",
      "office",
      "okinawa",
      "olayan",
      "olayangroup",
      "oldnavy",
      "ollo",
      "om",
      "omega",
      "one",
      "ong",
      "onl",
      "online",
      "ooo",
      "open",
      "oracle",
      "orange",
      "org",
      "organic",
      "origins",
      "osaka",
      "otsuka",
      "ott",
      "ovh",
      "pa",
      "page",
      "panasonic",
      "paris",
      "pars",
      "partners",
      "parts",
      "party",
      "passagens",
      "pay",
      "pccw",
      "pe",
      "pet",
      "pf",
      "pfizer",
      "pg",
      "ph",
      "pharmacy",
      "phd",
      "philips",
      "phone",
      "photo",
      "photography",
      "photos",
      "physio",
      "pics",
      "pictet",
      "pictures",
      "pid",
      "pin",
      "ping",
      "pink",
      "pioneer",
      "pizza",
      "pk",
      "pl",
      "place",
      "play",
      "playstation",
      "plumbing",
      "plus",
      "pm",
      "pn",
      "pnc",
      "pohl",
      "poker",
      "politie",
      "porn",
      "post",
      "pr",
      "pramerica",
      "praxi",
      "press",
      "prime",
      "pro",
      "prod",
      "productions",
      "prof",
      "progressive",
      "promo",
      "properties",
      "property",
      "protection",
      "pru",
      "prudential",
      "ps",
      "pt",
      "pub",
      "pw",
      "pwc",
      "py",
      "qa",
      "qpon",
      "quebec",
      "quest",
      "racing",
      "radio",
      "re",
      "read",
      "realestate",
      "realtor",
      "realty",
      "recipes",
      "red",
      "redstone",
      "redumbrella",
      "rehab",
      "reise",
      "reisen",
      "reit",
      "reliance",
      "ren",
      "rent",
      "rentals",
      "repair",
      "report",
      "republican",
      "rest",
      "restaurant",
      "review",
      "reviews",
      "rexroth",
      "rich",
      "richardli",
      "ricoh",
      "ril",
      "rio",
      "rip",
      "ro",
      "rocher",
      "rocks",
      "rodeo",
      "rogers",
      "room",
      "rs",
      "rsvp",
      "ru",
      "rugby",
      "ruhr",
      "run",
      "rw",
      "rwe",
      "ryukyu",
      "sa",
      "saarland",
      "safe",
      "safety",
      "sakura",
      "sale",
      "salon",
      "samsclub",
      "samsung",
      "sandvik",
      "sandvikcoromant",
      "sanofi",
      "sap",
      "sarl",
      "sas",
      "save",
      "saxo",
      "sb",
      "sbi",
      "sbs",
      "sc",
      "sca",
      "scb",
      "schaeffler",
      "schmidt",
      "scholarships",
      "school",
      "schule",
      "schwarz",
      "science",
      "scot",
      "sd",
      "se",
      "search",
      "seat",
      "secure",
      "security",
      "seek",
      "select",
      "sener",
      "services",
      "ses",
      "seven",
      "sew",
      "sex",
      "sexy",
      "sfr",
      "sg",
      "sh",
      "shangrila",
      "sharp",
      "shaw",
      "shell",
      "shia",
      "shiksha",
      "shoes",
      "shop",
      "shopping",
      "shouji",
      "show",
      "showtime",
      "si",
      "silk",
      "sina",
      "singles",
      "site",
      "sj",
      "sk",
      "ski",
      "skin",
      "sky",
      "skype",
      "sl",
      "sling",
      "sm",
      "smart",
      "smile",
      "sn",
      "sncf",
      "so",
      "soccer",
      "social",
      "softbank",
      "software",
      "sohu",
      "solar",
      "solutions",
      "song",
      "sony",
      "soy",
      "spa",
      "space",
      "sport",
      "spot",
      "sr",
      "srl",
      "ss",
      "st",
      "stada",
      "staples",
      "star",
      "statebank",
      "statefarm",
      "stc",
      "stcgroup",
      "stockholm",
      "storage",
      "store",
      "stream",
      "studio",
      "study",
      "style",
      "su",
      "sucks",
      "supplies",
      "supply",
      "support",
      "surf",
      "surgery",
      "suzuki",
      "sv",
      "swatch",
      "swiss",
      "sx",
      "sy",
      "sydney",
      "systems",
      "sz",
      "tab",
      "taipei",
      "talk",
      "taobao",
      "target",
      "tatamotors",
      "tatar",
      "tattoo",
      "tax",
      "taxi",
      "tc",
      "tci",
      "td",
      "tdk",
      "team",
      "tech",
      "technology",
      "tel",
      "temasek",
      "tennis",
      "teva",
      "tf",
      "tg",
      "th",
      "thd",
      "theater",
      "theatre",
      "tiaa",
      "tickets",
      "tienda",
      "tiffany",
      "tips",
      "tires",
      "tirol",
      "tj",
      "tjmaxx",
      "tjx",
      "tk",
      "tkmaxx",
      "tl",
      "tm",
      "tmall",
      "tn",
      "to",
      "today",
      "tokyo",
      "tools",
      "top",
      "toray",
      "toshiba",
      "total",
      "tours",
      "town",
      "toyota",
      "toys",
      "tr",
      "trade",
      "trading",
      "training",
      "travel",
      "travelchannel",
      "travelers",
      "travelersinsurance",
      "trust",
      "trv",
      "tt",
      "tube",
      "tui",
      "tunes",
      "tushu",
      "tv",
      "tvs",
      "tw",
      "tz",
      "ua",
      "ubank",
      "ubs",
      "ug",
      "uk",
      "unicom",
      "university",
      "uno",
      "uol",
      "ups",
      "us",
      "uy",
      "uz",
      "va",
      "vacations",
      "vana",
      "vanguard",
      "vc",
      "ve",
      "vegas",
      "ventures",
      "verisign",
      "verm\xF6gensberater",
      "verm\xF6gensberatung",
      "versicherung",
      "vet",
      "vg",
      "vi",
      "viajes",
      "video",
      "vig",
      "viking",
      "villas",
      "vin",
      "vip",
      "virgin",
      "visa",
      "vision",
      "viva",
      "vivo",
      "vlaanderen",
      "vn",
      "vodka",
      "volkswagen",
      "volvo",
      "vote",
      "voting",
      "voto",
      "voyage",
      "vu",
      "vuelos",
      "wales",
      "walmart",
      "walter",
      "wang",
      "wanggou",
      "watch",
      "watches",
      "weather",
      "weatherchannel",
      "webcam",
      "weber",
      "website",
      "wed",
      "wedding",
      "weibo",
      "weir",
      "wf",
      "whoswho",
      "wien",
      "wiki",
      "williamhill",
      "win",
      "windows",
      "wine",
      "winners",
      "wme",
      "wolterskluwer",
      "woodside",
      "work",
      "works",
      "world",
      "wow",
      "ws",
      "wtc",
      "wtf",
      "xbox",
      "xerox",
      "xfinity",
      "xihuan",
      "xin",
      "xxx",
      "xyz",
      "yachts",
      "yahoo",
      "yamaxun",
      "yandex",
      "ye",
      "yodobashi",
      "yoga",
      "yokohama",
      "you",
      "youtube",
      "yt",
      "yun",
      "za",
      "zappos",
      "zara",
      "zero",
      "zip",
      "zm",
      "zone",
      "zuerich",
      "zw",
      "\u03B5\u03BB",
      "\u03B5\u03C5",
      "\u0431\u0433",
      "\u0431\u0435\u043B",
      "\u0434\u0435\u0442\u0438",
      "\u0435\u044E",
      "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
      "\u043A\u043E\u043C",
      "\u043C\u043A\u0434",
      "\u043C\u043E\u043D",
      "\u043C\u043E\u0441\u043A\u0432\u0430",
      "\u043E\u043D\u043B\u0430\u0439\u043D",
      "\u043E\u0440\u0433",
      "\u0440\u0443\u0441",
      "\u0440\u0444",
      "\u0441\u0430\u0439\u0442",
      "\u0441\u0440\u0431",
      "\u0443\u043A\u0440",
      "\u049B\u0430\u0437",
      "\u0570\u0561\u0575",
      "\u05D9\u05E9\u05E8\u05D0\u05DC",
      "\u05E7\u05D5\u05DD",
      "\u0627\u0628\u0648\u0638\u0628\u064A",
      "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
      "\u0627\u0631\u0627\u0645\u0643\u0648",
      "\u0627\u0644\u0627\u0631\u062F\u0646",
      "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
      "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
      "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
      "\u0627\u0644\u0645\u063A\u0631\u0628",
      "\u0627\u0645\u0627\u0631\u0627\u062A",
      "\u0627\u06CC\u0631\u0627\u0646",
      "\u0628\u0627\u0631\u062A",
      "\u0628\u0627\u0632\u0627\u0631",
      "\u0628\u064A\u062A\u0643",
      "\u0628\u06BE\u0627\u0631\u062A",
      "\u062A\u0648\u0646\u0633",
      "\u0633\u0648\u062F\u0627\u0646",
      "\u0633\u0648\u0631\u064A\u0629",
      "\u0634\u0628\u0643\u0629",
      "\u0639\u0631\u0627\u0642",
      "\u0639\u0631\u0628",
      "\u0639\u0645\u0627\u0646",
      "\u0641\u0644\u0633\u0637\u064A\u0646",
      "\u0642\u0637\u0631",
      "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
      "\u0643\u0648\u0645",
      "\u0645\u0635\u0631",
      "\u0645\u0644\u064A\u0633\u064A\u0627",
      "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
      "\u0645\u0648\u0642\u0639",
      "\u0647\u0645\u0631\u0627\u0647",
      "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
      "\u0680\u0627\u0631\u062A",
      "\u0915\u0949\u092E",
      "\u0928\u0947\u091F",
      "\u092D\u093E\u0930\u0924",
      "\u092D\u093E\u0930\u0924\u092E\u094D",
      "\u092D\u093E\u0930\u094B\u0924",
      "\u0938\u0902\u0917\u0920\u0928",
      "\u09AC\u09BE\u0982\u09B2\u09BE",
      "\u09AD\u09BE\u09B0\u09A4",
      "\u09AD\u09BE\u09F0\u09A4",
      "\u0A2D\u0A3E\u0A30\u0A24",
      "\u0AAD\u0ABE\u0AB0\u0AA4",
      "\u0B2D\u0B3E\u0B30\u0B24",
      "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
      "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
      "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
      "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
      "\u0CAD\u0CBE\u0CB0\u0CA4",
      "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
      "\u0DBD\u0D82\u0D9A\u0DCF",
      "\u0E04\u0E2D\u0E21",
      "\u0E44\u0E17\u0E22",
      "\u0EA5\u0EB2\u0EA7",
      "\u10D2\u10D4",
      "\u307F\u3093\u306A",
      "\u30A2\u30DE\u30BE\u30F3",
      "\u30AF\u30E9\u30A6\u30C9",
      "\u30B0\u30FC\u30B0\u30EB",
      "\u30B3\u30E0",
      "\u30B9\u30C8\u30A2",
      "\u30BB\u30FC\u30EB",
      "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
      "\u30DD\u30A4\u30F3\u30C8",
      "\u4E16\u754C",
      "\u4E2D\u4FE1",
      "\u4E2D\u56FD",
      "\u4E2D\u570B",
      "\u4E2D\u6587\u7F51",
      "\u4E9A\u9A6C\u900A",
      "\u4F01\u4E1A",
      "\u4F5B\u5C71",
      "\u4FE1\u606F",
      "\u5065\u5EB7",
      "\u516B\u5366",
      "\u516C\u53F8",
      "\u516C\u76CA",
      "\u53F0\u6E7E",
      "\u53F0\u7063",
      "\u5546\u57CE",
      "\u5546\u5E97",
      "\u5546\u6807",
      "\u5609\u91CC",
      "\u5609\u91CC\u5927\u9152\u5E97",
      "\u5728\u7EBF",
      "\u5927\u62FF",
      "\u5929\u4E3B\u6559",
      "\u5A31\u4E50",
      "\u5BB6\u96FB",
      "\u5E7F\u4E1C",
      "\u5FAE\u535A",
      "\u6148\u5584",
      "\u6211\u7231\u4F60",
      "\u624B\u673A",
      "\u62DB\u8058",
      "\u653F\u52A1",
      "\u653F\u5E9C",
      "\u65B0\u52A0\u5761",
      "\u65B0\u95FB",
      "\u65F6\u5C1A",
      "\u66F8\u7C4D",
      "\u673A\u6784",
      "\u6DE1\u9A6C\u9521",
      "\u6E38\u620F",
      "\u6FB3\u9580",
      "\u70B9\u770B",
      "\u79FB\u52A8",
      "\u7EC4\u7EC7\u673A\u6784",
      "\u7F51\u5740",
      "\u7F51\u5E97",
      "\u7F51\u7AD9",
      "\u7F51\u7EDC",
      "\u8054\u901A",
      "\u8BFA\u57FA\u4E9A",
      "\u8C37\u6B4C",
      "\u8D2D\u7269",
      "\u901A\u8CA9",
      "\u96C6\u56E2",
      "\u96FB\u8A0A\u76C8\u79D1",
      "\u98DE\u5229\u6D66",
      "\u98DF\u54C1",
      "\u9910\u5385",
      "\u9999\u683C\u91CC\u62C9",
      "\u9999\u6E2F",
      "\uB2F7\uB137",
      "\uB2F7\uCEF4",
      "\uC0BC\uC131",
      "\uD55C\uAD6D"
    ];
    function detectFacets(text) {
      var _a;
      let match;
      const facets = [];
      {
        const re = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
        while (match = re.exec(text.utf16)) {
          if (!isValidDomain(match[3]) && !match[3].endsWith(".test")) {
            continue;
          }
          const start = text.utf16.indexOf(match[3], match.index) - 1;
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(start),
              byteEnd: text.utf16IndexToUtf8Index(start + match[3].length + 1)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#mention",
                did: match[3]
              }
            ]
          });
        }
      }
      {
        const re = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
        while (match = re.exec(text.utf16)) {
          let uri2 = match[2];
          if (!uri2.startsWith("http")) {
            const domain = (_a = match.groups) == null ? void 0 : _a.domain;
            if (!domain || !isValidDomain(domain)) {
              continue;
            }
            uri2 = `https://${uri2}`;
          }
          const start = text.utf16.indexOf(match[2], match.index);
          const index = { start, end: start + match[2].length };
          if (/[.,;:!?]$/.test(uri2)) {
            uri2 = uri2.slice(0, -1);
            index.end--;
          }
          if (/[)]$/.test(uri2) && !uri2.includes("(")) {
            uri2 = uri2.slice(0, -1);
            index.end--;
          }
          facets.push({
            index: {
              byteStart: text.utf16IndexToUtf8Index(index.start),
              byteEnd: text.utf16IndexToUtf8Index(index.end)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#link",
                uri: uri2
              }
            ]
          });
        }
      }
      {
        const re = /(?:^|\s)(#[^\d\s]\S*)(?=\s)?/g;
        while (match = re.exec(text.utf16)) {
          let [tag] = match;
          const hasLeadingSpace = /^\s/.test(tag);
          tag = tag.trim().replace(new RegExp("\\p{P}+$", "gu"), "");
          if (tag.length > 66)
            continue;
          const index = match.index + (hasLeadingSpace ? 1 : 0);
          facets.push({
            index: {
              byteStart: text.utf16IndexToUtf8Index(index),
              byteEnd: text.utf16IndexToUtf8Index(index + tag.length)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#tag",
                tag: tag.replace(/^#/, "")
              }
            ]
          });
        }
      }
      return facets.length > 0 ? facets : void 0;
    }
    function isValidDomain(str) {
      return !!tlds_default.find((tld) => {
        const i = str.lastIndexOf(tld);
        if (i === -1) {
          return false;
        }
        return str.charAt(i - 1) === "." && i === str.length - tld.length;
      });
    }
    var RichTextSegment = class {
      constructor(text, facet) {
        this.text = text;
        this.facet = facet;
      }
      get link() {
        var _a;
        const link = (_a = this.facet) == null ? void 0 : _a.features.find(facet_exports.isLink);
        if (facet_exports.isLink(link)) {
          return link;
        }
        return void 0;
      }
      isLink() {
        return !!this.link;
      }
      get mention() {
        var _a;
        const mention = (_a = this.facet) == null ? void 0 : _a.features.find(facet_exports.isMention);
        if (facet_exports.isMention(mention)) {
          return mention;
        }
        return void 0;
      }
      isMention() {
        return !!this.mention;
      }
      get tag() {
        var _a;
        const tag = (_a = this.facet) == null ? void 0 : _a.features.find(facet_exports.isTag);
        if (facet_exports.isTag(tag)) {
          return tag;
        }
        return void 0;
      }
      isTag() {
        return !!this.tag;
      }
    };
    var RichText = class {
      constructor(props, opts) {
        var _a, _b;
        this.unicodeText = new UnicodeString(props.text);
        this.facets = props.facets;
        if (!((_a = this.facets) == null ? void 0 : _a.length) && ((_b = props.entities) == null ? void 0 : _b.length)) {
          this.facets = entitiesToFacets(this.unicodeText, props.entities);
        }
        if (this.facets) {
          this.facets.sort(facetSort);
        }
        if (opts == null ? void 0 : opts.cleanNewlines) {
          sanitizeRichText(this, { cleanNewlines: true }).copyInto(this);
        }
      }
      get text() {
        return this.unicodeText.toString();
      }
      get length() {
        return this.unicodeText.length;
      }
      get graphemeLength() {
        return this.unicodeText.graphemeLength;
      }
      clone() {
        return new RichText({
          text: this.unicodeText.utf16,
          facets: cloneDeep(this.facets)
        });
      }
      copyInto(target) {
        target.unicodeText = this.unicodeText;
        target.facets = cloneDeep(this.facets);
      }
      *segments() {
        const facets = this.facets || [];
        if (!facets.length) {
          yield new RichTextSegment(this.unicodeText.utf16);
          return;
        }
        let textCursor = 0;
        let facetCursor = 0;
        do {
          const currFacet = facets[facetCursor];
          if (textCursor < currFacet.index.byteStart) {
            yield new RichTextSegment(this.unicodeText.slice(textCursor, currFacet.index.byteStart));
          } else if (textCursor > currFacet.index.byteStart) {
            facetCursor++;
            continue;
          }
          if (currFacet.index.byteStart < currFacet.index.byteEnd) {
            const subtext = this.unicodeText.slice(currFacet.index.byteStart, currFacet.index.byteEnd);
            if (!subtext.trim()) {
              yield new RichTextSegment(subtext);
            } else {
              yield new RichTextSegment(subtext, currFacet);
            }
          }
          textCursor = currFacet.index.byteEnd;
          facetCursor++;
        } while (facetCursor < facets.length);
        if (textCursor < this.unicodeText.length) {
          yield new RichTextSegment(this.unicodeText.slice(textCursor, this.unicodeText.length));
        }
      }
      insert(insertIndex, insertText) {
        var _a;
        this.unicodeText = new UnicodeString(this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex));
        if (!((_a = this.facets) == null ? void 0 : _a.length)) {
          return this;
        }
        const numCharsAdded = insertText.length;
        for (const ent of this.facets) {
          if (insertIndex <= ent.index.byteStart) {
            ent.index.byteStart += numCharsAdded;
            ent.index.byteEnd += numCharsAdded;
          } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {
            ent.index.byteEnd += numCharsAdded;
          }
        }
        return this;
      }
      delete(removeStartIndex, removeEndIndex) {
        var _a;
        this.unicodeText = new UnicodeString(this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex));
        if (!((_a = this.facets) == null ? void 0 : _a.length)) {
          return this;
        }
        const numCharsRemoved = removeEndIndex - removeStartIndex;
        for (const ent of this.facets) {
          if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {
            ent.index.byteStart = 0;
            ent.index.byteEnd = 0;
          } else if (removeStartIndex > ent.index.byteEnd) {
          } else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {
            ent.index.byteEnd = removeStartIndex;
          } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
            ent.index.byteEnd -= numCharsRemoved;
          } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
            ent.index.byteStart = removeStartIndex;
            ent.index.byteEnd -= numCharsRemoved;
          } else if (removeEndIndex < ent.index.byteStart) {
            ent.index.byteStart -= numCharsRemoved;
            ent.index.byteEnd -= numCharsRemoved;
          }
        }
        this.facets = this.facets.filter((ent) => ent.index.byteStart < ent.index.byteEnd);
        return this;
      }
      async detectFacets(agent) {
        this.facets = detectFacets(this.unicodeText);
        if (this.facets) {
          for (const facet of this.facets) {
            for (const feature of facet.features) {
              if (facet_exports.isMention(feature)) {
                const did2 = await agent.resolveHandle({ handle: feature.did }).catch((_) => void 0).then((res) => res == null ? void 0 : res.data.did);
                feature.did = did2 || "";
              }
            }
          }
          this.facets.sort(facetSort);
        }
      }
      detectFacetsWithoutResolution() {
        this.facets = detectFacets(this.unicodeText);
        if (this.facets) {
          this.facets.sort(facetSort);
        }
      }
    };
    var facetSort = (a, b) => a.index.byteStart - b.index.byteStart;
    function entitiesToFacets(text, entities) {
      const facets = [];
      for (const ent of entities) {
        if (ent.type === "link") {
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(ent.index.start),
              byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
            },
            features: [{ $type: "app.bsky.richtext.facet#link", uri: ent.value }]
          });
        } else if (ent.type === "mention") {
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(ent.index.start),
              byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
            },
            features: [
              { $type: "app.bsky.richtext.facet#mention", did: ent.value }
            ]
          });
        }
      }
      return facets;
    }
    function cloneDeep(v) {
      if (typeof v === "undefined") {
        return v;
      }
      return JSON.parse(JSON.stringify(v));
    }
    var ModerationDecision = class {
      constructor(cause = void 0, alert = false, blur = false, blurMedia = false, filter = false, noOverride = false, additionalCauses = [], did2 = "") {
        this.cause = cause;
        this.alert = alert;
        this.blur = blur;
        this.blurMedia = blurMedia;
        this.filter = filter;
        this.noOverride = noOverride;
        this.additionalCauses = additionalCauses;
        this.did = did2;
      }
      static noop() {
        return new ModerationDecision();
      }
    };
    var LABELS = {
      "!hide": {
        id: "!hide",
        preferences: ["hide"],
        flags: ["no-override"],
        onwarn: "blur",
        groupId: "system",
        configurable: false,
        strings: {
          settings: {
            en: {
              name: "Moderator Hide",
              description: "Moderator has chosen to hide the content."
            }
          },
          account: {
            en: {
              name: "Content Blocked",
              description: "This account has been hidden by the moderators."
            }
          },
          content: {
            en: {
              name: "Content Blocked",
              description: "This content has been hidden by the moderators."
            }
          }
        }
      },
      "!no-promote": {
        id: "!no-promote",
        preferences: ["hide"],
        flags: [],
        onwarn: null,
        groupId: "system",
        configurable: false,
        strings: {
          settings: {
            en: {
              name: "Moderator Filter",
              description: "Moderator has chosen to filter the content from feeds."
            }
          },
          account: {
            en: {
              name: "N/A",
              description: "N/A"
            }
          },
          content: {
            en: {
              name: "N/A",
              description: "N/A"
            }
          }
        }
      },
      "!warn": {
        id: "!warn",
        preferences: ["warn"],
        flags: [],
        onwarn: "blur",
        groupId: "system",
        configurable: false,
        strings: {
          settings: {
            en: {
              name: "Moderator Warn",
              description: "Moderator has chosen to set a general warning on the content."
            }
          },
          account: {
            en: {
              name: "Content Warning",
              description: "This account has received a general warning from moderators."
            }
          },
          content: {
            en: {
              name: "Content Warning",
              description: "This content has received a general warning from moderators."
            }
          }
        }
      },
      "!no-unauthenticated": {
        id: "!no-unauthenticated",
        preferences: ["hide"],
        flags: ["no-override", "unauthed"],
        onwarn: "blur",
        groupId: "system",
        configurable: false,
        strings: {
          settings: {
            en: {
              name: "Sign-in Required",
              description: "This user has requested that their account only be shown to signed-in users."
            }
          },
          account: {
            en: {
              name: "Sign-in Required",
              description: "This user has requested that their account only be shown to signed-in users."
            }
          },
          content: {
            en: {
              name: "Sign-in Required",
              description: "This user has requested that their content only be shown to signed-in users."
            }
          }
        }
      },
      "dmca-violation": {
        id: "dmca-violation",
        preferences: ["hide"],
        flags: ["no-override"],
        onwarn: "blur",
        groupId: "legal",
        configurable: false,
        strings: {
          settings: {
            en: {
              name: "Copyright Violation",
              description: "The content has received a DMCA takedown request."
            }
          },
          account: {
            en: {
              name: "Copyright Violation",
              description: "This account has received a DMCA takedown request. It will be restored if the concerns can be resolved."
            }
          },
          content: {
            en: {
              name: "Copyright Violation",
              description: "This content has received a DMCA takedown request. It will be restored if the concerns can be resolved."
            }
          }
        }
      },
      doxxing: {
        id: "doxxing",
        preferences: ["hide"],
        flags: ["no-override"],
        onwarn: "blur",
        groupId: "legal",
        configurable: false,
        strings: {
          settings: {
            en: {
              name: "Doxxing",
              description: "Information that reveals private information about someone which has been shared without the consent of the subject."
            }
          },
          account: {
            en: {
              name: "Doxxing",
              description: "This account has been reported to publish private information about someone without their consent. This report is currently under review."
            }
          },
          content: {
            en: {
              name: "Doxxing",
              description: "This content has been reported to include private information about someone without their consent."
            }
          }
        }
      },
      porn: {
        id: "porn",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "sexual",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Pornography",
              description: "Images of full-frontal nudity (genitalia) in any sexualized context, or explicit sexual activity (meaning contact with genitalia or breasts) even if partially covered. Includes graphic sexual cartoons (often jokes/memes)."
            }
          },
          account: {
            en: {
              name: "Adult Content",
              description: "This account contains imagery of full-frontal nudity or explicit sexual activity."
            }
          },
          content: {
            en: {
              name: "Adult Content",
              description: "This content contains imagery of full-frontal nudity or explicit sexual activity."
            }
          }
        }
      },
      sexual: {
        id: "sexual",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "sexual",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Sexually Suggestive",
              description: 'Content that does not meet the level of "pornography", but is still sexual. Some common examples have been selfies and "hornyposting" with underwear on, or partially naked (naked but covered, eg with hands or from side perspective). Sheer/see-through nipples may end up in this category.'
            }
          },
          account: {
            en: {
              name: "Suggestive Content",
              description: "This account contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
            }
          },
          content: {
            en: {
              name: "Suggestive Content",
              description: "This content contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
            }
          }
        }
      },
      nudity: {
        id: "nudity",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "sexual",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Nudity",
              description: 'Nudity which is not sexual, or that is primarily "artistic" in nature. For example: breastfeeding; classic art paintings and sculptures; newspaper images with some nudity; fashion modeling. "Erotic photography" is likely to end up in sexual or porn.'
            }
          },
          account: {
            en: {
              name: "Adult Content",
              description: "This account contains imagery which portrays nudity in a non-sexual or artistic setting."
            }
          },
          content: {
            en: {
              name: "Adult Content",
              description: "This content contains imagery which portrays nudity in a non-sexual or artistic setting."
            }
          }
        }
      },
      nsfl: {
        id: "nsfl",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "violence",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "NSFL",
              description: `"Not Suitable For Life." This includes graphic images like the infamous "goatse" (don't look it up).`
            }
          },
          account: {
            en: {
              name: "Graphic Imagery (NSFL)",
              description: 'This account contains graphic images which are often referred to as "Not Suitable For Life."'
            }
          },
          content: {
            en: {
              name: "Graphic Imagery (NSFL)",
              description: 'This content contains graphic images which are often referred to as "Not Suitable For Life."'
            }
          }
        }
      },
      corpse: {
        id: "corpse",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "violence",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Corpse",
              description: "Visual image of a dead human body in any context. Includes war images, hanging, funeral caskets. Does not include all figurative cases (cartoons), but can include realistic figurative images or renderings."
            }
          },
          account: {
            en: {
              name: "Graphic Imagery (Corpse)",
              description: "This account contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
            }
          },
          content: {
            en: {
              name: "Graphic Imagery (Corpse)",
              description: "This content contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
            }
          }
        }
      },
      gore: {
        id: "gore",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "violence",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Gore",
              description: "Intended for shocking images, typically involving blood or visible wounds."
            }
          },
          account: {
            en: {
              name: "Graphic Imagery (Gore)",
              description: "This account contains shocking images involving blood or visible wounds."
            }
          },
          content: {
            en: {
              name: "Graphic Imagery (Gore)",
              description: "This content contains shocking images involving blood or visible wounds."
            }
          }
        }
      },
      torture: {
        id: "torture",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur",
        groupId: "violence",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Torture",
              description: "Depictions of torture of a human or animal (animal cruelty)."
            }
          },
          account: {
            en: {
              name: "Graphic Imagery (Torture)",
              description: "This account contains depictions of torture of a human or animal."
            }
          },
          content: {
            en: {
              name: "Graphic Imagery (Torture)",
              description: "This content contains depictions of torture of a human or animal."
            }
          }
        }
      },
      "self-harm": {
        id: "self-harm",
        preferences: ["ignore", "warn", "hide"],
        flags: ["adult"],
        onwarn: "blur-media",
        groupId: "violence",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Self-Harm",
              description: "A visual depiction (photo or figurative) of cutting, suicide, or similar."
            }
          },
          account: {
            en: {
              name: "Graphic Imagery (Self-Harm)",
              description: "This account includes depictions of cutting, suicide, or other forms of self-harm."
            }
          },
          content: {
            en: {
              name: "Graphic Imagery (Self-Harm)",
              description: "This content includes depictions of cutting, suicide, or other forms of self-harm."
            }
          }
        }
      },
      "intolerant-race": {
        id: "intolerant-race",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "intolerance",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Racial Intolerance",
              description: "Hateful or intolerant content related to race."
            }
          },
          account: {
            en: {
              name: "Intolerance (Racial)",
              description: "This account includes hateful or intolerant content related to race."
            }
          },
          content: {
            en: {
              name: "Intolerance (Racial)",
              description: "This content includes hateful or intolerant views related to race."
            }
          }
        }
      },
      "intolerant-gender": {
        id: "intolerant-gender",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "intolerance",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Gender Intolerance",
              description: "Hateful or intolerant content related to gender or gender identity."
            }
          },
          account: {
            en: {
              name: "Intolerance (Gender)",
              description: "This account includes hateful or intolerant content related to gender or gender identity."
            }
          },
          content: {
            en: {
              name: "Intolerance (Gender)",
              description: "This content includes hateful or intolerant views related to gender or gender identity."
            }
          }
        }
      },
      "intolerant-sexual-orientation": {
        id: "intolerant-sexual-orientation",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "intolerance",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Sexual Orientation Intolerance",
              description: "Hateful or intolerant content related to sexual preferences."
            }
          },
          account: {
            en: {
              name: "Intolerance (Orientation)",
              description: "This account includes hateful or intolerant content related to sexual preferences."
            }
          },
          content: {
            en: {
              name: "Intolerance (Orientation)",
              description: "This content includes hateful or intolerant views related to sexual preferences."
            }
          }
        }
      },
      "intolerant-religion": {
        id: "intolerant-religion",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "intolerance",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Religious Intolerance",
              description: "Hateful or intolerant content related to religious views or practices."
            }
          },
          account: {
            en: {
              name: "Intolerance (Religious)",
              description: "This account includes hateful or intolerant content related to religious views or practices."
            }
          },
          content: {
            en: {
              name: "Intolerance (Religious)",
              description: "This content includes hateful or intolerant views related to religious views or practices."
            }
          }
        }
      },
      intolerant: {
        id: "intolerant",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "intolerance",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Intolerance",
              description: "A catchall for hateful or intolerant content which is not covered elsewhere."
            }
          },
          account: {
            en: {
              name: "Intolerance",
              description: "This account includes hateful or intolerant content."
            }
          },
          content: {
            en: {
              name: "Intolerance",
              description: "This content includes hateful or intolerant views."
            }
          }
        }
      },
      "icon-intolerant": {
        id: "icon-intolerant",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur-media",
        groupId: "intolerance",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Intolerant Iconography",
              description: "Visual imagery associated with a hate group, such as the KKK or Nazi, in any context (supportive, critical, documentary, etc)."
            }
          },
          account: {
            en: {
              name: "Intolerant Iconography",
              description: "This account includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
            }
          },
          content: {
            en: {
              name: "Intolerant Iconography",
              description: "This content includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
            }
          }
        }
      },
      threat: {
        id: "threat",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "rude",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Threats",
              description: "Statements or imagery published with the intent to threaten, intimidate, or harm."
            }
          },
          account: {
            en: {
              name: "Threats",
              description: "The moderators believe this account has published statements or imagery with the intent to threaten, intimidate, or harm others."
            }
          },
          content: {
            en: {
              name: "Threats",
              description: "The moderators believe this content was published with the intent to threaten, intimidate, or harm others."
            }
          }
        }
      },
      spoiler: {
        id: "spoiler",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "curation",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Spoiler",
              description: "Discussion about film, TV, etc which gives away plot points."
            }
          },
          account: {
            en: {
              name: "Spoiler Warning",
              description: "This account contains discussion about film, TV, etc which gives away plot points."
            }
          },
          content: {
            en: {
              name: "Spoiler Warning",
              description: "This content contains discussion about film, TV, etc which gives away plot points."
            }
          }
        }
      },
      spam: {
        id: "spam",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "spam",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Spam",
              description: "Repeat, low-quality messages which are clearly not designed to add to a conversation or space."
            }
          },
          account: {
            en: {
              name: "Spam",
              description: "This account publishes repeat, low-quality messages which are clearly not designed to add to a conversation or space."
            }
          },
          content: {
            en: {
              name: "Spam",
              description: "This content is a part of repeat, low-quality messages which are clearly not designed to add to a conversation or space."
            }
          }
        }
      },
      "account-security": {
        id: "account-security",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "misinfo",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Security Concerns",
              description: "Content designed to hijack user accounts such as a phishing attack."
            }
          },
          account: {
            en: {
              name: "Security Warning",
              description: "This account has published content designed to hijack user accounts such as a phishing attack."
            }
          },
          content: {
            en: {
              name: "Security Warning",
              description: "This content is designed to hijack user accounts such as a phishing attack."
            }
          }
        }
      },
      "net-abuse": {
        id: "net-abuse",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "blur",
        groupId: "misinfo",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Network Attacks",
              description: "Content designed to attack network systems such as denial-of-service attacks."
            }
          },
          account: {
            en: {
              name: "Network Attack Warning",
              description: "This account has published content designed to attack network systems such as denial-of-service attacks."
            }
          },
          content: {
            en: {
              name: "Network Attack Warning",
              description: "This content is designed to attack network systems such as denial-of-service attacks."
            }
          }
        }
      },
      impersonation: {
        id: "impersonation",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "alert",
        groupId: "misinfo",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Impersonation",
              description: "Accounts which falsely assert some identity."
            }
          },
          account: {
            en: {
              name: "Impersonation Warning",
              description: "The moderators believe this account is lying about their identity."
            }
          },
          content: {
            en: {
              name: "Impersonation Warning",
              description: "The moderators believe this account is lying about their identity."
            }
          }
        }
      },
      scam: {
        id: "scam",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "alert",
        groupId: "misinfo",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Scam",
              description: "Fraudulent content."
            }
          },
          account: {
            en: {
              name: "Scam Warning",
              description: "The moderators believe this account publishes fraudulent content."
            }
          },
          content: {
            en: {
              name: "Scam Warning",
              description: "The moderators believe this is fraudulent content."
            }
          }
        }
      },
      misleading: {
        id: "misleading",
        preferences: ["ignore", "warn", "hide"],
        flags: [],
        onwarn: "alert",
        groupId: "misinfo",
        configurable: true,
        strings: {
          settings: {
            en: {
              name: "Misleading",
              description: "Accounts which share misleading information."
            }
          },
          account: {
            en: {
              name: "Misleading",
              description: "The moderators believe this account is spreading misleading information."
            }
          },
          content: {
            en: {
              name: "Misleading",
              description: "The moderators believe this account is spreading misleading information."
            }
          }
        }
      }
    };
    var ModerationCauseAccumulator = class {
      constructor() {
        this.did = "";
        this.causes = [];
      }
      setDid(did2) {
        this.did = did2;
      }
      addBlocking(blocking) {
        if (blocking) {
          this.causes.push({
            type: "blocking",
            source: { type: "user" },
            priority: 3
          });
        }
      }
      addBlockingByList(blockingByList) {
        if (blockingByList) {
          this.causes.push({
            type: "blocking",
            source: { type: "list", list: blockingByList },
            priority: 3
          });
        }
      }
      addBlockedBy(blockedBy) {
        if (blockedBy) {
          this.causes.push({
            type: "blocked-by",
            source: { type: "user" },
            priority: 4
          });
        }
      }
      addBlockOther(blockOther) {
        if (blockOther) {
          this.causes.push({
            type: "block-other",
            source: { type: "user" },
            priority: 4
          });
        }
      }
      addLabel(label, opts) {
        const labelDef = LABELS[label.val];
        if (!labelDef) {
          return;
        }
        const isSelf = label.src === this.did;
        const labeler = isSelf ? void 0 : opts.labelers.find((s) => s.labeler.did === label.src);
        let labelPref = "ignore";
        if (!labelDef.configurable) {
          labelPref = labelDef.preferences[0];
        } else if (labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
          labelPref = "hide";
        } else if (labeler == null ? void 0 : labeler.labels[label.val]) {
          labelPref = labeler.labels[label.val];
        } else if (opts.labels[label.val]) {
          labelPref = opts.labels[label.val];
        }
        if (labelPref === "ignore") {
          return;
        }
        if (labelDef.flags.includes("unauthed") && !!opts.userDid) {
          return;
        }
        let priority;
        if (labelDef.flags.includes("no-override")) {
          priority = 1;
        } else if (labelPref === "hide") {
          priority = 2;
        } else if (labelDef.onwarn === "blur") {
          priority = 5;
        } else if (labelDef.onwarn === "blur-media") {
          priority = 7;
        } else {
          priority = 8;
        }
        this.causes.push({
          type: "label",
          source: isSelf || !labeler ? { type: "user" } : { type: "labeler", labeler: labeler.labeler },
          label,
          labelDef,
          setting: labelPref,
          priority
        });
      }
      addMuted(muted) {
        if (muted) {
          this.causes.push({
            type: "muted",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addMutedByList(mutedByList) {
        if (mutedByList) {
          this.causes.push({
            type: "muted",
            source: { type: "list", list: mutedByList },
            priority: 6
          });
        }
      }
      finalizeDecision(opts) {
        const mod = new ModerationDecision();
        mod.did = this.did;
        if (!this.causes.length) {
          return mod;
        }
        this.causes.sort((a, b) => a.priority - b.priority);
        mod.cause = this.causes[0];
        mod.additionalCauses = this.causes.slice(1);
        if (mod.cause.type === "blocking" || mod.cause.type === "blocked-by" || mod.cause.type === "block-other") {
          mod.filter = true;
          mod.blur = true;
          mod.noOverride = true;
        } else if (mod.cause.type === "muted") {
          mod.filter = true;
          mod.blur = true;
        } else if (mod.cause.type === "label") {
          if (mod.cause.setting === "hide") {
            mod.filter = true;
          }
          switch (mod.cause.labelDef.onwarn) {
            case "alert":
              mod.alert = true;
              break;
            case "blur":
              mod.blur = true;
              break;
            case "blur-media":
              mod.blurMedia = true;
              break;
            case null:
              break;
          }
          if (mod.cause.labelDef.flags.includes("no-override")) {
            mod.noOverride = true;
          } else if (mod.cause.labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
            mod.noOverride = true;
          }
        }
        return mod;
      }
    };
    function decideAccount(subject, opts) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const acc = new ModerationCauseAccumulator();
      acc.setDid(subject.did);
      if ((_a = subject.viewer) == null ? void 0 : _a.muted) {
        if ((_b = subject.viewer) == null ? void 0 : _b.mutedByList) {
          acc.addMutedByList((_c = subject.viewer) == null ? void 0 : _c.mutedByList);
        } else {
          acc.addMuted((_d = subject.viewer) == null ? void 0 : _d.muted);
        }
      }
      if ((_e = subject.viewer) == null ? void 0 : _e.blocking) {
        if ((_f = subject.viewer) == null ? void 0 : _f.blockingByList) {
          acc.addBlockingByList((_g = subject.viewer) == null ? void 0 : _g.blockingByList);
        } else {
          acc.addBlocking((_h = subject.viewer) == null ? void 0 : _h.blocking);
        }
      }
      acc.addBlockedBy((_i = subject.viewer) == null ? void 0 : _i.blockedBy);
      for (const label of filterAccountLabels(subject.labels)) {
        acc.addLabel(label, opts);
      }
      return acc.finalizeDecision(opts);
    }
    function filterAccountLabels(labels) {
      if (!labels) {
        return [];
      }
      return labels.filter((label) => !label.uri.endsWith("/app.bsky.actor.profile/self") || label.val === "!no-unauthenticated");
    }
    function decideProfile(subject, opts) {
      const acc = new ModerationCauseAccumulator();
      acc.setDid(subject.did);
      for (const label of filterProfileLabels(subject.labels)) {
        acc.addLabel(label, opts);
      }
      return acc.finalizeDecision(opts);
    }
    function filterProfileLabels(labels) {
      if (!labels) {
        return [];
      }
      return labels.filter((label) => label.uri.endsWith("/app.bsky.actor.profile/self"));
    }
    function decidePost(subject, opts) {
      var _a;
      const acc = new ModerationCauseAccumulator();
      acc.setDid(subject.author.did);
      if ((_a = subject.labels) == null ? void 0 : _a.length) {
        for (const label of subject.labels) {
          acc.addLabel(label, opts);
        }
      }
      return acc.finalizeDecision(opts);
    }
    function decideQuotedPost(subject, opts) {
      var _a, _b, _c, _d, _e;
      const acc = new ModerationCauseAccumulator();
      if (record_exports.isViewRecord(subject.record)) {
        acc.setDid(subject.record.author.did);
        if ((_a = subject.record.labels) == null ? void 0 : _a.length) {
          for (const label of subject.record.labels) {
            acc.addLabel(label, opts);
          }
        }
      } else if (record_exports.isViewBlocked(subject.record)) {
        acc.setDid(subject.record.author.did);
        if ((_b = subject.record.author.viewer) == null ? void 0 : _b.blocking) {
          acc.addBlocking((_c = subject.record.author.viewer) == null ? void 0 : _c.blocking);
        } else if ((_d = subject.record.author.viewer) == null ? void 0 : _d.blockedBy) {
          acc.addBlockedBy((_e = subject.record.author.viewer) == null ? void 0 : _e.blockedBy);
        } else {
          acc.addBlockOther(true);
        }
      }
      return acc.finalizeDecision(opts);
    }
    function decideQuotedPostAccount(subject, opts) {
      if (record_exports.isViewRecord(subject.record)) {
        return decideAccount(subject.record.author, opts);
      }
      return ModerationDecision.noop();
    }
    function decideQuotedPostWithMedia(subject, opts) {
      var _a, _b, _c, _d, _e;
      const acc = new ModerationCauseAccumulator();
      if (record_exports.isViewRecord(subject.record.record)) {
        acc.setDid(subject.record.record.author.did);
        if ((_a = subject.record.record.labels) == null ? void 0 : _a.length) {
          for (const label of subject.record.record.labels) {
            acc.addLabel(label, opts);
          }
        }
      } else if (record_exports.isViewBlocked(subject.record.record)) {
        acc.setDid(subject.record.record.author.did);
        if ((_b = subject.record.record.author.viewer) == null ? void 0 : _b.blocking) {
          acc.addBlocking((_c = subject.record.record.author.viewer) == null ? void 0 : _c.blocking);
        } else if ((_d = subject.record.record.author.viewer) == null ? void 0 : _d.blockedBy) {
          acc.addBlockedBy((_e = subject.record.record.author.viewer) == null ? void 0 : _e.blockedBy);
        } else {
          acc.addBlockOther(true);
        }
      }
      return acc.finalizeDecision(opts);
    }
    function decideQuotedPostWithMediaAccount(subject, opts) {
      if (record_exports.isViewRecord(subject.record.record)) {
        return decideAccount(subject.record.record.author, opts);
      }
      return ModerationDecision.noop();
    }
    function decideFeedGenerator(_subject, _opts) {
      return ModerationDecision.noop();
    }
    function decideUserList(_subject, _opts) {
      return ModerationDecision.noop();
    }
    function takeHighestPriorityDecision(...decisions) {
      const filtered = decisions.filter((d) => !!d);
      if (filtered.length === 0) {
        return ModerationDecision.noop();
      }
      filtered.sort((a, b) => {
        if (a.cause && b.cause) {
          return a.cause.priority - b.cause.priority;
        }
        if (a.cause) {
          return -1;
        }
        if (b.cause) {
          return 1;
        }
        return 0;
      });
      return filtered[0];
    }
    function downgradeDecision(decision, to) {
      decision.filter = false;
      decision.noOverride = false;
      if (to === "noop") {
        decision.blur = false;
        decision.blurMedia = false;
        decision.alert = false;
        delete decision.cause;
      } else if (to === "alert") {
        decision.blur = false;
        decision.blurMedia = false;
        decision.alert = true;
      }
    }
    function isModerationDecisionNoop(decision, { ignoreFilter } = { ignoreFilter: false }) {
      if (!decision) {
        return true;
      }
      if (decision.alert) {
        return false;
      }
      if (decision.blur) {
        return false;
      }
      if (decision.filter && !ignoreFilter) {
        return false;
      }
      return true;
    }
    function isQuotedPost(embed) {
      return Boolean(embed && record_exports.isView(embed));
    }
    function isQuotedPostWithMedia(embed) {
      return Boolean(embed && recordWithMedia_exports.isView(embed));
    }
    function toModerationUI(decision) {
      return {
        cause: decision.cause,
        filter: decision.filter,
        blur: decision.blur,
        alert: decision.alert,
        noOverride: decision.noOverride
      };
    }
    function moderateProfile(subject, opts) {
      var _a, _b, _c, _d;
      const account = decideAccount(subject, opts);
      const profile = decideProfile(subject, opts);
      if (account.blurMedia) {
        account.blur = true;
      }
      profile.filter = false;
      if (!isModerationDecisionNoop(account) && account.did === opts.userDid) {
        downgradeDecision(account, "alert");
      }
      if (!isModerationDecisionNoop(profile) && profile.did === opts.userDid) {
        downgradeDecision(profile, "alert");
      }
      let avatarBlur = false;
      let avatarNoOverride = false;
      if ((account.blur || account.blurMedia) && ((_a = account.cause) == null ? void 0 : _a.type) !== "muted") {
        avatarBlur = true;
        avatarNoOverride = account.noOverride || profile.noOverride;
      } else if (profile.blur || profile.blurMedia) {
        avatarBlur = true;
        avatarNoOverride = account.noOverride || profile.noOverride;
      }
      if (((_b = account.cause) == null ? void 0 : _b.type) === "blocking" || ((_c = account.cause) == null ? void 0 : _c.type) === "blocked-by" || ((_d = account.cause) == null ? void 0 : _d.type) === "muted") {
        account.blur = false;
        account.noOverride = false;
      }
      return {
        decisions: { account, profile },
        account: account.filter || account.blur || account.alert ? toModerationUI(account) : {},
        profile: profile.filter || profile.blur || profile.alert ? toModerationUI(profile) : {},
        avatar: {
          blur: avatarBlur,
          alert: account.alert || profile.alert,
          noOverride: avatarNoOverride
        }
      };
    }
    function moderatePost(subject, opts) {
      var _a, _b;
      const post = decidePost(subject, opts);
      const account = decideAccount(subject.author, opts);
      const profile = decideProfile(subject.author, opts);
      let quote;
      let quotedAccount;
      if (isQuotedPost(subject.embed)) {
        quote = decideQuotedPost(subject.embed, opts);
        quotedAccount = decideQuotedPostAccount(subject.embed, opts);
      } else if (isQuotedPostWithMedia(subject.embed)) {
        quote = decideQuotedPostWithMedia(subject.embed, opts);
        quotedAccount = decideQuotedPostWithMediaAccount(subject.embed, opts);
      }
      if (quote == null ? void 0 : quote.blurMedia) {
        quote.blur = true;
      }
      if (!isModerationDecisionNoop(post) && post.did === opts.userDid) {
        downgradeDecision(post, "blur");
      }
      if (account.cause && account.did === opts.userDid) {
        downgradeDecision(account, "noop");
      }
      if (profile.cause && profile.did === opts.userDid) {
        downgradeDecision(profile, "noop");
      }
      if (quote && !isModerationDecisionNoop(quote) && quote.did === opts.userDid) {
        downgradeDecision(quote, "blur");
      }
      if (quotedAccount && !isModerationDecisionNoop(quotedAccount) && quotedAccount.did === opts.userDid) {
        downgradeDecision(quotedAccount, "noop");
      }
      const mergedForFeed = takeHighestPriorityDecision(post, account, quote, quotedAccount);
      const mergedForView = takeHighestPriorityDecision(post, account);
      const mergedQuote = takeHighestPriorityDecision(quote, quotedAccount);
      let blurAvatar = false;
      if ((account.blur || account.blurMedia) && ((_a = account.cause) == null ? void 0 : _a.type) !== "muted") {
        blurAvatar = true;
      } else if ((profile.blur || profile.blurMedia) && ((_b = profile.cause) == null ? void 0 : _b.type) !== "muted") {
        blurAvatar = true;
      }
      return {
        decisions: { post, account, profile, quote, quotedAccount },
        content: {
          cause: !isModerationDecisionNoop(mergedForView) ? mergedForView.cause : mergedForFeed.filter ? mergedForFeed.cause : void 0,
          filter: mergedForFeed.filter,
          blur: mergedForView.blur,
          alert: mergedForView.alert,
          noOverride: mergedForView.noOverride
        },
        avatar: {
          blur: blurAvatar,
          alert: account.alert || profile.alert,
          noOverride: account.noOverride || profile.noOverride
        },
        embed: !isModerationDecisionNoop(mergedQuote, { ignoreFilter: true }) ? {
          cause: mergedQuote.cause,
          blur: mergedQuote.blur,
          alert: mergedQuote.alert,
          noOverride: mergedQuote.noOverride
        } : account.blurMedia ? {
          cause: account.cause,
          blur: true,
          noOverride: account.noOverride
        } : post.blurMedia ? {
          cause: post.cause,
          blur: true,
          noOverride: post.noOverride
        } : {}
      };
    }
    function moderateFeedGenerator(subject, opts) {
      const feedGenerator = decideFeedGenerator(subject, opts);
      const account = decideAccount(subject.creator, opts);
      const profile = decideProfile(subject.creator, opts);
      const merged = takeHighestPriorityDecision(feedGenerator, account);
      return {
        decisions: { feedGenerator, account, profile },
        content: {
          cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
          filter: merged.filter,
          blur: merged.blur,
          alert: merged.alert,
          noOverride: merged.noOverride
        },
        avatar: {
          blur: account.blurMedia || profile.blurMedia,
          alert: account.alert,
          noOverride: account.noOverride || profile.noOverride
        }
      };
    }
    function moderateUserList(subject, opts) {
      const userList = decideUserList(subject, opts);
      const account = defs_exports5.isProfileViewBasic(subject.creator) ? decideAccount(subject.creator, opts) : ModerationDecision.noop();
      const profile = defs_exports5.isProfileViewBasic(subject.creator) ? decideProfile(subject.creator, opts) : ModerationDecision.noop();
      const merged = takeHighestPriorityDecision(userList, account);
      return {
        decisions: { userList, account, profile },
        content: {
          cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
          filter: merged.filter,
          blur: merged.blur,
          alert: merged.alert,
          noOverride: merged.noOverride
        },
        avatar: {
          blur: account.blurMedia || profile.blurMedia,
          alert: account.alert,
          noOverride: account.noOverride || profile.noOverride
        }
      };
    }
    var LABEL_GROUPS = {
      system: {
        id: "system",
        configurable: false,
        labels: [
          LABELS["!hide"],
          LABELS["!no-promote"],
          LABELS["!warn"],
          LABELS["!no-unauthenticated"]
        ],
        strings: {
          settings: {
            en: {
              name: "System",
              description: "Moderator overrides for special cases."
            }
          }
        }
      },
      legal: {
        id: "legal",
        configurable: false,
        labels: [LABELS["dmca-violation"], LABELS["doxxing"]],
        strings: {
          settings: {
            en: {
              name: "Legal",
              description: "Content removed for legal reasons."
            }
          }
        }
      },
      sexual: {
        id: "sexual",
        configurable: true,
        labels: [LABELS["porn"], LABELS["sexual"], LABELS["nudity"]],
        strings: {
          settings: {
            en: {
              name: "Adult Content",
              description: "Content which is sexual in nature."
            }
          }
        }
      },
      violence: {
        id: "violence",
        configurable: true,
        labels: [
          LABELS["nsfl"],
          LABELS["corpse"],
          LABELS["gore"],
          LABELS["torture"],
          LABELS["self-harm"]
        ],
        strings: {
          settings: {
            en: {
              name: "Violence",
              description: "Content which is violent or deeply disturbing."
            }
          }
        }
      },
      intolerance: {
        id: "intolerance",
        configurable: true,
        labels: [
          LABELS["intolerant-race"],
          LABELS["intolerant-gender"],
          LABELS["intolerant-sexual-orientation"],
          LABELS["intolerant-religion"],
          LABELS["intolerant"],
          LABELS["icon-intolerant"]
        ],
        strings: {
          settings: {
            en: {
              name: "Intolerance",
              description: "Content or behavior which is hateful or intolerant toward a group of people."
            }
          }
        }
      },
      rude: {
        id: "rude",
        configurable: true,
        labels: [LABELS["threat"]],
        strings: {
          settings: {
            en: {
              name: "Rude",
              description: "Behavior which is rude toward other users."
            }
          }
        }
      },
      curation: {
        id: "curation",
        configurable: true,
        labels: [LABELS["spoiler"]],
        strings: {
          settings: {
            en: {
              name: "Curational",
              description: "Subjective moderation geared towards curating a more positive environment."
            }
          }
        }
      },
      spam: {
        id: "spam",
        configurable: true,
        labels: [LABELS["spam"]],
        strings: {
          settings: {
            en: {
              name: "Spam",
              description: "Content which doesn't add to the conversation."
            }
          }
        }
      },
      misinfo: {
        id: "misinfo",
        configurable: true,
        labels: [
          LABELS["account-security"],
          LABELS["net-abuse"],
          LABELS["impersonation"],
          LABELS["scam"],
          LABELS["misleading"]
        ],
        strings: {
          settings: {
            en: {
              name: "Misinformation",
              description: "Content which misleads or defrauds users."
            }
          }
        }
      }
    };
    var FEED_VIEW_PREF_DEFAULTS = {
      hideReplies: false,
      hideRepliesByUnfollowed: false,
      hideRepliesByLikeCount: 0,
      hideReposts: false,
      hideQuotePosts: false
    };
    var THREAD_VIEW_PREF_DEFAULTS = {
      sort: "oldest",
      prioritizeFollowedUsers: true
    };
    var BskyAgent = class extends AtpAgent {
      constructor() {
        super(...arguments);
        this.getTimeline = (params2, opts) => this.api.app.bsky.feed.getTimeline(params2, opts);
        this.getAuthorFeed = (params2, opts) => this.api.app.bsky.feed.getAuthorFeed(params2, opts);
        this.getActorLikes = (params2, opts) => this.api.app.bsky.feed.getActorLikes(params2, opts);
        this.getPostThread = (params2, opts) => this.api.app.bsky.feed.getPostThread(params2, opts);
        this.getPost = (params2) => this.api.app.bsky.feed.post.get(params2);
        this.getPosts = (params2, opts) => this.api.app.bsky.feed.getPosts(params2, opts);
        this.getLikes = (params2, opts) => this.api.app.bsky.feed.getLikes(params2, opts);
        this.getRepostedBy = (params2, opts) => this.api.app.bsky.feed.getRepostedBy(params2, opts);
        this.getFollows = (params2, opts) => this.api.app.bsky.graph.getFollows(params2, opts);
        this.getFollowers = (params2, opts) => this.api.app.bsky.graph.getFollowers(params2, opts);
        this.getProfile = (params2, opts) => this.api.app.bsky.actor.getProfile(params2, opts);
        this.getProfiles = (params2, opts) => this.api.app.bsky.actor.getProfiles(params2, opts);
        this.getSuggestions = (params2, opts) => this.api.app.bsky.actor.getSuggestions(params2, opts);
        this.searchActors = (params2, opts) => this.api.app.bsky.actor.searchActors(params2, opts);
        this.searchActorsTypeahead = (params2, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params2, opts);
        this.listNotifications = (params2, opts) => this.api.app.bsky.notification.listNotifications(params2, opts);
        this.countUnreadNotifications = (params2, opts) => this.api.app.bsky.notification.getUnreadCount(params2, opts);
      }
      get app() {
        return this.api.app;
      }
      async post(record) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        record.createdAt = record.createdAt || (/* @__PURE__ */ new Date()).toISOString();
        return this.api.app.bsky.feed.post.create({ repo: this.session.did }, record);
      }
      async deletePost(postUri) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        const postUrip = new AtUri(postUri);
        return await this.api.app.bsky.feed.post.delete({
          repo: postUrip.hostname,
          rkey: postUrip.rkey
        });
      }
      async like(uri2, cid2) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
          subject: { uri: uri2, cid: cid2 },
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteLike(likeUri) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        const likeUrip = new AtUri(likeUri);
        return await this.api.app.bsky.feed.like.delete({
          repo: likeUrip.hostname,
          rkey: likeUrip.rkey
        });
      }
      async repost(uri2, cid2) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
          subject: { uri: uri2, cid: cid2 },
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteRepost(repostUri) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        const repostUrip = new AtUri(repostUri);
        return await this.api.app.bsky.feed.repost.delete({
          repo: repostUrip.hostname,
          rkey: repostUrip.rkey
        });
      }
      async follow(subjectDid) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
          subject: subjectDid,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteFollow(followUri) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        const followUrip = new AtUri(followUri);
        return await this.api.app.bsky.graph.follow.delete({
          repo: followUrip.hostname,
          rkey: followUrip.rkey
        });
      }
      async upsertProfile(updateFn) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        let retriesRemaining = 5;
        while (retriesRemaining >= 0) {
          const existing = await this.com.atproto.repo.getRecord({
            repo: this.session.did,
            collection: "app.bsky.actor.profile",
            rkey: "self"
          }).catch((_) => void 0);
          const updated = await updateFn(existing == null ? void 0 : existing.data.value);
          if (updated) {
            updated.$type = "app.bsky.actor.profile";
          }
          const validation = profile_exports.validateRecord(updated);
          if (!validation.success) {
            throw validation.error;
          }
          try {
            await this.com.atproto.repo.putRecord({
              repo: this.session.did,
              collection: "app.bsky.actor.profile",
              rkey: "self",
              record: updated,
              swapRecord: (existing == null ? void 0 : existing.data.cid) || null
            });
          } catch (e) {
            if (retriesRemaining > 0 && e instanceof putRecord_exports.InvalidSwapError) {
              retriesRemaining--;
              continue;
            } else {
              throw e;
            }
          }
          break;
        }
      }
      async mute(actor) {
        return this.api.app.bsky.graph.muteActor({ actor });
      }
      async unmute(actor) {
        return this.api.app.bsky.graph.unmuteActor({ actor });
      }
      async muteModList(uri2) {
        return this.api.app.bsky.graph.muteActorList({
          list: uri2
        });
      }
      async unmuteModList(uri2) {
        return this.api.app.bsky.graph.unmuteActorList({
          list: uri2
        });
      }
      async blockModList(uri2) {
        if (!this.session) {
          throw new Error("Not logged in");
        }
        return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
          subject: uri2,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async unblockModList(uri2) {
        var _a;
        if (!this.session) {
          throw new Error("Not logged in");
        }
        const listInfo = await this.api.app.bsky.graph.getList({
          list: uri2,
          limit: 1
        });
        if (!((_a = listInfo.data.list.viewer) == null ? void 0 : _a.blocked)) {
          return;
        }
        const { rkey } = new AtUri(listInfo.data.list.viewer.blocked);
        return await this.api.app.bsky.graph.listblock.delete({
          repo: this.session.did,
          rkey
        });
      }
      async updateSeenNotifications(seenAt) {
        seenAt = seenAt || (/* @__PURE__ */ new Date()).toISOString();
        return this.api.app.bsky.notification.updateSeen({
          seenAt
        });
      }
      async getPreferences() {
        const prefs = {
          feeds: {
            saved: void 0,
            pinned: void 0
          },
          feedViewPrefs: {
            home: {
              ...FEED_VIEW_PREF_DEFAULTS
            }
          },
          threadViewPrefs: { ...THREAD_VIEW_PREF_DEFAULTS },
          adultContentEnabled: false,
          contentLabels: {},
          birthDate: void 0
        };
        const res = await this.app.bsky.actor.getPreferences({});
        for (const pref of res.data.preferences) {
          if (defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
            prefs.adultContentEnabled = pref.enabled;
          } else if (defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
            let value = pref.visibility;
            if (value === "show") {
              value = "ignore";
            }
            if (value === "ignore" || value === "warn" || value === "hide") {
              prefs.contentLabels[pref.label] = value;
            }
          } else if (defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success) {
            prefs.feeds.saved = pref.saved;
            prefs.feeds.pinned = pref.pinned;
          } else if (defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success) {
            if (pref.birthDate) {
              prefs.birthDate = new Date(pref.birthDate);
            }
          } else if (defs_exports5.isFeedViewPref(pref) && defs_exports5.validateFeedViewPref(pref).success) {
            const { $type, feed, ...v } = pref;
            prefs.feedViewPrefs[pref.feed] = { ...FEED_VIEW_PREF_DEFAULTS, ...v };
          } else if (defs_exports5.isThreadViewPref(pref) && defs_exports5.validateThreadViewPref(pref).success) {
            const { $type, ...v } = pref;
            prefs.threadViewPrefs = { ...prefs.threadViewPrefs, ...v };
          }
        }
        return prefs;
      }
      async setSavedFeeds(saved, pinned) {
        return updateFeedPreferences(this, () => ({
          saved,
          pinned
        }));
      }
      async addSavedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
          saved: [...saved.filter((uri2) => uri2 !== v), v],
          pinned
        }));
      }
      async removeSavedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
          saved: saved.filter((uri2) => uri2 !== v),
          pinned: pinned.filter((uri2) => uri2 !== v)
        }));
      }
      async addPinnedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
          saved: [...saved.filter((uri2) => uri2 !== v), v],
          pinned: [...pinned.filter((uri2) => uri2 !== v), v]
        }));
      }
      async removePinnedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
          saved,
          pinned: pinned.filter((uri2) => uri2 !== v)
        }));
      }
      async setAdultContentEnabled(v) {
        await updatePreferences(this, (prefs) => {
          let adultContentPref = prefs.findLast((pref) => defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success);
          if (adultContentPref) {
            adultContentPref.enabled = v;
          } else {
            adultContentPref = {
              $type: "app.bsky.actor.defs#adultContentPref",
              enabled: v
            };
          }
          return prefs.filter((pref) => !defs_exports5.isAdultContentPref(pref)).concat([adultContentPref]);
        });
      }
      async setContentLabelPref(key, value) {
        if (value === "show") {
          value = "ignore";
        }
        await updatePreferences(this, (prefs) => {
          let labelPref = prefs.findLast((pref) => defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success && pref.label === key);
          if (labelPref) {
            labelPref.visibility = value;
          } else {
            labelPref = {
              $type: "app.bsky.actor.defs#contentLabelPref",
              label: key,
              visibility: value
            };
          }
          return prefs.filter((pref) => !defs_exports5.isContentLabelPref(pref) || pref.label !== key).concat([labelPref]);
        });
      }
      async setPersonalDetails({
        birthDate
      }) {
        birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
        await updatePreferences(this, (prefs) => {
          let personalDetailsPref = prefs.findLast((pref) => defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success);
          if (personalDetailsPref) {
            personalDetailsPref.birthDate = birthDate;
          } else {
            personalDetailsPref = {
              $type: "app.bsky.actor.defs#personalDetailsPref",
              birthDate
            };
          }
          return prefs.filter((pref) => !defs_exports5.isPersonalDetailsPref(pref)).concat([personalDetailsPref]);
        });
      }
      async setFeedViewPrefs(feed, pref) {
        await updatePreferences(this, (prefs) => {
          const existing = prefs.findLast((pref2) => defs_exports5.isFeedViewPref(pref2) && defs_exports5.validateFeedViewPref(pref2).success && pref2.feed === feed);
          if (existing) {
            pref = { ...existing, ...pref };
          }
          return prefs.filter((p) => !defs_exports5.isFeedViewPref(pref) || p.feed !== feed).concat([{ ...pref, $type: "app.bsky.actor.defs#feedViewPref", feed }]);
        });
      }
      async setThreadViewPrefs(pref) {
        await updatePreferences(this, (prefs) => {
          const existing = prefs.findLast((pref2) => defs_exports5.isThreadViewPref(pref2) && defs_exports5.validateThreadViewPref(pref2).success);
          if (existing) {
            pref = { ...existing, ...pref };
          }
          return prefs.filter((p) => !defs_exports5.isThreadViewPref(p)).concat([{ ...pref, $type: "app.bsky.actor.defs#threadViewPref" }]);
        });
      }
    };
    async function updatePreferences(agent, cb) {
      const res = await agent.app.bsky.actor.getPreferences({});
      const newPrefs = cb(res.data.preferences);
      if (newPrefs === false) {
        return;
      }
      await agent.app.bsky.actor.putPreferences({
        preferences: newPrefs
      });
    }
    async function updateFeedPreferences(agent, cb) {
      let res;
      await updatePreferences(agent, (prefs) => {
        let feedsPref = prefs.findLast((pref) => defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success);
        if (feedsPref) {
          res = cb(feedsPref.saved, feedsPref.pinned);
          feedsPref.saved = res.saved;
          feedsPref.pinned = res.pinned;
        } else {
          res = cb([], []);
          feedsPref = {
            $type: "app.bsky.actor.defs#savedFeedsPref",
            saved: res.saved,
            pinned: res.pinned
          };
        }
        return prefs.filter((pref) => !defs_exports5.isSavedFeedsPref(pref)).concat([feedsPref]);
      });
      return res;
    }
  }
});

// node_modules/mime/dist/types/other.js
var types, other_default;
var init_other = __esm({
  "node_modules/mime/dist/types/other.js"() {
    types = { "application/prs.cww": ["cww"], "application/prs.xsf+xml": ["xsf"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["*xfdf"], "application/vnd.age": ["age"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["*fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["*mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.pwg-xhtml-print+xml": ["xhtm"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml", "uo"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["*prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["*sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["*aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif", "btf"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.cld": ["cld"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.pytha.pyox": ["pyo", "pyox"], "model/vnd.sap.vds": ["vds"], "model/vnd.usda": ["usda"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.familysearch.gedcom": ["ged"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
    Object.freeze(types);
    other_default = types;
  }
});

// node_modules/mime/dist/types/standard.js
var types2, standard_default;
var init_standard = __esm({
  "node_modules/mime/dist/types/standard.js"() {
    types2 = { "application/andrew-inset": ["ez"], "application/appinstaller": ["appinstaller"], "application/applixware": ["aw"], "application/appx": ["appx"], "application/appxbundle": ["appxbundle"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/automationml-aml+xml": ["aml"], "application/automationml-amlx+zip": ["amlx"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cpl+xml": ["cpl"], "application/cu-seeme": ["cu"], "application/cwl": ["cwl"], "application/dash+xml": ["mpd"], "application/dash-patch+xml": ["mpp"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdf": ["fdf"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["*js"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/media-policy-dataset+xml": ["mpf"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["*mp4", "*mpg4", "mp4s", "m4p"], "application/msix": ["msix"], "application/msixbundle": ["msixbundle"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-keys": ["asc"], "application/pgp-signature": ["sig", "*asc"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/sql": ["sql"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/watcherinfo+xml": ["wif"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xfdf": ["xfdf"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/aac": ["adts", "aac"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avci": ["avci"], "image/avcs": ["avcs"], "image/avif": ["avif"], "image/bmp": ["bmp", "dib"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/dpx": ["dpx"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm", "jpgm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/jt": ["jt"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/prc": ["prc"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/u3d": ["u3d"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/javascript": ["js", "mjs"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["md", "markdown"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/wgsl": ["wgsl"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "*jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    Object.freeze(types2);
    standard_default = types2;
  }
});

// node_modules/mime/dist/src/Mime.js
var __classPrivateFieldGet, _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions, Mime, Mime_default;
var init_Mime = __esm({
  "node_modules/mime/dist/src/Mime.js"() {
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    Mime = class {
      constructor(...args) {
        _Mime_extensionToType.set(this, /* @__PURE__ */ new Map());
        _Mime_typeToExtension.set(this, /* @__PURE__ */ new Map());
        _Mime_typeToExtensions.set(this, /* @__PURE__ */ new Map());
        for (const arg of args) {
          this.define(arg);
        }
      }
      define(typeMap, force = false) {
        for (let [type, extensions] of Object.entries(typeMap)) {
          type = type.toLowerCase();
          extensions = extensions.map((ext) => ext.toLowerCase());
          if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) {
            __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, /* @__PURE__ */ new Set());
          }
          const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
          let first = true;
          for (let extension of extensions) {
            const starred = extension.startsWith("*");
            extension = starred ? extension.slice(1) : extension;
            allExtensions == null ? void 0 : allExtensions.add(extension);
            if (first) {
              __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension);
            }
            first = false;
            if (starred)
              continue;
            const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
            if (currentType && currentType != type && !force) {
              throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
            }
            __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type);
          }
        }
        return this;
      }
      getType(path) {
        var _a;
        if (typeof path !== "string")
          return null;
        const last = path.replace(/^.*[/\\]/, "").toLowerCase();
        const ext = last.replace(/^.*\./, "").toLowerCase();
        const hasPath = last.length < path.length;
        const hasDot = ext.length < last.length - 1;
        if (!hasDot && hasPath)
          return null;
        return (_a = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext)) != null ? _a : null;
      }
      getExtension(type) {
        var _a, _b;
        if (typeof type !== "string")
          return null;
        type = (_a = type == null ? void 0 : type.split) == null ? void 0 : _a.call(type, ";")[0];
        return (_b = type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) != null ? _b : null;
      }
      getAllExtensions(type) {
        var _a;
        if (typeof type !== "string")
          return null;
        return (_a = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase())) != null ? _a : null;
      }
      _freeze() {
        this.define = () => {
          throw new Error("define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances");
        };
        Object.freeze(this);
        for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) {
          Object.freeze(extensions);
        }
        return this;
      }
      _getTestState() {
        return {
          types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
          extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f")
        };
      }
    };
    _Mime_extensionToType = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtension = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtensions = /* @__PURE__ */ new WeakMap();
    Mime_default = Mime;
  }
});

// node_modules/mime/dist/src/index.js
var src_exports = {};
__export(src_exports, {
  Mime: () => Mime_default,
  default: () => src_default
});
var src_default;
var init_src = __esm({
  "node_modules/mime/dist/src/index.js"() {
    init_other();
    init_standard();
    init_Mime();
    init_Mime();
    src_default = new Mime_default(standard_default, other_default)._freeze();
  }
});

// lib/BlueskyAction.js
var require_BlueskyAction = __commonJS({
  "lib/BlueskyAction.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BlueskyAction = exports2.Reference = void 0;
    var core2 = __importStar2(require_core());
    var api_1 = require_dist();
    var fs = __importStar2(require("fs"));
    var mime_1 = __importDefault((init_src(), __toCommonJS(src_exports)));
    var Reference = class {
      static parse(json) {
        if (json)
          return JSON.parse(json);
      }
    };
    exports2.Reference = Reference;
    var BlueskyAction = class {
      constructor(service, identifier, password) {
        this.agent = new api_1.BskyAgent({ service });
        this.identifier = identifier;
        this.password = password;
      }
      run(text, replyTo, media) {
        return __awaiter2(this, void 0, void 0, function* () {
          core2.info("\u2601\uFE0F  Sending BlueSky post");
          yield this.agent.login({
            identifier: this.identifier,
            password: this.password
          });
          const rt = new api_1.RichText({
            text
          });
          yield rt.detectFacets(this.agent);
          const uploadMedia = (media2) => __awaiter2(this, void 0, void 0, function* () {
            const files = yield fs.promises.readdir(media2);
            return yield Promise.all(files.map((file) => __awaiter2(this, void 0, void 0, function* () {
              const filePath = `${media2}/${file}`;
              const mimeType = mime_1.default.getType(file);
              core2.debug(`\u2601\uFE0F  uploading media ${filePath}`);
              const blob = yield fs.promises.readFile(filePath);
              if (!mimeType)
                throw new Error(`Unsupported media type for upload ${filePath}`);
              const response = yield this.agent.uploadBlob(blob, {
                encoding: mimeType
              });
              return response.data.blob;
            })));
          });
          const uploads = media ? yield uploadMedia(media) : [];
          if (replyTo) {
            const request = {
              $type: "app.bsky.feed.post",
              text: rt.text,
              facets: rt.facets,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              reply: {
                root: {
                  cid: replyTo.cid,
                  uri: replyTo.uri
                },
                parent: {
                  cid: replyTo.cid,
                  uri: replyTo.uri
                }
              },
              embed: {
                $type: "app.bsky.embed.images",
                images: uploads.map((blob) => {
                  return {
                    alt: "",
                    image: blob
                  };
                })
              }
            };
            const result = yield this.agent.post(request);
            core2.info(`\u2601\uFE0F  Sent reply post ${result.cid}:${result.uri}`);
            return result;
          } else {
            const request = {
              $type: "app.bsky.feed.post",
              text: rt.text,
              facets: rt.facets,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              embed: {
                $type: "app.bsky.embed.images",
                images: uploads.map((blob) => {
                  return {
                    alt: "",
                    image: blob
                  };
                })
              }
            };
            const result = yield this.agent.post(request);
            core2.info(`\u2601\uFE0F  Sent post ${result.cid}:${result.uri}`);
            return result;
          }
        });
      }
    };
    exports2.BlueskyAction = BlueskyAction;
  }
});

// lib/Valid.js
var require_Valid = __commonJS({
  "lib/Valid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Valid = void 0;
    var ValidT = class {
      constructor(key) {
        this.key = key;
      }
      required(store) {
        const value = store(this.key);
        if (value)
          return value;
        else
          throw new Error(`${this.key} is required`);
      }
      as(store, parser) {
        const value = store(this.key);
        if (value)
          return parser(value);
      }
    };
    function Valid(key) {
      return new ValidT(key);
    }
    exports2.Valid = Valid;
  }
});

// lib/main.js
var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = exports && exports.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", { value: true });
var core = __importStar(require_core());
var BlueskyAction_1 = require_BlueskyAction();
var Valid_1 = require_Valid();
function main() {
  return __awaiter(this, void 0, void 0, function* () {
    const service = (0, Valid_1.Valid)("service").required(core.getInput);
    const identifier = (0, Valid_1.Valid)("identifier").required(core.getInput);
    const password = (0, Valid_1.Valid)("password").required(core.getInput);
    core.setSecret(password);
    const action = new BlueskyAction_1.BlueskyAction(service, identifier, password);
    const text = (0, Valid_1.Valid)("text").required(core.getInput);
    const replyTo = (0, Valid_1.Valid)("replyTo").as(core.getInput, BlueskyAction_1.Reference.parse);
    const media = core.getInput("media");
    const reference = yield action.run(text, replyTo, media);
    core.setOutput("reference", JSON.stringify(reference));
  });
}
main();
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
