{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACp1fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpnIA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChDA;;ACAA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvCA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/JA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEtDA;AACA;AACA;AACA","sources":["../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/command.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/core.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/file-command.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/oidc-utils.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/path-utils.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/summary.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/utils.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+http-client@2.1.0/node_modules/@actions/http-client/lib/auth.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+http-client@2.1.0/node_modules/@actions/http-client/lib/index.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@actions+http-client@2.1.0/node_modules/@actions/http-client/lib/proxy.js","../webpack://bluesky-post-action/./node_modules/.pnpm/@atproto+api@0.2.7/node_modules/@atproto/api/dist/index.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-domexception@1.0.0/node_modules/node-domexception/index.js","../webpack://bluesky-post-action/./node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js","../webpack://bluesky-post-action/./node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/index.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/md5.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/nil.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/parse.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/regex.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/rng.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/sha1.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/stringify.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v1.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v3.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v35.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v4.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v5.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/validate.js","../webpack://bluesky-post-action/./node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/version.js","../webpack://bluesky-post-action/./node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js","../webpack://bluesky-post-action/external node-commonjs \"assert\"","../webpack://bluesky-post-action/external node-commonjs \"buffer\"","../webpack://bluesky-post-action/external node-commonjs \"crypto\"","../webpack://bluesky-post-action/external node-commonjs \"events\"","../webpack://bluesky-post-action/external node-commonjs \"fs\"","../webpack://bluesky-post-action/external node-commonjs \"http\"","../webpack://bluesky-post-action/external node-commonjs \"https\"","../webpack://bluesky-post-action/external node-commonjs \"net\"","../webpack://bluesky-post-action/external node-commonjs \"node:process\"","../webpack://bluesky-post-action/external node-commonjs \"node:stream/web\"","../webpack://bluesky-post-action/external node-commonjs \"os\"","../webpack://bluesky-post-action/external node-commonjs \"path\"","../webpack://bluesky-post-action/external node-commonjs \"tls\"","../webpack://bluesky-post-action/external node-commonjs \"util\"","../webpack://bluesky-post-action/external node-commonjs \"worker_threads\"","../webpack://bluesky-post-action/./node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/streams.cjs","../webpack://bluesky-post-action/./node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/file.js","../webpack://bluesky-post-action/external node-commonjs \"node:fs\"","../webpack://bluesky-post-action/external node-commonjs \"node:path\"","../webpack://bluesky-post-action/./node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/from.js","../webpack://bluesky-post-action/./node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/index.js","../webpack://bluesky-post-action/./node_modules/.pnpm/formdata-polyfill@4.0.10/node_modules/formdata-polyfill/esm.min.js","../webpack://bluesky-post-action/external node-commonjs \"node:http\"","../webpack://bluesky-post-action/external node-commonjs \"node:https\"","../webpack://bluesky-post-action/external node-commonjs \"node:zlib\"","../webpack://bluesky-post-action/external node-commonjs \"node:stream\"","../webpack://bluesky-post-action/external node-commonjs \"node:buffer\"","../webpack://bluesky-post-action/./node_modules/.pnpm/data-uri-to-buffer@4.0.1/node_modules/data-uri-to-buffer/dist/index.js","../webpack://bluesky-post-action/external node-commonjs \"node:util\"","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/errors/base.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/errors/fetch-error.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/utils/is.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/body.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/headers.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/utils/is-redirect.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/response.js","../webpack://bluesky-post-action/external node-commonjs \"node:url\"","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/utils/get-search.js","../webpack://bluesky-post-action/external node-commonjs \"node:net\"","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/utils/referrer.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/request.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/errors/abort-error.js","../webpack://bluesky-post-action/./node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/index.js","../webpack://bluesky-post-action/./src/agent.js","../webpack://bluesky-post-action/./src/index.js","../webpack://bluesky-post-action/./src/post.js","../webpack://bluesky-post-action/./src/validate.js","../webpack://bluesky-post-action/webpack/bootstrap","../webpack://bluesky-post-action/webpack/runtime/async module","../webpack://bluesky-post-action/webpack/runtime/define property getters","../webpack://bluesky-post-action/webpack/runtime/ensure chunk","../webpack://bluesky-post-action/webpack/runtime/get javascript chunk filename","../webpack://bluesky-post-action/webpack/runtime/hasOwnProperty shorthand","../webpack://bluesky-post-action/webpack/runtime/make namespace object","../webpack://bluesky-post-action/webpack/runtime/compat","../webpack://bluesky-post-action/webpack/runtime/import chunk loading","../webpack://bluesky-post-action/webpack/before-startup","../webpack://bluesky-post-action/webpack/startup","../webpack://bluesky-post-action/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst uuid_1 = require(\"uuid\");\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const reqHost = reqUrl.hostname;\n    if (isLoopbackAddress(reqHost)) {\n        return true;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperNoProxyItem === '*' ||\n            upperReqHosts.some(x => x === upperNoProxyItem ||\n                x.endsWith(`.${upperNoProxyItem}`) ||\n                (upperNoProxyItem.startsWith('.') &&\n                    x.endsWith(`${upperNoProxyItem}`)))) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\nfunction isLoopbackAddress(host) {\n    const hostLower = host.toLowerCase();\n    return (hostLower === 'localhost' ||\n        hostLower.startsWith('127.') ||\n        hostLower.startsWith('[::1]') ||\n        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));\n}\n//# sourceMappingURL=proxy.js.map","\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from3, except, desc) => {\n  if (from3 && typeof from3 === \"object\" || typeof from3 === \"function\") {\n    for (let key of __getOwnPropNames(from3))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// ../../node_modules/iso-datestring-validator/dist/index.js\nvar require_dist = __commonJS({\n  \"../../node_modules/iso-datestring-validator/dist/index.js\"(exports) {\n    (() => {\n      \"use strict\";\n      var e = { d: (t2, r2) => {\n        for (var n2 in r2)\n          e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });\n      }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e2, \"__esModule\", { value: true });\n      } }, t = {};\n      function r(e2, t2) {\n        return void 0 === t2 && (t2 = \"-\"), new RegExp(\"^(?!0{4}\" + t2 + \"0{2}\" + t2 + \"0{2})((?=[0-9]{4}\" + t2 + \"(((0[^2])|1[0-2])|02(?=\" + t2 + \"(([0-1][0-9])|2[0-8])))\" + t2 + \"[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))\" + t2 + \"02\" + t2 + \"29))([0-9]{4})\" + t2 + \"(?!((0[469])|11)\" + t2 + \"31)((0[1,3-9]|1[0-2])|(02(?!\" + t2 + \"3)))\" + t2 + \"(0[1-9]|[1-2][0-9]|3[0-1])$\").test(e2);\n      }\n      function n(e2) {\n        var t2 = /\\D/.exec(e2);\n        return t2 ? t2[0] : \"\";\n      }\n      function i(e2, t2, r2) {\n        void 0 === t2 && (t2 = \":\"), void 0 === r2 && (r2 = false);\n        var i2 = new RegExp(\"^([0-1]|2(?=([0-3])|4\" + t2 + \"00))[0-9]\" + t2 + \"[0-5][0-9](\" + t2 + \"([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$\");\n        if (!r2 || !/[Z+\\-]/.test(e2))\n          return i2.test(e2);\n        if (/Z$/.test(e2))\n          return i2.test(e2.replace(\"Z\", \"\"));\n        var o2 = e2.includes(\"+\"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];\n        return i2.test(u2) && function(e3, t3, r3) {\n          return void 0 === r3 && (r3 = \":\"), new RegExp(t3 ? \"^(0(?!(2\" + r3 + \"4)|0\" + r3 + \"3)|1(?=([0-1]|2(?=\" + r3 + \"[04])|[34](?=\" + r3 + \"0))))([03469](?=\" + r3 + \"[03])|[17](?=\" + r3 + \"0)|2(?=\" + r3 + \"[04])|5(?=\" + r3 + \"[034])|8(?=\" + r3 + \"[04]))\" + r3 + \"([03](?=0)|4(?=5))[05]$\" : \"^(0(?=[^0])|1(?=[0-2]))([39](?=\" + r3 + \"[03])|[0-24-8](?=\" + r3 + \"00))\" + r3 + \"[03]0$\").test(e3);\n        }(d2, o2, n(d2));\n      }\n      function o(e2) {\n        var t2 = e2.split(\"T\"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));\n        if (!a2)\n          return false;\n        var d2, s = (d2 = a2.match(/([^Z+\\-\\d])(?=\\d+\\1)/), Array.isArray(d2) ? d2[0] : \"\");\n        return u2 && i(a2, s, true);\n      }\n      function a(e2, t2) {\n        return void 0 === t2 && (t2 = \"-\"), new RegExp(\"^[0-9]{4}\" + t2 + \"(0(?=[^0])|1(?=[0-2]))[0-9]$\").test(e2);\n      }\n      e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });\n      var u = exports;\n      for (var d in t)\n        u[d] = t[d];\n      t.__esModule && Object.defineProperty(u, \"__esModule\", { value: true });\n    })();\n  }\n});\n\n// src/index.ts\nvar src_exports4 = {};\n__export(src_exports4, {\n  ActorNS: () => ActorNS,\n  AdminNS: () => AdminNS,\n  AppBskyActorDefs: () => defs_exports5,\n  AppBskyActorGetProfile: () => getProfile_exports,\n  AppBskyActorGetProfiles: () => getProfiles_exports,\n  AppBskyActorGetSuggestions: () => getSuggestions_exports,\n  AppBskyActorProfile: () => profile_exports,\n  AppBskyActorSearchActors: () => searchActors_exports,\n  AppBskyActorSearchActorsTypeahead: () => searchActorsTypeahead_exports,\n  AppBskyEmbedExternal: () => external_exports,\n  AppBskyEmbedImages: () => images_exports,\n  AppBskyEmbedRecord: () => record_exports,\n  AppBskyEmbedRecordWithMedia: () => recordWithMedia_exports,\n  AppBskyFeedDefs: () => defs_exports6,\n  AppBskyFeedGetAuthorFeed: () => getAuthorFeed_exports,\n  AppBskyFeedGetLikes: () => getLikes_exports,\n  AppBskyFeedGetPostThread: () => getPostThread_exports,\n  AppBskyFeedGetRepostedBy: () => getRepostedBy_exports,\n  AppBskyFeedGetTimeline: () => getTimeline_exports,\n  AppBskyFeedLike: () => like_exports,\n  AppBskyFeedPost: () => post_exports,\n  AppBskyFeedRepost: () => repost_exports,\n  AppBskyGraphFollow: () => follow_exports,\n  AppBskyGraphGetFollowers: () => getFollowers_exports,\n  AppBskyGraphGetFollows: () => getFollows_exports,\n  AppBskyGraphGetMutes: () => getMutes_exports,\n  AppBskyGraphMuteActor: () => muteActor_exports,\n  AppBskyGraphUnmuteActor: () => unmuteActor_exports,\n  AppBskyNotificationGetUnreadCount: () => getUnreadCount_exports,\n  AppBskyNotificationListNotifications: () => listNotifications_exports,\n  AppBskyNotificationUpdateSeen: () => updateSeen_exports,\n  AppBskyRichtextFacet: () => facet_exports,\n  AppBskyUnspeccedGetPopular: () => getPopular_exports,\n  AppNS: () => AppNS,\n  AtUri: () => AtUri,\n  AtpAgent: () => AtpAgent,\n  AtpBaseClient: () => AtpBaseClient,\n  AtpServiceClient: () => AtpServiceClient,\n  AtprotoNS: () => AtprotoNS,\n  BlobRef: () => BlobRef,\n  BskyAgent: () => BskyAgent,\n  BskyNS: () => BskyNS,\n  COM_ATPROTO_ADMIN: () => COM_ATPROTO_ADMIN,\n  COM_ATPROTO_MODERATION: () => COM_ATPROTO_MODERATION,\n  ComAtprotoAdminDefs: () => defs_exports,\n  ComAtprotoAdminDisableInviteCodes: () => disableInviteCodes_exports,\n  ComAtprotoAdminGetInviteCodes: () => getInviteCodes_exports,\n  ComAtprotoAdminGetModerationAction: () => getModerationAction_exports,\n  ComAtprotoAdminGetModerationActions: () => getModerationActions_exports,\n  ComAtprotoAdminGetModerationReport: () => getModerationReport_exports,\n  ComAtprotoAdminGetModerationReports: () => getModerationReports_exports,\n  ComAtprotoAdminGetRecord: () => getRecord_exports,\n  ComAtprotoAdminGetRepo: () => getRepo_exports,\n  ComAtprotoAdminResolveModerationReports: () => resolveModerationReports_exports,\n  ComAtprotoAdminReverseModerationAction: () => reverseModerationAction_exports,\n  ComAtprotoAdminSearchRepos: () => searchRepos_exports,\n  ComAtprotoAdminTakeModerationAction: () => takeModerationAction_exports,\n  ComAtprotoAdminUpdateAccountHandle: () => updateAccountHandle_exports,\n  ComAtprotoIdentityResolveHandle: () => resolveHandle_exports,\n  ComAtprotoIdentityUpdateHandle: () => updateHandle_exports,\n  ComAtprotoLabelDefs: () => defs_exports2,\n  ComAtprotoLabelQueryLabels: () => queryLabels_exports,\n  ComAtprotoLabelSubscribeLabels: () => subscribeLabels_exports,\n  ComAtprotoModerationCreateReport: () => createReport_exports,\n  ComAtprotoModerationDefs: () => defs_exports3,\n  ComAtprotoRepoApplyWrites: () => applyWrites_exports,\n  ComAtprotoRepoCreateRecord: () => createRecord_exports,\n  ComAtprotoRepoDeleteRecord: () => deleteRecord_exports,\n  ComAtprotoRepoDescribeRepo: () => describeRepo_exports,\n  ComAtprotoRepoGetRecord: () => getRecord_exports2,\n  ComAtprotoRepoListRecords: () => listRecords_exports,\n  ComAtprotoRepoPutRecord: () => putRecord_exports,\n  ComAtprotoRepoStrongRef: () => strongRef_exports,\n  ComAtprotoRepoUploadBlob: () => uploadBlob_exports,\n  ComAtprotoServerCreateAccount: () => createAccount_exports,\n  ComAtprotoServerCreateInviteCode: () => createInviteCode_exports,\n  ComAtprotoServerCreateInviteCodes: () => createInviteCodes_exports,\n  ComAtprotoServerCreateSession: () => createSession_exports,\n  ComAtprotoServerDefs: () => defs_exports4,\n  ComAtprotoServerDeleteAccount: () => deleteAccount_exports,\n  ComAtprotoServerDeleteSession: () => deleteSession_exports,\n  ComAtprotoServerDescribeServer: () => describeServer_exports,\n  ComAtprotoServerGetAccountInviteCodes: () => getAccountInviteCodes_exports,\n  ComAtprotoServerGetSession: () => getSession_exports,\n  ComAtprotoServerRefreshSession: () => refreshSession_exports,\n  ComAtprotoServerRequestAccountDelete: () => requestAccountDelete_exports,\n  ComAtprotoServerRequestPasswordReset: () => requestPasswordReset_exports,\n  ComAtprotoServerResetPassword: () => resetPassword_exports,\n  ComAtprotoSyncGetBlob: () => getBlob_exports,\n  ComAtprotoSyncGetBlocks: () => getBlocks_exports,\n  ComAtprotoSyncGetCheckout: () => getCheckout_exports,\n  ComAtprotoSyncGetCommitPath: () => getCommitPath_exports,\n  ComAtprotoSyncGetHead: () => getHead_exports,\n  ComAtprotoSyncGetRecord: () => getRecord_exports3,\n  ComAtprotoSyncGetRepo: () => getRepo_exports2,\n  ComAtprotoSyncListBlobs: () => listBlobs_exports,\n  ComAtprotoSyncListRepos: () => listRepos_exports,\n  ComAtprotoSyncNotifyOfUpdate: () => notifyOfUpdate_exports,\n  ComAtprotoSyncRequestCrawl: () => requestCrawl_exports,\n  ComAtprotoSyncSubscribeRepos: () => subscribeRepos_exports,\n  ComNS: () => ComNS,\n  EmbedNS: () => EmbedNS,\n  FeedNS: () => FeedNS,\n  FollowRecord: () => FollowRecord,\n  GraphNS: () => GraphNS,\n  IdentityNS: () => IdentityNS,\n  LabelNS: () => LabelNS,\n  LikeRecord: () => LikeRecord,\n  ModerationNS: () => ModerationNS,\n  NotificationNS: () => NotificationNS,\n  PostRecord: () => PostRecord,\n  ProfileRecord: () => ProfileRecord,\n  RepoNS: () => RepoNS,\n  RepostRecord: () => RepostRecord,\n  RichText: () => RichText,\n  RichTextSegment: () => RichTextSegment,\n  RichtextNS: () => RichtextNS,\n  ServerNS: () => ServerNS,\n  SyncNS: () => SyncNS,\n  UnicodeString: () => UnicodeString,\n  UnspeccedNS: () => UnspeccedNS,\n  default: () => AtpAgent,\n  jsonStringToLex: () => jsonStringToLex,\n  jsonToLex: () => jsonToLex,\n  lexToJson: () => lexToJson,\n  sanitizeRichText: () => sanitizeRichText,\n  stringifyLex: () => stringifyLex\n});\nmodule.exports = __toCommonJS(src_exports4);\n\n// ../common-web/src/check.ts\nvar check_exports = {};\n__export(check_exports, {\n  assure: () => assure,\n  is: () => is,\n  isObject: () => isObject\n});\nvar is = (obj, def2) => {\n  return def2.safeParse(obj).success;\n};\nvar assure = (def2, obj) => {\n  return def2.parse(obj);\n};\nvar isObject = (obj) => {\n  return typeof obj === \"object\" && obj !== null;\n};\n\n// ../../node_modules/multiformats/esm/vendor/varint.js\nvar encode_1 = encode;\nvar MSB = 128;\nvar REST = 127;\nvar MSBALL = ~REST;\nvar INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128;\nvar REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError(\"Could not decode varint\");\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function(value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nvar varint_default = _brrp_varint;\n\n// ../../node_modules/multiformats/esm/src/varint.js\nvar decode2 = (data, offset = 0) => {\n  const code2 = varint_default.decode(data, offset);\n  return [\n    code2,\n    varint_default.decode.bytes\n  ];\n};\nvar encodeTo = (int, target, offset = 0) => {\n  varint_default.encode(int, target, offset);\n  return target;\n};\nvar encodingLength = (int) => {\n  return varint_default.encodingLength(int);\n};\n\n// ../../node_modules/multiformats/esm/src/bytes.js\nvar empty = new Uint8Array(0);\nvar equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nvar coerce = (o) => {\n  if (o instanceof Uint8Array && o.constructor.name === \"Uint8Array\")\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error(\"Unknown type, must be binary type\");\n};\nvar fromString = (str) => new TextEncoder().encode(str);\nvar toString = (b) => new TextDecoder().decode(b);\n\n// ../../node_modules/multiformats/esm/src/hashes/digest.js\nvar create = (code2, digest2) => {\n  const size = digest2.byteLength;\n  const sizeOffset = encodingLength(code2);\n  const digestOffset = sizeOffset + encodingLength(size);\n  const bytes2 = new Uint8Array(digestOffset + size);\n  encodeTo(code2, bytes2, 0);\n  encodeTo(size, bytes2, sizeOffset);\n  bytes2.set(digest2, digestOffset);\n  return new Digest(code2, size, digest2, bytes2);\n};\nvar decode3 = (multihash) => {\n  const bytes2 = coerce(multihash);\n  const [code2, sizeOffset] = decode2(bytes2);\n  const [size, digestOffset] = decode2(bytes2.subarray(sizeOffset));\n  const digest2 = bytes2.subarray(sizeOffset + digestOffset);\n  if (digest2.byteLength !== size) {\n    throw new Error(\"Incorrect length\");\n  }\n  return new Digest(code2, size, digest2, bytes2);\n};\nvar equals2 = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);\n  }\n};\nvar Digest = class {\n  constructor(code2, size, digest2, bytes2) {\n    this.code = code2;\n    this.size = size;\n    this.digest = digest2;\n    this.bytes = bytes2;\n  }\n};\n\n// ../../node_modules/multiformats/esm/src/bases/base58.js\nvar base58_exports = {};\n__export(base58_exports, {\n  base58btc: () => base58btc,\n  base58flickr: () => base58flickr\n});\n\n// ../../node_modules/multiformats/esm/vendor/base-x.js\nfunction base(ALPHABET, name2) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError(\"Alphabet too long\");\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + \" is ambiguous\");\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode5(source) {\n    if (source instanceof Uint8Array)\n      ;\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n      return \"\";\n    }\n    var zeroes = 0;\n    var length2 = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i2 = 0;\n      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error(\"Non-zero carry\");\n      }\n      length2 = i2;\n      pbegin++;\n    }\n    var it2 = size - length2;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== \"string\") {\n      throw new TypeError(\"Expected String\");\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === \" \") {\n      return;\n    }\n    var zeroes = 0;\n    var length2 = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i2 = 0;\n      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error(\"Non-zero carry\");\n      }\n      length2 = i2;\n      psz++;\n    }\n    if (source[psz] === \" \") {\n      return;\n    }\n    var it4 = size - length2;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j2 = zeroes;\n    while (it4 !== size) {\n      vch[j2++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode6(string3) {\n    var buffer = decodeUnsafe(string3);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${name2} character`);\n  }\n  return {\n    encode: encode5,\n    decodeUnsafe,\n    decode: decode6\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nvar base_x_default = _brrp__multiformats_scope_baseX;\n\n// ../../node_modules/multiformats/esm/src/bases/base.js\nvar Encoder = class {\n  constructor(name2, prefix, baseEncode) {\n    this.name = name2;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes2) {\n    if (bytes2 instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes2)}`;\n    } else {\n      throw Error(\"Unknown type, must be binary type\");\n    }\n  }\n};\nvar Decoder = class {\n  constructor(name2, prefix, baseDecode) {\n    this.name = name2;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === void 0) {\n      throw new Error(\"Invalid prefix character\");\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === \"string\") {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error(\"Can only multibase decode strings\");\n    }\n  }\n  or(decoder2) {\n    return or(this, decoder2);\n  }\n};\nvar ComposedDecoder = class {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder2) {\n    return or(this, decoder2);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder2 = this.decoders[prefix];\n    if (decoder2) {\n      return decoder2.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n};\nvar or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nvar Codec = class {\n  constructor(name2, prefix, baseEncode, baseDecode) {\n    this.name = name2;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name2, prefix, baseEncode);\n    this.decoder = new Decoder(name2, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n};\nvar from = ({ name: name2, prefix, encode: encode5, decode: decode6 }) => new Codec(name2, prefix, encode5, decode6);\nvar baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {\n  const { encode: encode5, decode: decode6 } = base_x_default(alphabet2, name2);\n  return from({\n    prefix,\n    name: name2,\n    encode: encode5,\n    decode: (text) => coerce(decode6(text))\n  });\n};\nvar decode4 = (string3, alphabet2, bitsPerChar, name2) => {\n  const codes = {};\n  for (let i = 0; i < alphabet2.length; ++i) {\n    codes[alphabet2[i]] = i;\n  }\n  let end = string3.length;\n  while (string3[end - 1] === \"=\") {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string3[i]];\n    if (value === void 0) {\n      throw new SyntaxError(`Non-${name2} character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError(\"Unexpected end of data\");\n  }\n  return out;\n};\nvar encode2 = (data, alphabet2, bitsPerChar) => {\n  const pad = alphabet2[alphabet2.length - 1] === \"=\";\n  const mask = (1 << bitsPerChar) - 1;\n  let out = \"\";\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet2[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet2[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += \"=\";\n    }\n  }\n  return out;\n};\nvar rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {\n  return from({\n    prefix,\n    name: name2,\n    encode(input) {\n      return encode2(input, alphabet2, bitsPerChar);\n    },\n    decode(input) {\n      return decode4(input, alphabet2, bitsPerChar, name2);\n    }\n  });\n};\n\n// ../../node_modules/multiformats/esm/src/bases/base58.js\nvar base58btc = baseX({\n  name: \"base58btc\",\n  prefix: \"z\",\n  alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n});\nvar base58flickr = baseX({\n  name: \"base58flickr\",\n  prefix: \"Z\",\n  alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base32.js\nvar base32_exports = {};\n__export(base32_exports, {\n  base32: () => base32,\n  base32hex: () => base32hex,\n  base32hexpad: () => base32hexpad,\n  base32hexpadupper: () => base32hexpadupper,\n  base32hexupper: () => base32hexupper,\n  base32pad: () => base32pad,\n  base32padupper: () => base32padupper,\n  base32upper: () => base32upper,\n  base32z: () => base32z\n});\nvar base32 = rfc4648({\n  prefix: \"b\",\n  name: \"base32\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n  bitsPerChar: 5\n});\nvar base32upper = rfc4648({\n  prefix: \"B\",\n  name: \"base32upper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  bitsPerChar: 5\n});\nvar base32pad = rfc4648({\n  prefix: \"c\",\n  name: \"base32pad\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n  bitsPerChar: 5\n});\nvar base32padupper = rfc4648({\n  prefix: \"C\",\n  name: \"base32padupper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n  bitsPerChar: 5\n});\nvar base32hex = rfc4648({\n  prefix: \"v\",\n  name: \"base32hex\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n  bitsPerChar: 5\n});\nvar base32hexupper = rfc4648({\n  prefix: \"V\",\n  name: \"base32hexupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  bitsPerChar: 5\n});\nvar base32hexpad = rfc4648({\n  prefix: \"t\",\n  name: \"base32hexpad\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n  bitsPerChar: 5\n});\nvar base32hexpadupper = rfc4648({\n  prefix: \"T\",\n  name: \"base32hexpadupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n  bitsPerChar: 5\n});\nvar base32z = rfc4648({\n  prefix: \"h\",\n  name: \"base32z\",\n  alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n  bitsPerChar: 5\n});\n\n// ../../node_modules/multiformats/esm/src/cid.js\nvar CID = class {\n  constructor(version2, code2, multihash, bytes2) {\n    this.code = code2;\n    this.version = version2;\n    this.multihash = multihash;\n    this.bytes = bytes2;\n    this.byteOffset = bytes2.byteOffset;\n    this.byteLength = bytes2.byteLength;\n    this.asCID = this;\n    this._baseCache = /* @__PURE__ */ new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n      case 0: {\n        return this;\n      }\n      default: {\n        const { code: code2, multihash } = this;\n        if (code2 !== DAG_PB_CODE) {\n          throw new Error(\"Cannot convert a non dag-pb CID to CIDv0\");\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error(\"Cannot convert non sha2-256 multihash CID to CIDv0\");\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n      case 0: {\n        const { code: code2, digest: digest2 } = this.multihash;\n        const multihash = create(code2, digest2);\n        return CID.createV1(this.code, multihash);\n      }\n      case 1: {\n        return this;\n      }\n      default: {\n        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);\n  }\n  toString(base3) {\n    const { bytes: bytes2, version: version2, _baseCache } = this;\n    switch (version2) {\n      case 0:\n        return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);\n      default:\n        return toStringV1(bytes2, _baseCache, base3 || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"CID\";\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return \"CID(\" + this.toString() + \")\";\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error(\"Deprecated, use .toString()\");\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error(\"Deprecated .buffer property, use .bytes to get Uint8Array instead\");\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;\n      return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const { version: version2, multihash, code: code2 } = value;\n      const digest2 = decode3(multihash);\n      return CID.create(version2, code2, digest2);\n    } else {\n      return null;\n    }\n  }\n  static create(version2, code2, digest2) {\n    if (typeof code2 !== \"number\") {\n      throw new Error(\"String codecs are no longer supported\");\n    }\n    switch (version2) {\n      case 0: {\n        if (code2 !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n        } else {\n          return new CID(version2, code2, digest2, digest2.bytes);\n        }\n      }\n      case 1: {\n        const bytes2 = encodeCID(version2, code2, digest2.bytes);\n        return new CID(version2, code2, digest2, bytes2);\n      }\n      default: {\n        throw new Error(\"Invalid version\");\n      }\n    }\n  }\n  static createV0(digest2) {\n    return CID.create(0, DAG_PB_CODE, digest2);\n  }\n  static createV1(code2, digest2) {\n    return CID.create(1, code2, digest2);\n  }\n  static decode(bytes2) {\n    const [cid2, remainder] = CID.decodeFirst(bytes2);\n    if (remainder.length) {\n      throw new Error(\"Incorrect length\");\n    }\n    return cid2;\n  }\n  static decodeFirst(bytes2) {\n    const specs = CID.inspectBytes(bytes2);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error(\"Incorrect length\");\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid2 = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);\n    return [\n      cid2,\n      bytes2.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length2] = decode2(initialBytes.subarray(offset));\n      offset += length2;\n      return i;\n    };\n    let version2 = next();\n    let codec = DAG_PB_CODE;\n    if (version2 === 18) {\n      version2 = 0;\n      offset = 0;\n    } else if (version2 === 1) {\n      codec = next();\n    }\n    if (version2 !== 0 && version2 !== 1) {\n      throw new RangeError(`Invalid CID version ${version2}`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version: version2,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base3) {\n    const [prefix, bytes2] = parseCIDtoBytes(source, base3);\n    const cid2 = CID.decode(bytes2);\n    cid2._baseCache.set(prefix, source);\n    return cid2;\n  }\n};\nvar parseCIDtoBytes = (source, base3) => {\n  switch (source[0]) {\n    case \"Q\": {\n      const decoder2 = base3 || base58btc;\n      return [\n        base58btc.prefix,\n        decoder2.decode(`${base58btc.prefix}${source}`)\n      ];\n    }\n    case base58btc.prefix: {\n      const decoder2 = base3 || base58btc;\n      return [\n        base58btc.prefix,\n        decoder2.decode(source)\n      ];\n    }\n    case base32.prefix: {\n      const decoder2 = base3 || base32;\n      return [\n        base32.prefix,\n        decoder2.decode(source)\n      ];\n    }\n    default: {\n      if (base3 == null) {\n        throw Error(\"To parse non base32 or base58btc encoded CID multibase decoder must be provided\");\n      }\n      return [\n        source[0],\n        base3.decode(source)\n      ];\n    }\n  }\n};\nvar toStringV0 = (bytes2, cache, base3) => {\n  const { prefix } = base3;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);\n  }\n  const cid2 = cache.get(prefix);\n  if (cid2 == null) {\n    const cid3 = base3.encode(bytes2).slice(1);\n    cache.set(prefix, cid3);\n    return cid3;\n  } else {\n    return cid2;\n  }\n};\nvar toStringV1 = (bytes2, cache, base3) => {\n  const { prefix } = base3;\n  const cid2 = cache.get(prefix);\n  if (cid2 == null) {\n    const cid3 = base3.encode(bytes2);\n    cache.set(prefix, cid3);\n    return cid3;\n  } else {\n    return cid2;\n  }\n};\nvar DAG_PB_CODE = 112;\nvar SHA_256_CODE = 18;\nvar encodeCID = (version2, code2, multihash) => {\n  const codeOffset = encodingLength(version2);\n  const hashOffset = codeOffset + encodingLength(code2);\n  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);\n  encodeTo(version2, bytes2, 0);\n  encodeTo(code2, bytes2, codeOffset);\n  bytes2.set(multihash, hashOffset);\n  return bytes2;\n};\nvar cidSymbol = Symbol.for(\"@ipld/js-cid/CID\");\nvar readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nvar hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nvar version = \"0.0.0-dev\";\nvar deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nvar IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;\n\n// ../../node_modules/multiformats/esm/src/bases/identity.js\nvar identity_exports = {};\n__export(identity_exports, {\n  identity: () => identity\n});\nvar identity = from({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base2.js\nvar base2_exports = {};\n__export(base2_exports, {\n  base2: () => base2\n});\nvar base2 = rfc4648({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base8.js\nvar base8_exports = {};\n__export(base8_exports, {\n  base8: () => base8\n});\nvar base8 = rfc4648({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base10.js\nvar base10_exports = {};\n__export(base10_exports, {\n  base10: () => base10\n});\nvar base10 = baseX({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base16.js\nvar base16_exports = {};\n__export(base16_exports, {\n  base16: () => base16,\n  base16upper: () => base16upper\n});\nvar base16 = rfc4648({\n  prefix: \"f\",\n  name: \"base16\",\n  alphabet: \"0123456789abcdef\",\n  bitsPerChar: 4\n});\nvar base16upper = rfc4648({\n  prefix: \"F\",\n  name: \"base16upper\",\n  alphabet: \"0123456789ABCDEF\",\n  bitsPerChar: 4\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base36.js\nvar base36_exports = {};\n__export(base36_exports, {\n  base36: () => base36,\n  base36upper: () => base36upper\n});\nvar base36 = baseX({\n  prefix: \"k\",\n  name: \"base36\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n});\nvar base36upper = baseX({\n  prefix: \"K\",\n  name: \"base36upper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base64.js\nvar base64_exports = {};\n__export(base64_exports, {\n  base64: () => base64,\n  base64pad: () => base64pad,\n  base64url: () => base64url,\n  base64urlpad: () => base64urlpad\n});\nvar base64 = rfc4648({\n  prefix: \"m\",\n  name: \"base64\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  bitsPerChar: 6\n});\nvar base64pad = rfc4648({\n  prefix: \"M\",\n  name: \"base64pad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  bitsPerChar: 6\n});\nvar base64url = rfc4648({\n  prefix: \"u\",\n  name: \"base64url\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n  bitsPerChar: 6\n});\nvar base64urlpad = rfc4648({\n  prefix: \"U\",\n  name: \"base64urlpad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n  bitsPerChar: 6\n});\n\n// ../../node_modules/multiformats/esm/src/bases/base256emoji.js\nvar base256emoji_exports = {};\n__export(base256emoji_exports, {\n  base256emoji: () => base256emoji\n});\nvar alphabet = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\");\nvar alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nvar alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode3(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, \"\");\n}\nfunction decode5(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === void 0) {\n      throw new Error(`Non-base256emoji character: ${char}`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nvar base256emoji = from({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: encode3,\n  decode: decode5\n});\n\n// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js\nvar sha2_browser_exports = {};\n__export(sha2_browser_exports, {\n  sha256: () => sha256,\n  sha512: () => sha512\n});\n\n// ../../node_modules/multiformats/esm/src/hashes/hasher.js\nvar from2 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);\nvar Hasher = class {\n  constructor(name2, code2, encode5) {\n    this.name = name2;\n    this.code = code2;\n    this.encode = encode5;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));\n    } else {\n      throw Error(\"Unknown type, must be binary type\");\n    }\n  }\n};\n\n// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js\nvar sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));\nvar sha256 = from2({\n  name: \"sha2-256\",\n  code: 18,\n  encode: sha(\"SHA-256\")\n});\nvar sha512 = from2({\n  name: \"sha2-512\",\n  code: 19,\n  encode: sha(\"SHA-512\")\n});\n\n// ../../node_modules/multiformats/esm/src/hashes/identity.js\nvar identity_exports2 = {};\n__export(identity_exports2, {\n  identity: () => identity2\n});\nvar code = 0;\nvar name = \"identity\";\nvar encode4 = coerce;\nvar digest = (input) => create(code, encode4(input));\nvar identity2 = {\n  code,\n  name,\n  encode: encode4,\n  digest\n};\n\n// ../../node_modules/multiformats/esm/src/codecs/json.js\nvar textEncoder = new TextEncoder();\nvar textDecoder = new TextDecoder();\n\n// ../../node_modules/multiformats/esm/src/basics.js\nvar bases = {\n  ...identity_exports,\n  ...base2_exports,\n  ...base8_exports,\n  ...base10_exports,\n  ...base16_exports,\n  ...base32_exports,\n  ...base36_exports,\n  ...base58_exports,\n  ...base64_exports,\n  ...base256emoji_exports\n};\nvar hashes = {\n  ...sha2_browser_exports,\n  ...identity_exports2\n};\n\n// ../../node_modules/uint8arrays/esm/src/util/bases.js\nfunction createCodec(name2, prefix, encode5, decode6) {\n  return {\n    name: name2,\n    prefix,\n    encoder: {\n      name: name2,\n      prefix,\n      encode: encode5\n    },\n    decoder: { decode: decode6 }\n  };\n}\nvar string = createCodec(\"utf8\", \"u\", (buf) => {\n  const decoder2 = new TextDecoder(\"utf8\");\n  return \"u\" + decoder2.decode(buf);\n}, (str) => {\n  const encoder2 = new TextEncoder();\n  return encoder2.encode(str.substring(1));\n});\nvar ascii = createCodec(\"ascii\", \"a\", (buf) => {\n  let string3 = \"a\";\n  for (let i = 0; i < buf.length; i++) {\n    string3 += String.fromCharCode(buf[i]);\n  }\n  return string3;\n}, (str) => {\n  str = str.substring(1);\n  const buf = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nvar BASES = {\n  utf8: string,\n  \"utf-8\": string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n  ...bases\n};\nvar bases_default = BASES;\n\n// ../../node_modules/uint8arrays/esm/src/from-string.js\nfunction fromString2(string3, encoding = \"utf8\") {\n  const base3 = bases_default[encoding];\n  if (!base3) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`);\n  }\n  return base3.decoder.decode(`${base3.prefix}${string3}`);\n}\n\n// ../../node_modules/uint8arrays/esm/src/to-string.js\nfunction toString2(array2, encoding = \"utf8\") {\n  const base3 = bases_default[encoding];\n  if (!base3) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`);\n  }\n  return base3.encoder.encode(array2).substring(1);\n}\n\n// ../common-web/src/ipld.ts\nvar jsonToIpld = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => jsonToIpld(item));\n  }\n  if (val && typeof val === \"object\") {\n    if (typeof val[\"$link\"] === \"string\" && Object.keys(val).length === 1) {\n      return CID.parse(val[\"$link\"]);\n    }\n    if (typeof val[\"$bytes\"] === \"string\" && Object.keys(val).length === 1) {\n      return fromString2(val[\"$bytes\"], \"base64\");\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = jsonToIpld(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\nvar ipldToJson = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => ipldToJson(item));\n  }\n  if (val && typeof val === \"object\") {\n    if (val instanceof Uint8Array) {\n      return {\n        $bytes: toString2(val, \"base64\")\n      };\n    }\n    if (CID.asCID(val)) {\n      return {\n        $link: val.toString()\n      };\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = ipldToJson(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\n\n// ../../node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n  util2.assertEqual = (val) => val;\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object2) => {\n    const keys = [];\n    for (const key in object2) {\n      if (Object.prototype.hasOwnProperty.call(object2, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n  function joinValues(array2, separator = \" | \") {\n    return array2.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\nvar ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class extends Error {\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  get errors() {\n    return this.issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n        fieldErrors[sub.path[0]].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\nvar errorMap = (issue, _ctx) => {\n  let message;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"startsWith\" in issue.validation) {\n          message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be greater than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.minimum)}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be smaller than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.maximum)}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar makeIssue = (params2) => {\n  const { data, path, errorMaps, issueData } = params2;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: issueData.message || errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      getErrorMap(),\n      errorMap\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\")\n      this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\")\n      this.value = \"aborted\";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      if (s.status === \"dirty\")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      syncPairs.push({\n        key: await pair.key,\n        value: await pair.value\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\")\n        return INVALID;\n      if (value.status === \"aborted\")\n        return INVALID;\n      if (key.status === \"dirty\")\n        status.dirty();\n      if (value.status === \"dirty\")\n        status.dirty();\n      if (typeof value.value !== \"undefined\" || pair.alwaysSet) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n};\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = (value) => ({ status: \"dirty\", value });\nvar OK = (value) => ({ status: \"valid\", value });\nvar isAborted = (x) => x.status === \"aborted\";\nvar isDirty = (x) => x.status === \"dirty\";\nvar isValid = (x) => x.status === \"valid\";\nvar isAsync = (x) => typeof Promise !== void 0 && x instanceof Promise;\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path, key) {\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    return this._path.concat(this._key);\n  }\n};\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    const error = new ZodError(ctx.common.issues);\n    return { success: false, error };\n  }\n};\nfunction processCreateParams(params2) {\n  if (!params2)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    if (typeof ctx.data === \"undefined\") {\n      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n    }\n    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\nvar ZodType = class {\n  constructor(def2) {\n    this.spa = this.safeParseAsync;\n    this.superRefine = this._refinement;\n    this._def = def2;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.default = this.default.bind(this);\n    this.describe = this.describe.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n  }\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params2) {\n    const result = this.safeParse(data, params2);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params2) {\n    var _a;\n    const ctx = {\n      common: {\n        issues: [],\n        async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,\n        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap\n      },\n      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  async parseAsync(data, params2) {\n    const result = await this.safeParseAsync(data, params2);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params2) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,\n        async: true\n      },\n      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  optional() {\n    return ZodOptional.create(this);\n  }\n  nullable() {\n    return ZodNullable.create(this);\n  }\n  nullish() {\n    return this.optional().nullable();\n  }\n  array() {\n    return ZodArray.create(this);\n  }\n  promise() {\n    return ZodPromise.create(this);\n  }\n  or(option) {\n    return ZodUnion.create([this, option]);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def2) {\n    const defaultValueFunc = typeof def2 === \"function\" ? def2 : () => def2;\n    return new ZodDefault({\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(void 0)\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nvar emailRegex = /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\nvar ZodString = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n    this.trim = () => new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(\n        ctx2,\n        {\n          code: ZodIssueCode.invalid_type,\n          expected: ZodParsedType.string,\n          received: ctx2.parsedType\n        }\n      );\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch (_a) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"startsWith\") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _addCheck(check) {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this.min(len, message).max(len, message);\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodString.create = (params2) => {\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    ...processCreateParams(params2)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\");\n  }\n};\nZodNumber.create = (params2) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodBigInt = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.bigint,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBigInt.create = (params2) => {\n  return new ZodBigInt({\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params2) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodDate = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            minimum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            maximum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n};\nZodDate.create = (params2) => {\n  return new ZodDate({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params2) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params2) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params2) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params2) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = (params2) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params2) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodArray = class extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def2 = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def2.minLength !== null) {\n      if (ctx.data.length < def2.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def2.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          message: def2.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def2.maxLength !== null) {\n      if (ctx.data.length > def2.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def2.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          message: def2.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all(ctx.data.map((item, i) => {\n        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = ctx.data.map((item, i) => {\n      return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return this.min(len, message).max(len, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodArray.create = (schema2, params2) => {\n  return new ZodArray({\n    type: schema2,\n    minLength: null,\n    maxLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params2)\n  });\n};\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar AugmentFactory = (def2) => (augmentation) => {\n  return new ZodObject({\n    ...def2,\n    shape: () => ({\n      ...def2.shape(),\n      ...augmentation\n    })\n  });\n};\nfunction deepPartialify(schema2) {\n  if (schema2 instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema2.shape) {\n      const fieldSchema = schema2.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema2._def,\n      shape: () => newShape\n    });\n  } else if (schema2 instanceof ZodArray) {\n    return ZodArray.create(deepPartialify(schema2.element));\n  } else if (schema2 instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema2.unwrap()));\n  } else if (schema2 instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema2.unwrap()));\n  } else if (schema2 instanceof ZodTuple) {\n    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema2;\n  }\n}\nvar ZodObject = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = AugmentFactory(this._def);\n    this.extend = AugmentFactory(this._def);\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    return this._cached = { shape, keys };\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\")\n        ;\n      else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          syncPairs.push({\n            key,\n            value: await pair.value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          var _a, _b, _c, _d;\n          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n          if (issue.code === \"unrecognized_keys\")\n            return {\n              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  setKey(key, schema2) {\n    return this.augment({ [key]: schema2 });\n  }\n  merge(merging) {\n    const merged = new ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  catchall(index) {\n    return new ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    util.objectKeys(mask).map((key) => {\n      if (this.shape[key])\n        shape[key] = this.shape[key];\n    });\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    util.objectKeys(this.shape).map((key) => {\n      if (util.objectKeys(mask).indexOf(key) === -1) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    if (mask) {\n      util.objectKeys(this.shape).map((key) => {\n        if (util.objectKeys(mask).indexOf(key) === -1) {\n          newShape[key] = this.shape[key];\n        } else {\n          newShape[key] = this.shape[key].optional();\n        }\n      });\n      return new ZodObject({\n        ...this._def,\n        shape: () => newShape\n      });\n    } else {\n      for (const key in this.shape) {\n        const fieldSchema = this.shape[key];\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required() {\n    const newShape = {};\n    for (const key in this.shape) {\n      const fieldSchema = this.shape[key];\n      let newField = fieldSchema;\n      while (newField instanceof ZodOptional) {\n        newField = newField._def.innerType;\n      }\n      newShape[key] = newField;\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params2) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params2)\n  });\n};\nZodObject.strictCreate = (shape, params2) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params2)\n  });\n};\nZodObject.lazycreate = (shape, params2) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params2) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodDiscriminatedUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.options.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: this.validDiscriminatorValues,\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get validDiscriminatorValues() {\n    return Array.from(this.options.keys());\n  }\n  get options() {\n    return this._def.options;\n  }\n  static create(discriminator, types, params2) {\n    const options = /* @__PURE__ */ new Map();\n    try {\n      types.forEach((type) => {\n        const discriminatorValue = type.shape[discriminator].value;\n        options.set(discriminatorValue, type);\n      });\n    } catch (e) {\n      throw new Error(\"The discriminator value could not be extracted from all the provided schemas\");\n    }\n    if (options.size !== types.length) {\n      throw new Error(\"Some of the discriminator values are not unique\");\n    }\n    return new ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      ...processCreateParams(params2)\n    });\n  }\n};\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params2) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodTuple = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = ctx.data.map((item, itemIndex) => {\n      const schema2 = this._def.items[itemIndex] || this._def.rest;\n      if (!schema2)\n        return null;\n      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x) => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas2, params2) => {\n  if (!Array.isArray(schemas2)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas2,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodRecord = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params2) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodSet = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def2 = this._def;\n    if (def2.minSize !== null) {\n      if (ctx.data.size < def2.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def2.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          message: def2.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def2.maxSize !== null) {\n      if (ctx.data.size > def2.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def2.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          message: def2.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        if (element.status === \"dirty\")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodSet.create = (valueType, params2) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodFunction = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params2 = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      return OK(async (...args) => {\n        const error = new ZodError([]);\n        const parsedArgs = await this._def.args.parseAsync(args, params2).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await fn(...parsedArgs);\n        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params2).catch((e) => {\n          error.addIssue(makeReturnsIssue(result, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      return OK((...args) => {\n        const parsedArgs = this._def.args.safeParse(args, params2);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = fn(...parsedArgs.data);\n        const parsedReturns = this._def.returns.safeParse(result, params2);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params2) {\n    return new ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params2)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params2) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params2) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params2)\n  });\n};\nfunction createZodEnum(values, params2) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params2)\n  });\n}\nvar ZodEnum = class extends ZodType {\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (this._def.values.indexOf(input.data) === -1) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n};\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (nativeEnumValues.indexOf(input.data) === -1) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nZodNativeEnum.create = (values, params2) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema2, params2) => {\n  return new ZodPromise({\n    type: schema2,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then((processed2) => {\n          return this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n        });\n      } else {\n        return this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\")\n          return INVALID;\n        if (inner.status === \"dirty\")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\")\n            return INVALID;\n          if (inner.status === \"dirty\")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base3 = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base3))\n          return base3;\n        const result = effect.transform(base3.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {\n          if (!isValid(base3))\n            return base3;\n          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema2, effect, params2) => {\n  return new ZodEffects({\n    schema: schema2,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params2)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema2, params2) => {\n  return new ZodEffects({\n    schema: schema2,\n    effect: { type: \"preprocess\", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type, params2) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type, params2) => {\n  return new ZodNullable({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type, params2) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params2)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n};\nZodNaN.create = (params2) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params2)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar custom = (check, params2 = {}, fatal) => {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      if (!check(data)) {\n        const p = typeof params2 === \"function\" ? params2(data) : params2;\n        const p2 = typeof p === \"string\" ? { message: p } : p;\n        ctx.addIssue({ code: \"custom\", ...p2, fatal });\n      }\n    });\n  return ZodAny.create();\n};\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params2 = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params2, true);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar NEVER = INVALID;\nvar mod = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  getParsedType,\n  ZodParsedType,\n  defaultErrorMap: errorMap,\n  setErrorMap,\n  getErrorMap,\n  makeIssue,\n  EMPTY_PATH,\n  addIssueToContext,\n  ParseStatus,\n  INVALID,\n  DIRTY,\n  OK,\n  isAborted,\n  isDirty,\n  isValid,\n  isAsync,\n  ZodType,\n  ZodString,\n  ZodNumber,\n  ZodBigInt,\n  ZodBoolean,\n  ZodDate,\n  ZodUndefined,\n  ZodNull,\n  ZodAny,\n  ZodUnknown,\n  ZodNever,\n  ZodVoid,\n  ZodArray,\n  get objectUtil() {\n    return objectUtil;\n  },\n  ZodObject,\n  ZodUnion,\n  ZodDiscriminatedUnion,\n  ZodIntersection,\n  ZodTuple,\n  ZodRecord,\n  ZodMap,\n  ZodSet,\n  ZodFunction,\n  ZodLazy,\n  ZodLiteral,\n  ZodEnum,\n  ZodNativeEnum,\n  ZodPromise,\n  ZodEffects,\n  ZodTransformer: ZodEffects,\n  ZodOptional,\n  ZodNullable,\n  ZodDefault,\n  ZodNaN,\n  BRAND,\n  ZodBranded,\n  custom,\n  Schema: ZodType,\n  ZodSchema: ZodType,\n  late,\n  get ZodFirstPartyTypeKind() {\n    return ZodFirstPartyTypeKind;\n  },\n  any: anyType,\n  array: arrayType,\n  bigint: bigIntType,\n  boolean: booleanType,\n  date: dateType,\n  discriminatedUnion: discriminatedUnionType,\n  effect: effectsType,\n  \"enum\": enumType,\n  \"function\": functionType,\n  \"instanceof\": instanceOfType,\n  intersection: intersectionType,\n  lazy: lazyType,\n  literal: literalType,\n  map: mapType,\n  nan: nanType,\n  nativeEnum: nativeEnumType,\n  never: neverType,\n  \"null\": nullType,\n  nullable: nullableType,\n  number: numberType,\n  object: objectType,\n  oboolean,\n  onumber,\n  optional: optionalType,\n  ostring,\n  preprocess: preprocessType,\n  promise: promiseType,\n  record: recordType,\n  set: setType,\n  strictObject: strictObjectType,\n  string: stringType,\n  transformer: effectsType,\n  tuple: tupleType,\n  \"undefined\": undefinedType,\n  union: unionType,\n  unknown: unknownType,\n  \"void\": voidType,\n  NEVER,\n  ZodIssueCode,\n  quotelessJson,\n  ZodError\n});\n\n// ../common-web/src/types.ts\nvar cidSchema = mod.any().refine((obj) => CID.asCID(obj) !== null, {\n  message: \"Not a CID\"\n}).transform((obj) => CID.asCID(obj));\nvar schema = {\n  cid: cidSchema,\n  bytes: mod.instanceof(Uint8Array),\n  string: mod.string(),\n  array: mod.array(mod.unknown()),\n  map: mod.record(mod.string(), mod.unknown()),\n  unknown: mod.unknown()\n};\nvar def = {\n  cid: {\n    name: \"cid\",\n    schema: schema.cid\n  },\n  bytes: {\n    name: \"bytes\",\n    schema: schema.bytes\n  },\n  string: {\n    name: \"string\",\n    schema: schema.string\n  },\n  map: {\n    name: \"map\",\n    schema: schema.map\n  },\n  unknown: {\n    name: \"unknown\",\n    schema: schema.unknown\n  }\n};\n\n// ../common-web/src/times.ts\nvar SECOND = 1e3;\nvar MINUTE = SECOND * 60;\nvar HOUR = MINUTE * 60;\nvar DAY = HOUR * 24;\n\n// ../common-web/src/strings.ts\nvar utf8Len = (str) => {\n  return new TextEncoder().encode(str).byteLength;\n};\nvar graphemeLen = (str) => {\n  return [...new Intl.Segmenter().segment(str)].length;\n};\n\n// ../identifier/src/reserved.ts\nvar atpSpecific = [\n  \"at\",\n  \"atp\",\n  \"plc\",\n  \"pds\",\n  \"did\",\n  \"repo\",\n  \"tid\",\n  \"nsid\",\n  \"xrpc\",\n  \"lex\",\n  \"lexicon\",\n  \"bsky\",\n  \"bluesky\",\n  \"handle\"\n];\nvar commonlyReserved = [\n  \"about\",\n  \"abuse\",\n  \"access\",\n  \"account\",\n  \"accounts\",\n  \"acme\",\n  \"activate\",\n  \"activities\",\n  \"activity\",\n  \"ad\",\n  \"add\",\n  \"address\",\n  \"adm\",\n  \"admanager\",\n  \"admin\",\n  \"administration\",\n  \"administrator\",\n  \"administrators\",\n  \"admins\",\n  \"ads\",\n  \"adsense\",\n  \"adult\",\n  \"advertising\",\n  \"adwords\",\n  \"affiliate\",\n  \"affiliatepage\",\n  \"affiliates\",\n  \"afp\",\n  \"ajax\",\n  \"all\",\n  \"alpha\",\n  \"analysis\",\n  \"analytics\",\n  \"android\",\n  \"anon\",\n  \"anonymous\",\n  \"answer\",\n  \"answers\",\n  \"ap\",\n  \"api\",\n  \"apis\",\n  \"app\",\n  \"appengine\",\n  \"appnews\",\n  \"apps\",\n  \"archive\",\n  \"archives\",\n  \"article\",\n  \"asdf\",\n  \"asset\",\n  \"assets\",\n  \"auth\",\n  \"authentication\",\n  \"avatar\",\n  \"backup\",\n  \"bank\",\n  \"banner\",\n  \"banners\",\n  \"base\",\n  \"beginners\",\n  \"beta\",\n  \"billing\",\n  \"bin\",\n  \"binaries\",\n  \"binary\",\n  \"blackberry\",\n  \"blog\",\n  \"blogs\",\n  \"blogsearch\",\n  \"board\",\n  \"book\",\n  \"bookmark\",\n  \"bookmarks\",\n  \"books\",\n  \"bot\",\n  \"bots\",\n  \"bug\",\n  \"bugs\",\n  \"business\",\n  \"buy\",\n  \"buzz\",\n  \"cache\",\n  \"calendar\",\n  \"call\",\n  \"campaign\",\n  \"cancel\",\n  \"captcha\",\n  \"career\",\n  \"careers\",\n  \"cart\",\n  \"catalog\",\n  \"catalogs\",\n  \"categories\",\n  \"category\",\n  \"cdn\",\n  \"cgi\",\n  \"cgi-bin\",\n  \"changelog\",\n  \"chart\",\n  \"charts\",\n  \"chat\",\n  \"check\",\n  \"checked\",\n  \"checking\",\n  \"checkout\",\n  \"client\",\n  \"cliente\",\n  \"clients\",\n  \"clients1\",\n  \"cnarne\",\n  \"code\",\n  \"comercial\",\n  \"comment\",\n  \"comments\",\n  \"communities\",\n  \"community\",\n  \"company\",\n  \"compare\",\n  \"compras\",\n  \"config\",\n  \"configuration\",\n  \"confirm\",\n  \"confirmation\",\n  \"connect\",\n  \"contact\",\n  \"contacts\",\n  \"contactus\",\n  \"contact-us\",\n  \"contact_us\",\n  \"content\",\n  \"contest\",\n  \"contribute\",\n  \"contributor\",\n  \"contributors\",\n  \"coppa\",\n  \"copyright\",\n  \"copyrights\",\n  \"core\",\n  \"corp\",\n  \"countries\",\n  \"country\",\n  \"cpanel\",\n  \"create\",\n  \"css\",\n  \"cssproxy\",\n  \"customise\",\n  \"customize\",\n  \"dashboard\",\n  \"data\",\n  \"db\",\n  \"default\",\n  \"delete\",\n  \"demo\",\n  \"design\",\n  \"designer\",\n  \"desktop\",\n  \"destroy\",\n  \"dev\",\n  \"devel\",\n  \"developer\",\n  \"developers\",\n  \"devs\",\n  \"diagram\",\n  \"diary\",\n  \"dict\",\n  \"dictionary\",\n  \"die\",\n  \"dir\",\n  \"directory\",\n  \"direct_messages\",\n  \"direct-messages\",\n  \"dist\",\n  \"diversity\",\n  \"dl\",\n  \"dmca\",\n  \"doc\",\n  \"docs\",\n  \"documentation\",\n  \"documentations\",\n  \"documents\",\n  \"domain\",\n  \"domains\",\n  \"donate\",\n  \"download\",\n  \"downloads\",\n  \"e\",\n  \"e-mail\",\n  \"earth\",\n  \"ecommerce\",\n  \"edit\",\n  \"edits\",\n  \"editor\",\n  \"edu\",\n  \"education\",\n  \"email\",\n  \"embed\",\n  \"embedded\",\n  \"employment\",\n  \"employments\",\n  \"empty\",\n  \"enable\",\n  \"encrypted\",\n  \"end\",\n  \"engine\",\n  \"enterprise\",\n  \"enterprises\",\n  \"entries\",\n  \"entry\",\n  \"error\",\n  \"errorlog\",\n  \"errors\",\n  \"eval\",\n  \"event\",\n  \"example\",\n  \"examplecommunity\",\n  \"exampleopenid\",\n  \"examplesyn\",\n  \"examplesyndicated\",\n  \"exampleusername\",\n  \"exchange\",\n  \"exit\",\n  \"explore\",\n  \"faq\",\n  \"faqs\",\n  \"favorite\",\n  \"favorites\",\n  \"favourite\",\n  \"favourites\",\n  \"feature\",\n  \"features\",\n  \"feed\",\n  \"feedback\",\n  \"feedburner\",\n  \"feedproxy\",\n  \"feeds\",\n  \"file\",\n  \"files\",\n  \"finance\",\n  \"folder\",\n  \"folders\",\n  \"first\",\n  \"following\",\n  \"forgot\",\n  \"form\",\n  \"forms\",\n  \"forum\",\n  \"forums\",\n  \"founder\",\n  \"free\",\n  \"friend\",\n  \"friends\",\n  \"ftp\",\n  \"fuck\",\n  \"fun\",\n  \"fusion\",\n  \"gadget\",\n  \"gadgets\",\n  \"game\",\n  \"games\",\n  \"gears\",\n  \"general\",\n  \"geographic\",\n  \"get\",\n  \"gettingstarted\",\n  \"gift\",\n  \"gifts\",\n  \"gist\",\n  \"git\",\n  \"github\",\n  \"gmail\",\n  \"go\",\n  \"golang\",\n  \"goto\",\n  \"gov\",\n  \"graph\",\n  \"graphs\",\n  \"group\",\n  \"groups\",\n  \"guest\",\n  \"guests\",\n  \"guide\",\n  \"guides\",\n  \"hack\",\n  \"hacks\",\n  \"head\",\n  \"help\",\n  \"home\",\n  \"homepage\",\n  \"host\",\n  \"hosting\",\n  \"hostmaster\",\n  \"hostname\",\n  \"howto\",\n  \"how-to\",\n  \"how_to\",\n  \"html\",\n  \"htrnl\",\n  \"http\",\n  \"httpd\",\n  \"https\",\n  \"i\",\n  \"iamges\",\n  \"icon\",\n  \"icons\",\n  \"id\",\n  \"idea\",\n  \"ideas\",\n  \"im\",\n  \"image\",\n  \"images\",\n  \"img\",\n  \"imap\",\n  \"inbox\",\n  \"inboxes\",\n  \"index\",\n  \"indexes\",\n  \"info\",\n  \"information\",\n  \"inquiry\",\n  \"intranet\",\n  \"investor\",\n  \"investors\",\n  \"invitation\",\n  \"invitations\",\n  \"invite\",\n  \"invoice\",\n  \"invoices\",\n  \"imac\",\n  \"ios\",\n  \"ipad\",\n  \"iphone\",\n  \"irc\",\n  \"irnages\",\n  \"irng\",\n  \"is\",\n  \"issue\",\n  \"issues\",\n  \"it\",\n  \"item\",\n  \"items\",\n  \"java\",\n  \"javascript\",\n  \"job\",\n  \"jobs\",\n  \"join\",\n  \"js\",\n  \"json\",\n  \"jump\",\n  \"kb\",\n  \"knowledge-base\",\n  \"knowledgebase\",\n  \"lab\",\n  \"labs\",\n  \"language\",\n  \"languages\",\n  \"last\",\n  \"ldap_status\",\n  \"ldap-status\",\n  \"ldapstatus\",\n  \"legal\",\n  \"license\",\n  \"licenses\",\n  \"link\",\n  \"links\",\n  \"linux\",\n  \"list\",\n  \"lists\",\n  \"livejournal\",\n  \"lj\",\n  \"local\",\n  \"locale\",\n  \"location\",\n  \"log\",\n  \"log-in\",\n  \"log-out\",\n  \"login\",\n  \"logout\",\n  \"logs\",\n  \"log_in\",\n  \"log_out\",\n  \"m\",\n  \"mac\",\n  \"macos\",\n  \"macosx\",\n  \"mac-os\",\n  \"mac-os-x\",\n  \"mac_os_x\",\n  \"mail\",\n  \"mailer\",\n  \"mailing\",\n  \"main\",\n  \"maintenance\",\n  \"manage\",\n  \"manager\",\n  \"manual\",\n  \"map\",\n  \"maps\",\n  \"marketing\",\n  \"master\",\n  \"me\",\n  \"media\",\n  \"member\",\n  \"members\",\n  \"memories\",\n  \"memory\",\n  \"merchandise\",\n  \"message\",\n  \"messages\",\n  \"messenger\",\n  \"mg\",\n  \"microblog\",\n  \"microblogs\",\n  \"mine\",\n  \"mis\",\n  \"misc\",\n  \"mms\",\n  \"mob\",\n  \"mobile\",\n  \"model\",\n  \"models\",\n  \"money\",\n  \"movie\",\n  \"movies\",\n  \"mp3\",\n  \"mp4\",\n  \"msg\",\n  \"msn\",\n  \"music\",\n  \"mx\",\n  \"my\",\n  \"mymme\",\n  \"mysql\",\n  \"name\",\n  \"named\",\n  \"nan\",\n  \"navi\",\n  \"navigation\",\n  \"net\",\n  \"network\",\n  \"networks\",\n  \"new\",\n  \"news\",\n  \"newsletter\",\n  \"nick\",\n  \"nickname\",\n  \"nil\",\n  \"none\",\n  \"notes\",\n  \"noticias\",\n  \"notification\",\n  \"notifications\",\n  \"notify\",\n  \"ns\",\n  \"ns1\",\n  \"ns2\",\n  \"ns3\",\n  \"ns4\",\n  \"ns5\",\n  \"null\",\n  \"oauth\",\n  \"oauth-clients\",\n  \"oauth_clients\",\n  \"ocsp\",\n  \"offer\",\n  \"offers\",\n  \"official\",\n  \"old\",\n  \"online\",\n  \"openid\",\n  \"operator\",\n  \"option\",\n  \"options\",\n  \"order\",\n  \"orders\",\n  \"org\",\n  \"organization\",\n  \"organizations\",\n  \"other\",\n  \"overview\",\n  \"owner\",\n  \"owners\",\n  \"p0rn\",\n  \"pack\",\n  \"page\",\n  \"pager\",\n  \"pages\",\n  \"paid\",\n  \"panel\",\n  \"partner\",\n  \"partnerpage\",\n  \"partners\",\n  \"password\",\n  \"patch\",\n  \"pay\",\n  \"payment\",\n  \"people\",\n  \"perl\",\n  \"person\",\n  \"phone\",\n  \"photo\",\n  \"photoalbum\",\n  \"photos\",\n  \"php\",\n  \"phpmyadmin\",\n  \"phppgadmin\",\n  \"phpredisadmin\",\n  \"pic\",\n  \"pics\",\n  \"picture\",\n  \"pictures\",\n  \"ping\",\n  \"pixel\",\n  \"places\",\n  \"plan\",\n  \"plans\",\n  \"plugin\",\n  \"plugins\",\n  \"podcasts\",\n  \"policies\",\n  \"policy\",\n  \"pop\",\n  \"pop3\",\n  \"popular\",\n  \"porn\",\n  \"portal\",\n  \"portals\",\n  \"post\",\n  \"postfix\",\n  \"postmaster\",\n  \"posts\",\n  \"pr\",\n  \"pr0n\",\n  \"premium\",\n  \"press\",\n  \"price\",\n  \"pricing\",\n  \"principles\",\n  \"print\",\n  \"privacy\",\n  \"privacy-policy\",\n  \"privacypolicy\",\n  \"privacy_policy\",\n  \"private\",\n  \"prod\",\n  \"product\",\n  \"production\",\n  \"products\",\n  \"profile\",\n  \"profiles\",\n  \"project\",\n  \"projects\",\n  \"promo\",\n  \"promotions\",\n  \"proxies\",\n  \"proxy\",\n  \"pub\",\n  \"public\",\n  \"purchase\",\n  \"purpose\",\n  \"put\",\n  \"python\",\n  \"queries\",\n  \"query\",\n  \"radio\",\n  \"random\",\n  \"ranking\",\n  \"read\",\n  \"reader\",\n  \"readme\",\n  \"recent\",\n  \"recruit\",\n  \"recruitment\",\n  \"redirect\",\n  \"register\",\n  \"registration\",\n  \"release\",\n  \"remove\",\n  \"replies\",\n  \"report\",\n  \"reports\",\n  \"repositories\",\n  \"repository\",\n  \"req\",\n  \"request\",\n  \"requests\",\n  \"research\",\n  \"reset\",\n  \"resolve\",\n  \"resolver\",\n  \"review\",\n  \"rnail\",\n  \"rnicrosoft\",\n  \"roc\",\n  \"root\",\n  \"rss\",\n  \"ruby\",\n  \"rule\",\n  \"sag\",\n  \"sale\",\n  \"sales\",\n  \"sample\",\n  \"samples\",\n  \"sandbox\",\n  \"save\",\n  \"scholar\",\n  \"school\",\n  \"schools\",\n  \"script\",\n  \"scripts\",\n  \"search\",\n  \"secure\",\n  \"security\",\n  \"self\",\n  \"seminars\",\n  \"send\",\n  \"server\",\n  \"server-info\",\n  \"server_info\",\n  \"server-status\",\n  \"server_status\",\n  \"servers\",\n  \"service\",\n  \"services\",\n  \"session\",\n  \"sessions\",\n  \"setting\",\n  \"settings\",\n  \"setup\",\n  \"share\",\n  \"shop\",\n  \"shopping\",\n  \"shortcut\",\n  \"shortcuts\",\n  \"show\",\n  \"sign-in\",\n  \"sign-up\",\n  \"signin\",\n  \"signout\",\n  \"signup\",\n  \"sign_in\",\n  \"sign_up\",\n  \"site\",\n  \"sitemap\",\n  \"sitemaps\",\n  \"sitenews\",\n  \"sites\",\n  \"sketchup\",\n  \"sky\",\n  \"slash\",\n  \"slashinvoice\",\n  \"slut\",\n  \"smartphone\",\n  \"sms\",\n  \"smtp\",\n  \"soap\",\n  \"software\",\n  \"sorry\",\n  \"source\",\n  \"spec\",\n  \"special\",\n  \"spreadsheet\",\n  \"spreadsheets\",\n  \"sql\",\n  \"src\",\n  \"srntp\",\n  \"ssh\",\n  \"ssl\",\n  \"ssladmin\",\n  \"ssladministrator\",\n  \"sslwebmaster\",\n  \"ssytem\",\n  \"staff\",\n  \"stage\",\n  \"staging\",\n  \"start\",\n  \"stat\",\n  \"state\",\n  \"static\",\n  \"statistics\",\n  \"stats\",\n  \"status\",\n  \"store\",\n  \"stores\",\n  \"stories\",\n  \"style\",\n  \"styleguide\",\n  \"styles\",\n  \"stylesheet\",\n  \"stylesheets\",\n  \"subdomain\",\n  \"subscribe\",\n  \"subscription\",\n  \"subscriptions\",\n  \"suggest\",\n  \"suggestqueries\",\n  \"support\",\n  \"survey\",\n  \"surveys\",\n  \"surveytool\",\n  \"svn\",\n  \"swf\",\n  \"syn\",\n  \"sync\",\n  \"syndicated\",\n  \"sys\",\n  \"sysadmin\",\n  \"sysadministrator\",\n  \"sysadmins\",\n  \"system\",\n  \"tablet\",\n  \"tablets\",\n  \"tag\",\n  \"tags\",\n  \"talk\",\n  \"talkgadget\",\n  \"task\",\n  \"tasks\",\n  \"team\",\n  \"teams\",\n  \"tech\",\n  \"telnet\",\n  \"term\",\n  \"terms\",\n  \"terms-of-service\",\n  \"termsofservice\",\n  \"terms_of_service\",\n  \"test\",\n  \"testing\",\n  \"tests\",\n  \"text\",\n  \"theme\",\n  \"themes\",\n  \"thread\",\n  \"threads\",\n  \"ticket\",\n  \"tickets\",\n  \"tmp\",\n  \"todo\",\n  \"to-do\",\n  \"to_do\",\n  \"toml\",\n  \"tool\",\n  \"toolbar\",\n  \"toolbars\",\n  \"tools\",\n  \"top\",\n  \"topic\",\n  \"topics\",\n  \"tos\",\n  \"tour\",\n  \"trac\",\n  \"translate\",\n  \"trace\",\n  \"translation\",\n  \"translations\",\n  \"translator\",\n  \"trends\",\n  \"tutorial\",\n  \"tux\",\n  \"tv\",\n  \"twitter\",\n  \"txt\",\n  \"ul\",\n  \"undef\",\n  \"unfollow\",\n  \"unsubscribe\",\n  \"update\",\n  \"updates\",\n  \"upgrade\",\n  \"upgrades\",\n  \"upi\",\n  \"upload\",\n  \"uploads\",\n  \"url\",\n  \"usage\",\n  \"user\",\n  \"username\",\n  \"usernames\",\n  \"users\",\n  \"uuid\",\n  \"validation\",\n  \"validations\",\n  \"ver\",\n  \"version\",\n  \"video\",\n  \"videos\",\n  \"video-stats\",\n  \"visitor\",\n  \"visitors\",\n  \"voice\",\n  \"volunteer\",\n  \"volunteers\",\n  \"w\",\n  \"watch\",\n  \"wave\",\n  \"weather\",\n  \"web\",\n  \"webdisk\",\n  \"webhook\",\n  \"webhooks\",\n  \"webmail\",\n  \"webmaster\",\n  \"webmasters\",\n  \"webrnail\",\n  \"website\",\n  \"websites\",\n  \"welcome\",\n  \"whm\",\n  \"whois\",\n  \"widget\",\n  \"widgets\",\n  \"wifi\",\n  \"wiki\",\n  \"wikis\",\n  \"win\",\n  \"windows\",\n  \"word\",\n  \"work\",\n  \"works\",\n  \"workshop\",\n  \"wpad\",\n  \"ww\",\n  \"wws\",\n  \"www\",\n  \"wwws\",\n  \"wwww\",\n  \"xfn\",\n  \"xhtml\",\n  \"xhtrnl\",\n  \"xml\",\n  \"xmpp\",\n  \"xpg\",\n  \"xxx\",\n  \"yaml\",\n  \"year\",\n  \"yml\",\n  \"you\",\n  \"yourdomain\",\n  \"yourname\",\n  \"yoursite\",\n  \"yourusername\"\n];\nvar famousAccounts = [\n  \"10ronaldinho\",\n  \"3gerardpique\",\n  \"adele\",\n  \"akshaykumar\",\n  \"aliaa08\",\n  \"aliciakeys\",\n  \"amitshah\",\n  \"andresiniesta8\",\n  \"anushkasharma\",\n  \"arianagrande\",\n  \"arrahman\",\n  \"arvindkejriwal\",\n  \"avrillavigne\",\n  \"barackobama\",\n  \"bbcbreaking\",\n  \"bbcworld\",\n  \"beingsalmankhan\",\n  \"billgates\",\n  \"britneyspears\",\n  \"brunomars\",\n  \"bts_bighit\",\n  \"bts_twt\",\n  \"championsleague\",\n  \"chrisbrown\",\n  \"cnnbrk\",\n  \"coldplay\",\n  \"conanobrien\",\n  \"cristiano\",\n  \"danieltosh\",\n  \"davidguetta\",\n  \"ddlovato\",\n  \"deepikapadukone\",\n  \"drake\",\n  \"elisapie\",\n  \"ellendegeneres\",\n  \"elonmusk\",\n  \"eminem\",\n  \"emmawatson\",\n  \"fcbarcelona\",\n  \"foxnews\",\n  \"harry_styles\",\n  \"hillaryclinton\",\n  \"iamsrk\",\n  \"ihrithik\",\n  \"imvkohli\",\n  \"instagram\",\n  \"jimmyfallon\",\n  \"jlo\",\n  \"joebiden\",\n  \"jtimberlake\",\n  \"justinbieber\",\n  \"kaka\",\n  \"kanyewest\",\n  \"katyperry\",\n  \"kendalljenner\",\n  \"kevinhart4real\",\n  \"khloekardashian\",\n  \"kimkardashian\",\n  \"kingjames\",\n  \"kourtneykardash\",\n  \"kyliejenner\",\n  \"ladygaga\",\n  \"liampayne\",\n  \"liltunechi\",\n  \"manutd\",\n  \"mariahcarey\",\n  \"mileycyrus\",\n  \"mohamadalarefe\",\n  \"narendramodi\",\n  \"nasa\",\n  \"nba\",\n  \"neymarjr\",\n  \"nfl\",\n  \"niallofficial\",\n  \"nickiminaj\",\n  \"npr\",\n  \"nytimes\",\n  \"onedirection\",\n  \"oprah\",\n  \"pink\",\n  \"pitbull\",\n  \"playstation\",\n  \"pmoindia\",\n  \"premierleague\",\n  \"priyankachopra\",\n  \"realdonaldtrump\",\n  \"ricky_martin\",\n  \"rihanna\",\n  \"sachin_rt\",\n  \"selenagomez\",\n  \"shakira\",\n  \"shawnmendes\",\n  \"sportscenter\",\n  \"srbachchan\",\n  \"subhisharma100\",\n  \"taylorswift13\",\n  \"theeconomist\",\n  \"twitter\",\n  \"virendersehwag\",\n  \"whitehouse45\",\n  \"wizkhalifa\",\n  \"youtube\",\n  \"zaynmalik\",\n  \"beyonce\",\n  \"billieeilish\",\n  \"leomessi\",\n  \"natgeo\",\n  \"nike\",\n  \"snoopdogg\",\n  \"taylorswift\",\n  \"therock\",\n  \"10downingstreet\",\n  \"aoc\",\n  \"carterjwm\",\n  \"dril\",\n  \"gretathunberg\",\n  \"kamalaharris\",\n  \"kremlinrussia_e\",\n  \"potus\",\n  \"rondesantisfl\",\n  \"ukraine\",\n  \"washingtonpost\",\n  \"yousuck2020\",\n  \"zelenskyyua\"\n];\nvar reservedSubdomains = [\n  ...atpSpecific,\n  ...commonlyReserved,\n  ...famousAccounts\n].reduce((acc, cur) => {\n  return {\n    ...acc,\n    [cur]: true\n  };\n}, {});\n\n// ../identifier/src/handle.ts\nvar ensureValidHandle = (handle2) => {\n  if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {\n    throw new InvalidHandleError(\n      \"Disallowed characters in handle (ASCII letters, digits, dashes, periods only)\"\n    );\n  }\n  if (handle2.length > 253) {\n    throw new InvalidHandleError(\"Handle is too long (253 chars max)\");\n  }\n  const labels = handle2.split(\".\");\n  if (labels.length < 2) {\n    throw new InvalidHandleError(\"Handle domain needs at least two parts\");\n  }\n  for (let i = 0; i < labels.length; i++) {\n    const l = labels[i];\n    if (l.length < 1) {\n      throw new InvalidHandleError(\"Handle parts can not be empty\");\n    }\n    if (l.length > 63) {\n      throw new InvalidHandleError(\"Handle part too long (max 63 chars)\");\n    }\n    if (l.endsWith(\"-\") || l.startsWith(\"-\")) {\n      throw new InvalidHandleError(\n        \"Handle parts can not start or end with hyphens\"\n      );\n    }\n    if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {\n      throw new InvalidHandleError(\n        \"Handle final component (TLD) must start with ASCII letter\"\n      );\n    }\n  }\n};\nvar InvalidHandleError = class extends Error {\n};\n\n// ../identifier/src/did.ts\nvar ensureValidDid = (did2) => {\n  if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {\n    throw new InvalidDidError(\n      \"Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)\"\n    );\n  }\n  const parts = did2.split(\":\");\n  if (parts.length < 3) {\n    throw new InvalidDidError(\n      \"DID requires prefix, method, and method-specific content\"\n    );\n  }\n  if (parts[0] != \"did\") {\n    throw new InvalidDidError('DID requires \"did:\" prefix');\n  }\n  if (!/^[a-z]+$/.test(parts[1])) {\n    throw new InvalidDidError(\"DID method must be lower-case letters\");\n  }\n  if (did2.endsWith(\":\") || did2.endsWith(\"%\")) {\n    throw new InvalidDidError('DID can not end with \":\" or \"%\"');\n  }\n  if (did2.length > 8 * 1024) {\n    throw new InvalidDidError(\"DID is far too long\");\n  }\n};\nvar InvalidDidError = class extends Error {\n};\n\n// ../nsid/src/index.ts\nvar NSID = class {\n  constructor(nsid2) {\n    this.segments = [];\n    ensureValidNsid(nsid2);\n    this.segments = nsid2.split(\".\");\n  }\n  static parse(nsid2) {\n    return new NSID(nsid2);\n  }\n  static create(authority, name2) {\n    const segments = [...authority.split(\".\").reverse(), name2].join(\".\");\n    return new NSID(segments);\n  }\n  static isValid(nsid2) {\n    try {\n      NSID.parse(nsid2);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  get authority() {\n    return this.segments.slice(0, this.segments.length - 1).reverse().join(\".\");\n  }\n  get name() {\n    return this.segments.at(this.segments.length - 1);\n  }\n  toString() {\n    return this.segments.join(\".\");\n  }\n};\nvar ensureValidNsid = (nsid2) => {\n  const split = nsid2.split(\".\");\n  const toCheck = split.at(-1) === \"*\" ? split.slice(0, -1).join(\".\") : split.join(\".\");\n  if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {\n    throw new InvalidNsidError(\n      \"Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)\"\n    );\n  }\n  if (toCheck.length > 253 + 1 + 128) {\n    throw new InvalidNsidError(\"NSID is too long (382 chars max)\");\n  }\n  const labels = toCheck.split(\".\");\n  if (split.length < 3) {\n    throw new InvalidNsidError(\"NSID needs at least three parts\");\n  }\n  for (let i = 0; i < labels.length; i++) {\n    const l = labels[i];\n    if (l.length < 1) {\n      throw new InvalidNsidError(\"NSID parts can not be empty\");\n    }\n    if (l.length > 63 && i + 1 < labels.length) {\n      throw new InvalidNsidError(\"NSID domain part too long (max 63 chars)\");\n    }\n    if (l.length > 128 && i + 1 == labels.length) {\n      throw new InvalidNsidError(\"NSID name part too long (max 127 chars)\");\n    }\n    if (l.endsWith(\"-\")) {\n      throw new InvalidNsidError(\"NSID parts can not end with hyphen\");\n    }\n    if (!/^[a-zA-Z]/.test(l)) {\n      throw new InvalidNsidError(\"NSID parts must start with ASCII letter\");\n    }\n  }\n};\nvar InvalidNsidError = class extends Error {\n};\n\n// ../uri/src/validation.ts\nvar ensureValidAtUri = (uri2) => {\n  const uriParts = uri2.split(\"#\");\n  if (uriParts.length > 2) {\n    throw new Error('ATURI can have at most one \"#\", separating fragment out');\n  }\n  const fragmentPart = uriParts[1] || null;\n  uri2 = uriParts[0];\n  if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri2)) {\n    throw new Error(\"Disallowed characters in ATURI (ASCII)\");\n  }\n  const parts = uri2.split(\"/\");\n  if (parts.length >= 3 && (parts[0] != \"at:\" || parts[1].length != 0)) {\n    throw new Error('ATURI must start with \"at://\"');\n  }\n  if (parts.length < 3) {\n    throw new Error(\"ATURI requires at least method and authority sections\");\n  }\n  try {\n    ensureValidHandle(parts[2]);\n  } catch {\n    try {\n      ensureValidDid(parts[2]);\n    } catch {\n      throw new Error(\"ATURI authority must be a valid handle or DID\");\n    }\n  }\n  if (parts.length >= 4) {\n    if (parts[3].length == 0) {\n      throw new Error(\n        \"ATURI can not have a slash after authority without a path segment\"\n      );\n    }\n    try {\n      ensureValidNsid(parts[3]);\n    } catch {\n      throw new Error(\n        \"ATURI requires first path segment (if supplied) to be valid NSID\"\n      );\n    }\n  }\n  if (parts.length >= 5) {\n    if (parts[4].length == 0) {\n      throw new Error(\n        \"ATURI can not have a slash after collection, unless record key is provided\"\n      );\n    }\n  }\n  if (parts.length >= 6) {\n    throw new Error(\n      \"ATURI path can have at most two parts, and no trailing slash\"\n    );\n  }\n  if (uriParts.length >= 2 && fragmentPart == null) {\n    throw new Error(\"ATURI fragment must be non-empty and start with slash\");\n  }\n  if (fragmentPart != null) {\n    if (fragmentPart.length == 0 || fragmentPart[0] != \"/\") {\n      throw new Error(\"ATURI fragment must be non-empty and start with slash\");\n    }\n    if (!/^\\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\\]/-]*$/.test(fragmentPart)) {\n      throw new Error(\"Disallowed characters in ATURI fragment (ASCII)\");\n    }\n  }\n  if (uri2.length > 8 * 1024) {\n    throw new Error(\"ATURI is far too long\");\n  }\n};\n\n// ../uri/src/index.ts\nvar ATP_URI_REGEX = /^(at:\\/\\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\\/[^?#\\s]*)?(\\?[^#\\s]+)?(#[^\\s]+)?$/i;\nvar RELATIVE_REGEX = /^(\\/[^?#\\s]*)?(\\?[^#\\s]+)?(#[^\\s]+)?$/i;\nvar AtUri = class {\n  constructor(uri2, base3) {\n    let parsed;\n    if (base3) {\n      parsed = parse(base3);\n      if (!parsed) {\n        throw new Error(`Invalid at uri: ${base3}`);\n      }\n      const relativep = parseRelative(uri2);\n      if (!relativep) {\n        throw new Error(`Invalid path: ${uri2}`);\n      }\n      Object.assign(parsed, relativep);\n    } else {\n      parsed = parse(uri2);\n      if (!parsed) {\n        throw new Error(`Invalid at uri: ${uri2}`);\n      }\n    }\n    this.hash = parsed.hash;\n    this.host = parsed.host;\n    this.pathname = parsed.pathname;\n    this.searchParams = parsed.searchParams;\n  }\n  static make(handleOrDid, collection, rkey) {\n    let str = handleOrDid;\n    if (collection)\n      str += \"/\" + collection;\n    if (rkey)\n      str += \"/\" + rkey;\n    return new AtUri(str);\n  }\n  get protocol() {\n    return \"at:\";\n  }\n  get origin() {\n    return `at://${this.host}`;\n  }\n  get hostname() {\n    return this.host;\n  }\n  set hostname(v) {\n    this.host = v;\n  }\n  get search() {\n    return this.searchParams.toString();\n  }\n  set search(v) {\n    this.searchParams = new URLSearchParams(v);\n  }\n  get collection() {\n    return this.pathname.split(\"/\").filter(Boolean)[0] || \"\";\n  }\n  set collection(v) {\n    const parts = this.pathname.split(\"/\").filter(Boolean);\n    parts[0] = v;\n    this.pathname = parts.join(\"/\");\n  }\n  get rkey() {\n    return this.pathname.split(\"/\").filter(Boolean)[1] || \"\";\n  }\n  set rkey(v) {\n    const parts = this.pathname.split(\"/\").filter(Boolean);\n    if (!parts[0])\n      parts[0] = \"undefined\";\n    parts[1] = v;\n    this.pathname = parts.join(\"/\");\n  }\n  get href() {\n    return this.toString();\n  }\n  toString() {\n    let path = this.pathname || \"/\";\n    if (!path.startsWith(\"/\")) {\n      path = `/${path}`;\n    }\n    let qs = this.searchParams.toString();\n    if (qs && !qs.startsWith(\"?\")) {\n      qs = `?${qs}`;\n    }\n    let hash = this.hash;\n    if (hash && !hash.startsWith(\"#\")) {\n      hash = `#${hash}`;\n    }\n    return `at://${this.host}${path}${qs}${hash}`;\n  }\n};\nfunction parse(str) {\n  const match = ATP_URI_REGEX.exec(str);\n  if (match) {\n    return {\n      hash: match[5] || \"\",\n      host: match[2] || \"\",\n      pathname: match[3] || \"\",\n      searchParams: new URLSearchParams(match[4] || \"\")\n    };\n  }\n  return void 0;\n}\nfunction parseRelative(str) {\n  const match = RELATIVE_REGEX.exec(str);\n  if (match) {\n    return {\n      hash: match[3] || \"\",\n      pathname: match[1] || \"\",\n      searchParams: new URLSearchParams(match[2] || \"\")\n    };\n  }\n  return void 0;\n}\n\n// ../lexicon/src/types.ts\nvar lexBoolean = mod.object({\n  type: mod.literal(\"boolean\"),\n  description: mod.string().optional(),\n  default: mod.boolean().optional(),\n  const: mod.boolean().optional()\n});\nvar lexInteger = mod.object({\n  type: mod.literal(\"integer\"),\n  description: mod.string().optional(),\n  default: mod.number().int().optional(),\n  minimum: mod.number().int().optional(),\n  maximum: mod.number().int().optional(),\n  enum: mod.number().int().array().optional(),\n  const: mod.number().int().optional()\n});\nvar lexStringFormat = mod.enum([\n  \"datetime\",\n  \"uri\",\n  \"at-uri\",\n  \"did\",\n  \"handle\",\n  \"at-identifier\",\n  \"nsid\",\n  \"cid\"\n]);\nvar lexString = mod.object({\n  type: mod.literal(\"string\"),\n  format: lexStringFormat.optional(),\n  description: mod.string().optional(),\n  default: mod.string().optional(),\n  minLength: mod.number().int().optional(),\n  maxLength: mod.number().int().optional(),\n  minGraphemes: mod.number().int().optional(),\n  maxGraphemes: mod.number().int().optional(),\n  enum: mod.string().array().optional(),\n  const: mod.string().optional(),\n  knownValues: mod.string().array().optional()\n});\nvar lexUnknown = mod.object({\n  type: mod.literal(\"unknown\"),\n  description: mod.string().optional()\n});\nvar lexPrimitive = mod.union([\n  lexBoolean,\n  lexInteger,\n  lexString,\n  lexUnknown\n]);\nvar lexBytes = mod.object({\n  type: mod.literal(\"bytes\"),\n  description: mod.string().optional(),\n  maxLength: mod.number().optional(),\n  minLength: mod.number().optional()\n});\nvar lexCidLink = mod.object({\n  type: mod.literal(\"cid-link\"),\n  description: mod.string().optional()\n});\nvar lexIpldType = mod.union([lexBytes, lexCidLink]);\nvar lexRef = mod.object({\n  type: mod.literal(\"ref\"),\n  description: mod.string().optional(),\n  ref: mod.string()\n});\nvar lexRefUnion = mod.object({\n  type: mod.literal(\"union\"),\n  description: mod.string().optional(),\n  refs: mod.string().array(),\n  closed: mod.boolean().optional()\n});\nvar lexRefVariant = mod.union([lexRef, lexRefUnion]);\nvar lexBlob = mod.object({\n  type: mod.literal(\"blob\"),\n  description: mod.string().optional(),\n  accept: mod.string().array().optional(),\n  maxSize: mod.number().optional()\n});\nvar lexArray = mod.object({\n  type: mod.literal(\"array\"),\n  description: mod.string().optional(),\n  items: mod.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),\n  minLength: mod.number().int().optional(),\n  maxLength: mod.number().int().optional()\n});\nvar lexPrimitiveArray = lexArray.merge(\n  mod.object({\n    items: lexPrimitive\n  })\n);\nvar lexToken = mod.object({\n  type: mod.literal(\"token\"),\n  description: mod.string().optional()\n});\nvar lexObject = mod.object({\n  type: mod.literal(\"object\"),\n  description: mod.string().optional(),\n  required: mod.string().array().optional(),\n  nullable: mod.string().array().optional(),\n  properties: mod.record(\n    mod.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive])\n  ).optional()\n});\nvar lexXrpcParameters = mod.object({\n  type: mod.literal(\"params\"),\n  description: mod.string().optional(),\n  required: mod.string().array().optional(),\n  properties: mod.record(mod.union([lexPrimitive, lexPrimitiveArray]))\n});\nvar lexXrpcBody = mod.object({\n  description: mod.string().optional(),\n  encoding: mod.string(),\n  schema: mod.union([lexRefVariant, lexObject]).optional()\n});\nvar lexXrpcSubscriptionMessage = mod.object({\n  description: mod.string().optional(),\n  schema: mod.union([lexRefVariant, lexObject]).optional()\n});\nvar lexXrpcError = mod.object({\n  name: mod.string(),\n  description: mod.string().optional()\n});\nvar lexXrpcQuery = mod.object({\n  type: mod.literal(\"query\"),\n  description: mod.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  output: lexXrpcBody.optional(),\n  errors: lexXrpcError.array().optional()\n});\nvar lexXrpcProcedure = mod.object({\n  type: mod.literal(\"procedure\"),\n  description: mod.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  input: lexXrpcBody.optional(),\n  output: lexXrpcBody.optional(),\n  errors: lexXrpcError.array().optional()\n});\nvar lexXrpcSubscription = mod.object({\n  type: mod.literal(\"subscription\"),\n  description: mod.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  message: lexXrpcSubscriptionMessage.optional(),\n  infos: lexXrpcError.array().optional(),\n  errors: lexXrpcError.array().optional()\n});\nvar lexRecord = mod.object({\n  type: mod.literal(\"record\"),\n  description: mod.string().optional(),\n  key: mod.string().optional(),\n  record: lexObject\n});\nvar lexUserType = mod.union([\n  lexRecord,\n  lexXrpcQuery,\n  lexXrpcProcedure,\n  lexXrpcSubscription,\n  lexBlob,\n  lexArray,\n  lexToken,\n  lexObject,\n  lexBoolean,\n  lexInteger,\n  lexString,\n  lexBytes,\n  lexCidLink,\n  lexUnknown\n]);\nvar lexiconDoc = mod.object({\n  lexicon: mod.literal(1),\n  id: mod.string().refine((v) => NSID.isValid(v), {\n    message: \"Must be a valid NSID\"\n  }),\n  revision: mod.number().optional(),\n  description: mod.string().optional(),\n  defs: mod.record(lexUserType)\n}).superRefine((doc, ctx) => {\n  for (const defId in doc.defs) {\n    const def2 = doc.defs[defId];\n    if (defId !== \"main\" && (def2.type === \"record\" || def2.type === \"procedure\" || def2.type === \"query\" || def2.type === \"subscription\")) {\n      ctx.addIssue({\n        code: mod.ZodIssueCode.custom,\n        message: `Records, procedures, queries, and subscriptions must be the main definition.`\n      });\n    }\n  }\n});\nfunction isObj(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\nfunction hasProp(data, prop) {\n  return prop in data;\n}\nvar discriminatedObject = mod.object({ $type: mod.string() });\nfunction isDiscriminatedObject(value) {\n  return discriminatedObject.safeParse(value).success;\n}\nvar LexiconDocMalformedError = class extends Error {\n  constructor(message, schemaDef, issues) {\n    super(message);\n    this.schemaDef = schemaDef;\n    this.issues = issues;\n    this.schemaDef = schemaDef;\n    this.issues = issues;\n  }\n};\nvar ValidationError = class extends Error {\n};\nvar InvalidLexiconError = class extends Error {\n};\nvar LexiconDefNotFoundError = class extends Error {\n};\n\n// ../lexicon/src/validators/formats.ts\nvar import_iso_datestring_validator = __toESM(require_dist());\nfunction datetime(path, value) {\n  try {\n    if (!(0, import_iso_datestring_validator.isValidISODateString)(value)) {\n      throw new Error();\n    }\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(\n        `${path} must be an iso8601 formatted datetime`\n      )\n    };\n  }\n  return { success: true, value };\n}\nfunction uri(path, value) {\n  const isUri = value.match(/^\\w+:(?:\\/\\/)?[^\\s/][^\\s]*$/) !== null;\n  if (!isUri) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a uri`)\n    };\n  }\n  return { success: true, value };\n}\nfunction atUri(path, value) {\n  try {\n    ensureValidAtUri(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid at-uri`)\n    };\n  }\n  return { success: true, value };\n}\nfunction did(path, value) {\n  try {\n    ensureValidDid(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid did`)\n    };\n  }\n  return { success: true, value };\n}\nfunction handle(path, value) {\n  try {\n    ensureValidHandle(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid handle`)\n    };\n  }\n  return { success: true, value };\n}\nfunction atIdentifier(path, value) {\n  const isDid = did(path, value);\n  if (!isDid.success) {\n    const isHandle2 = handle(path, value);\n    if (!isHandle2.success) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be a valid did or a handle`)\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction nsid(path, value) {\n  try {\n    ensureValidNsid(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a valid nsid`)\n    };\n  }\n  return { success: true, value };\n}\nfunction cid(path, value) {\n  try {\n    CID.parse(value);\n  } catch {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a cid string`)\n    };\n  }\n  return { success: true, value };\n}\n\n// ../lexicon/src/validators/primitives.ts\nfunction validate(lexicons2, path, def2, value) {\n  switch (def2.type) {\n    case \"boolean\":\n      return boolean(lexicons2, path, def2, value);\n    case \"integer\":\n      return integer(lexicons2, path, def2, value);\n    case \"string\":\n      return string2(lexicons2, path, def2, value);\n    case \"bytes\":\n      return bytes(lexicons2, path, def2, value);\n    case \"cid-link\":\n      return cidLink(lexicons2, path, def2, value);\n    case \"unknown\":\n      return unknown(lexicons2, path, def2, value);\n    default:\n      return {\n        success: false,\n        error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)\n      };\n  }\n}\nfunction boolean(lexicons2, path, def2, value) {\n  def2 = def2;\n  const type = typeof value;\n  if (type === \"undefined\") {\n    if (typeof def2.default === \"boolean\") {\n      return { success: true, value: def2.default };\n    }\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a boolean`)\n    };\n  } else if (type !== \"boolean\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a boolean`)\n    };\n  }\n  if (typeof def2.const === \"boolean\") {\n    if (value !== def2.const) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be ${def2.const}`)\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction integer(lexicons2, path, def2, value) {\n  def2 = def2;\n  const type = typeof value;\n  if (type === \"undefined\") {\n    if (typeof def2.default === \"number\") {\n      return { success: true, value: def2.default };\n    }\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an integer`)\n    };\n  } else if (!Number.isInteger(value)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an integer`)\n    };\n  }\n  if (typeof def2.const === \"number\") {\n    if (value !== def2.const) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be ${def2.const}`)\n      };\n    }\n  }\n  if (Array.isArray(def2.enum)) {\n    if (!def2.enum.includes(value)) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must be one of (${def2.enum.join(\"|\")})`\n        )\n      };\n    }\n  }\n  if (typeof def2.maximum === \"number\") {\n    if (value > def2.maximum) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} can not be greater than ${def2.maximum}`\n        )\n      };\n    }\n  }\n  if (typeof def2.minimum === \"number\") {\n    if (value < def2.minimum) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} can not be less than ${def2.minimum}`\n        )\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction string2(lexicons2, path, def2, value) {\n  def2 = def2;\n  if (typeof value === \"undefined\") {\n    if (typeof def2.default === \"string\") {\n      return { success: true, value: def2.default };\n    }\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a string`)\n    };\n  } else if (typeof value !== \"string\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a string`)\n    };\n  }\n  if (typeof def2.const === \"string\") {\n    if (value !== def2.const) {\n      return {\n        success: false,\n        error: new ValidationError(`${path} must be ${def2.const}`)\n      };\n    }\n  }\n  if (Array.isArray(def2.enum)) {\n    if (!def2.enum.includes(value)) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must be one of (${def2.enum.join(\"|\")})`\n        )\n      };\n    }\n  }\n  if (typeof def2.maxLength === \"number\") {\n    if (utf8Len(value) > def2.maxLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be longer than ${def2.maxLength} characters`\n        )\n      };\n    }\n  }\n  if (typeof def2.minLength === \"number\") {\n    if (utf8Len(value) < def2.minLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be shorter than ${def2.minLength} characters`\n        )\n      };\n    }\n  }\n  if (typeof def2.maxGraphemes === \"number\") {\n    if (graphemeLen(value) > def2.maxGraphemes) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be longer than ${def2.maxGraphemes} graphemes`\n        )\n      };\n    }\n  }\n  if (typeof def2.minGraphemes === \"number\") {\n    if (graphemeLen(value) < def2.minGraphemes) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be shorter than ${def2.minGraphemes} graphemes`\n        )\n      };\n    }\n  }\n  if (typeof def2.format === \"string\") {\n    switch (def2.format) {\n      case \"datetime\":\n        return datetime(path, value);\n      case \"uri\":\n        return uri(path, value);\n      case \"at-uri\":\n        return atUri(path, value);\n      case \"did\":\n        return did(path, value);\n      case \"handle\":\n        return handle(path, value);\n      case \"at-identifier\":\n        return atIdentifier(path, value);\n      case \"nsid\":\n        return nsid(path, value);\n      case \"cid\":\n        return cid(path, value);\n    }\n  }\n  return { success: true, value };\n}\nfunction bytes(lexicons2, path, def2, value) {\n  def2 = def2;\n  if (!value || !(value instanceof Uint8Array)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a byte array`)\n    };\n  }\n  if (typeof def2.maxLength === \"number\") {\n    if (value.byteLength > def2.maxLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be larger than ${def2.maxLength} bytes`\n        )\n      };\n    }\n  }\n  if (typeof def2.minLength === \"number\") {\n    if (value.byteLength < def2.minLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not be smaller than ${def2.minLength} bytes`\n        )\n      };\n    }\n  }\n  return { success: true, value };\n}\nfunction cidLink(lexicons2, path, def2, value) {\n  if (CID.asCID(value) === null) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be a CID`)\n    };\n  }\n  return { success: true, value };\n}\nfunction unknown(lexicons2, path, def2, value) {\n  if (!value || typeof value !== \"object\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an object`)\n    };\n  }\n  return { success: true, value };\n}\n\n// ../lexicon/src/blob-refs.ts\nvar typedJsonBlobRef = mod.object({\n  $type: mod.literal(\"blob\"),\n  ref: schema.cid,\n  mimeType: mod.string(),\n  size: mod.number()\n}).strict();\nvar untypedJsonBlobRef = mod.object({\n  cid: mod.string(),\n  mimeType: mod.string()\n}).strict();\nvar jsonBlobRef = mod.union([typedJsonBlobRef, untypedJsonBlobRef]);\nvar BlobRef = class {\n  constructor(ref, mimeType, size, original) {\n    this.ref = ref;\n    this.mimeType = mimeType;\n    this.size = size;\n    this.original = original ?? {\n      $type: \"blob\",\n      ref,\n      mimeType,\n      size\n    };\n  }\n  static asBlobRef(obj) {\n    if (check_exports.is(obj, jsonBlobRef)) {\n      return BlobRef.fromJsonRef(obj);\n    }\n    return null;\n  }\n  static fromJsonRef(json) {\n    if (check_exports.is(json, typedJsonBlobRef)) {\n      return new BlobRef(json.ref, json.mimeType, json.size);\n    } else {\n      return new BlobRef(CID.parse(json.cid), json.mimeType, -1, json);\n    }\n  }\n  ipld() {\n    return {\n      $type: \"blob\",\n      ref: this.ref,\n      mimeType: this.mimeType,\n      size: this.size\n    };\n  }\n  toJSON() {\n    return ipldToJson(this.ipld());\n  }\n};\n\n// ../lexicon/src/validators/blob.ts\nfunction blob(lexicons2, path, def2, value) {\n  if (!value || !(value instanceof BlobRef)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} should be a blob ref`)\n    };\n  }\n  return { success: true, value };\n}\n\n// ../lexicon/src/validators/complex.ts\nfunction validate2(lexicons2, path, def2, value) {\n  switch (def2.type) {\n    case \"boolean\":\n      return boolean(lexicons2, path, def2, value);\n    case \"integer\":\n      return integer(lexicons2, path, def2, value);\n    case \"string\":\n      return string2(lexicons2, path, def2, value);\n    case \"bytes\":\n      return bytes(lexicons2, path, def2, value);\n    case \"cid-link\":\n      return cidLink(lexicons2, path, def2, value);\n    case \"unknown\":\n      return unknown(lexicons2, path, def2, value);\n    case \"object\":\n      return object(lexicons2, path, def2, value);\n    case \"array\":\n      return array(lexicons2, path, def2, value);\n    case \"blob\":\n      return blob(lexicons2, path, def2, value);\n    default:\n      return {\n        success: false,\n        error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)\n      };\n  }\n}\nfunction array(lexicons2, path, def2, value) {\n  if (!Array.isArray(value)) {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an array`)\n    };\n  }\n  if (typeof def2.maxLength === \"number\") {\n    if (value.length > def2.maxLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not have more than ${def2.maxLength} elements`\n        )\n      };\n    }\n  }\n  if (typeof def2.minLength === \"number\") {\n    if (value.length < def2.minLength) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must not have fewer than ${def2.minLength} elements`\n        )\n      };\n    }\n  }\n  const itemsDef = def2.items;\n  for (let i = 0; i < value.length; i++) {\n    const itemValue = value[i];\n    const itemPath = `${path}/${i}`;\n    const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);\n    if (!res.success) {\n      return res;\n    }\n  }\n  return { success: true, value };\n}\nfunction object(lexicons2, path, def2, value) {\n  def2 = def2;\n  if (!value || typeof value !== \"object\") {\n    return {\n      success: false,\n      error: new ValidationError(`${path} must be an object`)\n    };\n  }\n  const requiredProps = new Set(def2.required);\n  const nullableProps = new Set(def2.nullable);\n  let resultValue = value;\n  if (typeof def2.properties === \"object\") {\n    for (const key in def2.properties) {\n      if (value[key] === null && nullableProps.has(key)) {\n        continue;\n      }\n      const propDef = def2.properties[key];\n      const propPath = `${path}/${key}`;\n      const validated = validateOneOf(lexicons2, propPath, propDef, value[key]);\n      const propValue = validated.success ? validated.value : value[key];\n      const propIsUndefined = typeof propValue === \"undefined\";\n      if (propIsUndefined && requiredProps.has(key)) {\n        return {\n          success: false,\n          error: new ValidationError(`${path} must have the property \"${key}\"`)\n        };\n      } else if (!propIsUndefined && !validated.success) {\n        return validated;\n      }\n      if (propValue !== value[key]) {\n        if (resultValue === value) {\n          resultValue = { ...value };\n        }\n        resultValue[key] = propValue;\n      }\n    }\n  }\n  return { success: true, value: resultValue };\n}\n\n// ../lexicon/src/util.ts\nfunction toLexUri(str, baseUri) {\n  if (str.startsWith(\"lex:\")) {\n    return str;\n  }\n  if (str.startsWith(\"#\")) {\n    if (!baseUri) {\n      throw new Error(`Unable to resolve uri without anchor: ${str}`);\n    }\n    return `${baseUri}${str}`;\n  }\n  return `lex:${str}`;\n}\nfunction validateOneOf(lexicons2, path, def2, value, mustBeObj = false) {\n  let error;\n  let concreteDefs;\n  if (def2.type === \"union\") {\n    if (!isDiscriminatedObject(value)) {\n      return {\n        success: false,\n        error: new ValidationError(\n          `${path} must be an object which includes the \"$type\" property`\n        )\n      };\n    }\n    if (!def2.refs.includes(toLexUri(value.$type))) {\n      if (def2.closed) {\n        return {\n          success: false,\n          error: new ValidationError(\n            `${path} $type must be one of ${def2.refs.join(\", \")}`\n          )\n        };\n      }\n      return { success: true, value };\n    } else {\n      concreteDefs = toConcreteTypes(lexicons2, {\n        type: \"ref\",\n        ref: value.$type\n      });\n    }\n  } else {\n    concreteDefs = toConcreteTypes(lexicons2, def2);\n  }\n  for (const concreteDef of concreteDefs) {\n    const result = mustBeObj ? object(lexicons2, path, concreteDef, value) : validate2(lexicons2, path, concreteDef, value);\n    if (result.success) {\n      return result;\n    }\n    error ?? (error = result.error);\n  }\n  if (concreteDefs.length > 1) {\n    return {\n      success: false,\n      error: new ValidationError(\n        `${path} did not match any of the expected definitions`\n      )\n    };\n  }\n  return { success: false, error };\n}\nfunction assertValidOneOf(lexicons2, path, def2, value, mustBeObj = false) {\n  const res = validateOneOf(lexicons2, path, def2, value, mustBeObj);\n  if (!res.success)\n    throw res.error;\n  return res.value;\n}\nfunction toConcreteTypes(lexicons2, def2) {\n  if (def2.type === \"ref\") {\n    return [lexicons2.getDefOrThrow(def2.ref)];\n  } else if (def2.type === \"union\") {\n    return def2.refs.map((ref) => lexicons2.getDefOrThrow(ref)).flat();\n  } else {\n    return [def2];\n  }\n}\n\n// ../lexicon/src/validators/xrpc.ts\nfunction params(lexicons2, path, def2, val) {\n  const value = val && typeof val === \"object\" ? val : {};\n  const requiredProps = new Set(def2.required ?? []);\n  let resultValue = value;\n  if (typeof def2.properties === \"object\") {\n    for (const key in def2.properties) {\n      const propDef = def2.properties[key];\n      const validated = propDef.type === \"array\" ? array(lexicons2, key, propDef, value[key]) : validate(lexicons2, key, propDef, value[key]);\n      const propValue = validated.success ? validated.value : value[key];\n      const propIsUndefined = typeof propValue === \"undefined\";\n      if (propIsUndefined && requiredProps.has(key)) {\n        return {\n          success: false,\n          error: new ValidationError(`${path} must have the property \"${key}\"`)\n        };\n      } else if (!propIsUndefined && !validated.success) {\n        return validated;\n      }\n      if (propValue !== value[key]) {\n        if (resultValue === value) {\n          resultValue = { ...value };\n        }\n        resultValue[key] = propValue;\n      }\n    }\n  }\n  return { success: true, value: resultValue };\n}\n\n// ../lexicon/src/validation.ts\nfunction assertValidRecord(lexicons2, def2, value) {\n  const res = object(lexicons2, \"Record\", def2.record, value);\n  if (!res.success)\n    throw res.error;\n  return res.value;\n}\nfunction assertValidXrpcParams(lexicons2, def2, value) {\n  if (def2.parameters) {\n    const res = params(lexicons2, \"Params\", def2.parameters, value);\n    if (!res.success)\n      throw res.error;\n    return res.value;\n  }\n}\nfunction assertValidXrpcInput(lexicons2, def2, value) {\n  if (def2.input?.schema) {\n    return assertValidOneOf(lexicons2, \"Input\", def2.input.schema, value, true);\n  }\n}\nfunction assertValidXrpcOutput(lexicons2, def2, value) {\n  if (def2.output?.schema) {\n    return assertValidOneOf(lexicons2, \"Output\", def2.output.schema, value, true);\n  }\n}\nfunction assertValidXrpcMessage(lexicons2, def2, value) {\n  if (def2.message?.schema) {\n    return assertValidOneOf(\n      lexicons2,\n      \"Message\",\n      def2.message.schema,\n      value,\n      true\n    );\n  }\n}\n\n// ../lexicon/src/lexicons.ts\nvar Lexicons = class {\n  constructor(docs) {\n    this.docs = /* @__PURE__ */ new Map();\n    this.defs = /* @__PURE__ */ new Map();\n    if (docs?.length) {\n      for (const doc of docs) {\n        this.add(doc);\n      }\n    }\n  }\n  add(doc) {\n    try {\n      lexiconDoc.parse(doc);\n    } catch (e) {\n      if (e instanceof ZodError) {\n        throw new LexiconDocMalformedError(\n          `Failed to parse schema definition ${doc.id}`,\n          doc,\n          e.issues\n        );\n      } else {\n        throw e;\n      }\n    }\n    const validatedDoc = doc;\n    const uri2 = toLexUri(validatedDoc.id);\n    if (this.docs.has(uri2)) {\n      throw new Error(`${uri2} has already been registered`);\n    }\n    resolveRefUris(validatedDoc, uri2);\n    this.docs.set(uri2, validatedDoc);\n    for (const [defUri, def2] of iterDefs(validatedDoc)) {\n      this.defs.set(defUri, def2);\n    }\n  }\n  remove(uri2) {\n    uri2 = toLexUri(uri2);\n    const doc = this.docs.get(uri2);\n    if (!doc) {\n      throw new Error(`Unable to remove \"${uri2}\": does not exist`);\n    }\n    for (const [defUri, _def] of iterDefs(doc)) {\n      this.defs.delete(defUri);\n    }\n    this.docs.delete(uri2);\n  }\n  get(uri2) {\n    uri2 = toLexUri(uri2);\n    return this.docs.get(uri2);\n  }\n  getDef(uri2) {\n    uri2 = toLexUri(uri2);\n    return this.defs.get(uri2);\n  }\n  getDefOrThrow(uri2, types) {\n    const def2 = this.getDef(uri2);\n    if (!def2) {\n      throw new LexiconDefNotFoundError(`Lexicon not found: ${uri2}`);\n    }\n    if (types && !types.includes(def2.type)) {\n      throw new InvalidLexiconError(\n        `Not a ${types.join(\" or \")} lexicon: ${uri2}`\n      );\n    }\n    return def2;\n  }\n  validate(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"record\", \"object\"]);\n    if (!isObj(value)) {\n      throw new ValidationError(`Value must be an object`);\n    }\n    if (def2.type === \"record\") {\n      return object(this, \"Record\", def2.record, value);\n    } else if (def2.type === \"object\") {\n      return object(this, \"Object\", def2, value);\n    } else {\n      throw new InvalidLexiconError(\"Definition must be a record or object\");\n    }\n  }\n  assertValidRecord(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"record\"]);\n    if (!isObj(value)) {\n      throw new ValidationError(`Record must be an object`);\n    }\n    if (!hasProp(value, \"$type\") || typeof value.$type !== \"string\") {\n      throw new ValidationError(`Record/$type must be a string`);\n    }\n    const $type = value.$type || \"\";\n    if (toLexUri($type) !== lexUri) {\n      throw new ValidationError(\n        `Invalid $type: must be ${lexUri}, got ${$type}`\n      );\n    }\n    return assertValidRecord(this, def2, value);\n  }\n  assertValidXrpcParams(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\n      \"query\",\n      \"procedure\",\n      \"subscription\"\n    ]);\n    return assertValidXrpcParams(\n      this,\n      def2,\n      value\n    );\n  }\n  assertValidXrpcInput(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"procedure\"]);\n    return assertValidXrpcInput(this, def2, value);\n  }\n  assertValidXrpcOutput(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"query\", \"procedure\"]);\n    return assertValidXrpcOutput(\n      this,\n      def2,\n      value\n    );\n  }\n  assertValidXrpcMessage(lexUri, value) {\n    lexUri = toLexUri(lexUri);\n    const def2 = this.getDefOrThrow(lexUri, [\"subscription\"]);\n    return assertValidXrpcMessage(this, def2, value);\n  }\n  resolveLexUri(lexUri, ref) {\n    lexUri = toLexUri(lexUri);\n    return toLexUri(ref, lexUri);\n  }\n};\nfunction* iterDefs(doc) {\n  for (const defId in doc.defs) {\n    yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];\n    if (defId === \"main\") {\n      yield [`lex:${doc.id}`, doc.defs[defId]];\n    }\n  }\n}\nfunction resolveRefUris(obj, baseUri) {\n  for (const k in obj) {\n    if (obj.type === \"ref\") {\n      obj.ref = toLexUri(obj.ref, baseUri);\n    } else if (obj.type === \"union\") {\n      obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri));\n    } else if (Array.isArray(obj[k])) {\n      obj[k] = obj[k].map((item) => {\n        if (typeof item === \"string\") {\n          return item.startsWith(\"#\") ? toLexUri(item, baseUri) : item;\n        } else if (item && typeof item === \"object\") {\n          return resolveRefUris(item, baseUri);\n        }\n        return item;\n      });\n    } else if (obj[k] && typeof obj[k] === \"object\") {\n      obj[k] = resolveRefUris(obj[k], baseUri);\n    }\n  }\n  return obj;\n}\n\n// ../lexicon/src/serialize.ts\nvar lexToIpld = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => lexToIpld(item));\n  }\n  if (val && typeof val === \"object\") {\n    if (val instanceof BlobRef) {\n      return val.original;\n    }\n    if (CID.asCID(val) || val instanceof Uint8Array) {\n      return val;\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = lexToIpld(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\nvar ipldToLex = (val) => {\n  if (Array.isArray(val)) {\n    return val.map((item) => ipldToLex(item));\n  }\n  if (val && typeof val === \"object\") {\n    if ((val[\"$type\"] === \"blob\" || typeof val[\"cid\"] === \"string\" && typeof val[\"mimeType\"] === \"string\") && check_exports.is(val, jsonBlobRef)) {\n      return BlobRef.fromJsonRef(val);\n    }\n    if (CID.asCID(val) || val instanceof Uint8Array) {\n      return val;\n    }\n    const toReturn = {};\n    for (const key of Object.keys(val)) {\n      toReturn[key] = ipldToLex(val[key]);\n    }\n    return toReturn;\n  }\n  return val;\n};\nvar lexToJson = (val) => {\n  return ipldToJson(lexToIpld(val));\n};\nvar stringifyLex = (val) => {\n  return JSON.stringify(lexToJson(val));\n};\nvar jsonToLex = (val) => {\n  return ipldToLex(jsonToIpld(val));\n};\nvar jsonStringToLex = (val) => {\n  return jsonToLex(JSON.parse(val));\n};\n\n// ../xrpc/src/types.ts\nvar errorResponseBody = mod.object({\n  error: mod.string().optional(),\n  message: mod.string().optional()\n});\nvar ResponseType = /* @__PURE__ */ ((ResponseType2) => {\n  ResponseType2[ResponseType2[\"Unknown\"] = 1] = \"Unknown\";\n  ResponseType2[ResponseType2[\"InvalidResponse\"] = 2] = \"InvalidResponse\";\n  ResponseType2[ResponseType2[\"Success\"] = 200] = \"Success\";\n  ResponseType2[ResponseType2[\"InvalidRequest\"] = 400] = \"InvalidRequest\";\n  ResponseType2[ResponseType2[\"AuthRequired\"] = 401] = \"AuthRequired\";\n  ResponseType2[ResponseType2[\"Forbidden\"] = 403] = \"Forbidden\";\n  ResponseType2[ResponseType2[\"XRPCNotSupported\"] = 404] = \"XRPCNotSupported\";\n  ResponseType2[ResponseType2[\"PayloadTooLarge\"] = 413] = \"PayloadTooLarge\";\n  ResponseType2[ResponseType2[\"RateLimitExceeded\"] = 429] = \"RateLimitExceeded\";\n  ResponseType2[ResponseType2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  ResponseType2[ResponseType2[\"MethodNotImplemented\"] = 501] = \"MethodNotImplemented\";\n  ResponseType2[ResponseType2[\"UpstreamFailure\"] = 502] = \"UpstreamFailure\";\n  ResponseType2[ResponseType2[\"NotEnoughResouces\"] = 503] = \"NotEnoughResouces\";\n  ResponseType2[ResponseType2[\"UpstreamTimeout\"] = 504] = \"UpstreamTimeout\";\n  return ResponseType2;\n})(ResponseType || {});\nvar ResponseTypeNames = {\n  [2 /* InvalidResponse */]: \"InvalidResponse\",\n  [200 /* Success */]: \"Success\",\n  [400 /* InvalidRequest */]: \"InvalidRequest\",\n  [401 /* AuthRequired */]: \"AuthenticationRequired\",\n  [403 /* Forbidden */]: \"Forbidden\",\n  [404 /* XRPCNotSupported */]: \"XRPCNotSupported\",\n  [413 /* PayloadTooLarge */]: \"PayloadTooLarge\",\n  [429 /* RateLimitExceeded */]: \"RateLimitExceeded\",\n  [500 /* InternalServerError */]: \"InternalServerError\",\n  [501 /* MethodNotImplemented */]: \"MethodNotImplemented\",\n  [502 /* UpstreamFailure */]: \"UpstreamFailure\",\n  [503 /* NotEnoughResouces */]: \"NotEnoughResouces\",\n  [504 /* UpstreamTimeout */]: \"UpstreamTimeout\"\n};\nvar ResponseTypeStrings = {\n  [2 /* InvalidResponse */]: \"Invalid Response\",\n  [200 /* Success */]: \"Success\",\n  [400 /* InvalidRequest */]: \"Invalid Request\",\n  [401 /* AuthRequired */]: \"Authentication Required\",\n  [403 /* Forbidden */]: \"Forbidden\",\n  [404 /* XRPCNotSupported */]: \"XRPC Not Supported\",\n  [413 /* PayloadTooLarge */]: \"Payload Too Large\",\n  [429 /* RateLimitExceeded */]: \"Rate Limit Exceeded\",\n  [500 /* InternalServerError */]: \"Internal Server Error\",\n  [501 /* MethodNotImplemented */]: \"Method Not Implemented\",\n  [502 /* UpstreamFailure */]: \"Upstream Failure\",\n  [503 /* NotEnoughResouces */]: \"Not Enough Resouces\",\n  [504 /* UpstreamTimeout */]: \"Upstream Timeout\"\n};\nvar XRPCResponse = class {\n  constructor(data, headers) {\n    this.data = data;\n    this.headers = headers;\n    this.success = true;\n  }\n};\nvar XRPCError = class extends Error {\n  constructor(status, error, message) {\n    super(message || error || ResponseTypeStrings[status]);\n    this.status = status;\n    this.error = error;\n    this.success = false;\n    if (!this.error) {\n      this.error = ResponseTypeNames[status];\n    }\n  }\n};\nvar XRPCInvalidResponseError = class extends XRPCError {\n  constructor(lexiconNsid, validationError, responseBody) {\n    super(\n      2 /* InvalidResponse */,\n      ResponseTypeStrings[2 /* InvalidResponse */],\n      `The server gave an invalid response and may be out of date.`\n    );\n    this.lexiconNsid = lexiconNsid;\n    this.validationError = validationError;\n    this.responseBody = responseBody;\n  }\n};\n\n// ../xrpc/src/util.ts\nfunction getMethodSchemaHTTPMethod(schema2) {\n  if (schema2.type === \"procedure\") {\n    return \"post\";\n  }\n  return \"get\";\n}\nfunction constructMethodCallUri(nsid2, schema2, serviceUri, params2) {\n  const uri2 = new URL(serviceUri);\n  uri2.pathname = `/xrpc/${nsid2}`;\n  if (params2) {\n    for (const [key, value] of Object.entries(params2)) {\n      const paramSchema = schema2.parameters?.properties?.[key];\n      if (!paramSchema) {\n        throw new Error(`Invalid query parameter: ${key}`);\n      }\n      if (value !== void 0) {\n        if (paramSchema.type === \"array\") {\n          const vals = [];\n          vals.concat(value).forEach((val) => {\n            uri2.searchParams.append(\n              key,\n              encodeQueryParam(paramSchema.items.type, val)\n            );\n          });\n        } else {\n          uri2.searchParams.set(key, encodeQueryParam(paramSchema.type, value));\n        }\n      }\n    }\n  }\n  return uri2.toString();\n}\nfunction encodeQueryParam(type, value) {\n  if (type === \"string\" || type === \"unknown\") {\n    return String(value);\n  }\n  if (type === \"float\") {\n    return String(Number(value));\n  } else if (type === \"integer\") {\n    return String(Number(value) | 0);\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"datetime\") {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    return String(value);\n  }\n  throw new Error(`Unsupported query param type: ${type}`);\n}\nfunction constructMethodCallHeaders(schema2, data, opts) {\n  const headers = opts?.headers || {};\n  if (schema2.type === \"procedure\") {\n    if (opts?.encoding) {\n      headers[\"Content-Type\"] = opts.encoding;\n    }\n    if (data && typeof data === \"object\") {\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"application/json\";\n      }\n    }\n  }\n  return headers;\n}\nfunction encodeMethodCallBody(headers, data) {\n  if (!headers[\"Content-Type\"] || typeof data === \"undefined\") {\n    return void 0;\n  }\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n  if (headers[\"Content-Type\"].startsWith(\"text/\")) {\n    return new TextEncoder().encode(data.toString());\n  }\n  if (headers[\"Content-Type\"].startsWith(\"application/json\")) {\n    return new TextEncoder().encode(stringifyLex(data));\n  }\n  return data;\n}\nfunction httpResponseCodeToEnum(status) {\n  let resCode;\n  if (status in ResponseType) {\n    resCode = status;\n  } else if (status >= 100 && status < 200) {\n    resCode = 404 /* XRPCNotSupported */;\n  } else if (status >= 200 && status < 300) {\n    resCode = 200 /* Success */;\n  } else if (status >= 300 && status < 400) {\n    resCode = 404 /* XRPCNotSupported */;\n  } else if (status >= 400 && status < 500) {\n    resCode = 400 /* InvalidRequest */;\n  } else {\n    resCode = 500 /* InternalServerError */;\n  }\n  return resCode;\n}\nfunction httpResponseBodyParse(mimeType, data) {\n  if (mimeType) {\n    if (mimeType.includes(\"application/json\") && data?.byteLength) {\n      try {\n        const str = new TextDecoder().decode(data);\n        return jsonStringToLex(str);\n      } catch (e) {\n        throw new XRPCError(\n          2 /* InvalidResponse */,\n          `Failed to parse response body: ${String(e)}`\n        );\n      }\n    }\n    if (mimeType.startsWith(\"text/\") && data?.byteLength) {\n      try {\n        return new TextDecoder().decode(data);\n      } catch (e) {\n        throw new XRPCError(\n          2 /* InvalidResponse */,\n          `Failed to parse response body: ${String(e)}`\n        );\n      }\n    }\n  }\n  if (data instanceof ArrayBuffer) {\n    return new Uint8Array(data);\n  }\n  return data;\n}\n\n// ../xrpc/src/client.ts\nvar Client = class {\n  constructor() {\n    this.fetch = defaultFetchHandler;\n    this.lex = new Lexicons();\n  }\n  async call(serviceUri, methodNsid, params2, data, opts) {\n    return this.service(serviceUri).call(methodNsid, params2, data, opts);\n  }\n  service(serviceUri) {\n    return new ServiceClient(this, serviceUri);\n  }\n  addLexicon(doc) {\n    this.lex.add(doc);\n  }\n  addLexicons(docs) {\n    for (const doc of docs) {\n      this.addLexicon(doc);\n    }\n  }\n  removeLexicon(uri2) {\n    this.lex.remove(uri2);\n  }\n};\nvar ServiceClient = class {\n  constructor(baseClient, serviceUri) {\n    this.headers = {};\n    this.baseClient = baseClient;\n    this.uri = typeof serviceUri === \"string\" ? new URL(serviceUri) : serviceUri;\n  }\n  setHeader(key, value) {\n    this.headers[key] = value;\n  }\n  unsetHeader(key) {\n    delete this.headers[key];\n  }\n  async call(methodNsid, params2, data, opts) {\n    const def2 = this.baseClient.lex.getDefOrThrow(methodNsid);\n    if (!def2 || def2.type !== \"query\" && def2.type !== \"procedure\") {\n      throw new Error(\n        `Invalid lexicon: ${methodNsid}. Must be a query or procedure.`\n      );\n    }\n    const httpMethod = getMethodSchemaHTTPMethod(def2);\n    const httpUri = constructMethodCallUri(methodNsid, def2, this.uri, params2);\n    const httpHeaders = constructMethodCallHeaders(def2, data, {\n      headers: {\n        ...this.headers,\n        ...opts?.headers\n      },\n      encoding: opts?.encoding\n    });\n    const res = await this.baseClient.fetch(\n      httpUri,\n      httpMethod,\n      httpHeaders,\n      data\n    );\n    const resCode = httpResponseCodeToEnum(res.status);\n    if (resCode === 200 /* Success */) {\n      try {\n        this.baseClient.lex.assertValidXrpcOutput(methodNsid, res.body);\n      } catch (e) {\n        if (e instanceof ValidationError) {\n          throw new XRPCInvalidResponseError(methodNsid, e, res.body);\n        } else {\n          throw e;\n        }\n      }\n      return new XRPCResponse(res.body, res.headers);\n    } else {\n      if (res.body && isErrorResponseBody(res.body)) {\n        throw new XRPCError(resCode, res.body.error, res.body.message);\n      } else {\n        throw new XRPCError(resCode);\n      }\n    }\n  }\n};\nasync function defaultFetchHandler(httpUri, httpMethod, httpHeaders, httpReqBody) {\n  try {\n    const reqInit = {\n      method: httpMethod,\n      headers: httpHeaders,\n      body: encodeMethodCallBody(httpHeaders, httpReqBody),\n      duplex: \"half\"\n    };\n    const res = await fetch(httpUri, reqInit);\n    const resBody = await res.arrayBuffer();\n    return {\n      status: res.status,\n      headers: Object.fromEntries(res.headers.entries()),\n      body: httpResponseBodyParse(res.headers.get(\"content-type\"), resBody)\n    };\n  } catch (e) {\n    throw new XRPCError(1 /* Unknown */, String(e));\n  }\n}\nfunction isErrorResponseBody(v) {\n  return errorResponseBody.safeParse(v).success;\n}\n\n// ../xrpc/src/index.ts\nvar defaultInst = new Client();\n\n// src/client/lexicons.ts\nvar schemaDict = {\n  ComAtprotoAdminDefs: {\n    lexicon: 1,\n    id: \"com.atproto.admin.defs\",\n    defs: {\n      actionView: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"action\",\n          \"subject\",\n          \"subjectBlobCids\",\n          \"reason\",\n          \"createdBy\",\n          \"createdAt\",\n          \"resolvedReportIds\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          action: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionType\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoRef\",\n              \"lex:com.atproto.repo.strongRef\"\n            ]\n          },\n          subjectBlobCids: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          createLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          negateLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          reason: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          reversal: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionReversal\"\n          },\n          resolvedReportIds: {\n            type: \"array\",\n            items: {\n              type: \"integer\"\n            }\n          }\n        }\n      },\n      actionViewDetail: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"action\",\n          \"subject\",\n          \"subjectBlobs\",\n          \"reason\",\n          \"createdBy\",\n          \"createdAt\",\n          \"resolvedReports\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          action: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionType\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoView\",\n              \"lex:com.atproto.admin.defs#recordView\"\n            ]\n          },\n          subjectBlobs: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#blobView\"\n            }\n          },\n          createLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          negateLabelVals: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            }\n          },\n          reason: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          reversal: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionReversal\"\n          },\n          resolvedReports: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#reportView\"\n            }\n          }\n        }\n      },\n      actionViewCurrent: {\n        type: \"object\",\n        required: [\"id\", \"action\"],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          action: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionType\"\n          }\n        }\n      },\n      actionReversal: {\n        type: \"object\",\n        required: [\"reason\", \"createdBy\", \"createdAt\"],\n        properties: {\n          reason: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      actionType: {\n        type: \"string\",\n        knownValues: [\n          \"lex:com.atproto.admin.defs#takedown\",\n          \"lex:com.atproto.admin.defs#flag\",\n          \"lex:com.atproto.admin.defs#acknowledge\"\n        ]\n      },\n      takedown: {\n        type: \"token\",\n        description: \"Moderation action type: Takedown. Indicates that content should not be served by the PDS.\"\n      },\n      flag: {\n        type: \"token\",\n        description: \"Moderation action type: Flag. Indicates that the content was reviewed and considered to violate PDS rules, but may still be served.\"\n      },\n      acknowledge: {\n        type: \"token\",\n        description: \"Moderation action type: Acknowledge. Indicates that the content was reviewed and not considered to violate PDS rules.\"\n      },\n      reportView: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"reasonType\",\n          \"subject\",\n          \"reportedBy\",\n          \"createdAt\",\n          \"resolvedByActionIds\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          reasonType: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.moderation.defs#reasonType\"\n          },\n          reason: {\n            type: \"string\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoRef\",\n              \"lex:com.atproto.repo.strongRef\"\n            ]\n          },\n          reportedBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          resolvedByActionIds: {\n            type: \"array\",\n            items: {\n              type: \"integer\"\n            }\n          }\n        }\n      },\n      reportViewDetail: {\n        type: \"object\",\n        required: [\n          \"id\",\n          \"reasonType\",\n          \"subject\",\n          \"reportedBy\",\n          \"createdAt\",\n          \"resolvedByActions\"\n        ],\n        properties: {\n          id: {\n            type: \"integer\"\n          },\n          reasonType: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.moderation.defs#reasonType\"\n          },\n          reason: {\n            type: \"string\"\n          },\n          subject: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#repoView\",\n              \"lex:com.atproto.admin.defs#recordView\"\n            ]\n          },\n          reportedBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          resolvedByActions: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#actionView\"\n            }\n          }\n        }\n      },\n      repoView: {\n        type: \"object\",\n        required: [\n          \"did\",\n          \"handle\",\n          \"relatedRecords\",\n          \"indexedAt\",\n          \"moderation\"\n        ],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          email: {\n            type: \"string\"\n          },\n          relatedRecords: {\n            type: \"array\",\n            items: {\n              type: \"unknown\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderation\"\n          },\n          invitedBy: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.server.defs#inviteCode\"\n          }\n        }\n      },\n      repoViewDetail: {\n        type: \"object\",\n        required: [\n          \"did\",\n          \"handle\",\n          \"relatedRecords\",\n          \"indexedAt\",\n          \"moderation\"\n        ],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          email: {\n            type: \"string\"\n          },\n          relatedRecords: {\n            type: \"array\",\n            items: {\n              type: \"unknown\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderationDetail\"\n          },\n          invitedBy: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.server.defs#inviteCode\"\n          },\n          invites: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.server.defs#inviteCode\"\n            }\n          }\n        }\n      },\n      repoRef: {\n        type: \"object\",\n        required: [\"did\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          }\n        }\n      },\n      recordView: {\n        type: \"object\",\n        required: [\n          \"uri\",\n          \"cid\",\n          \"value\",\n          \"blobCids\",\n          \"indexedAt\",\n          \"moderation\",\n          \"repo\"\n        ],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          value: {\n            type: \"unknown\"\n          },\n          blobCids: {\n            type: \"array\",\n            items: {\n              type: \"string\",\n              format: \"cid\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderation\"\n          },\n          repo: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#repoView\"\n          }\n        }\n      },\n      recordViewDetail: {\n        type: \"object\",\n        required: [\n          \"uri\",\n          \"cid\",\n          \"value\",\n          \"blobs\",\n          \"indexedAt\",\n          \"moderation\",\n          \"repo\"\n        ],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          value: {\n            type: \"unknown\"\n          },\n          blobs: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#blobView\"\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderationDetail\"\n          },\n          repo: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#repoView\"\n          }\n        }\n      },\n      moderation: {\n        type: \"object\",\n        required: [],\n        properties: {\n          currentAction: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionViewCurrent\"\n          }\n        }\n      },\n      moderationDetail: {\n        type: \"object\",\n        required: [\"actions\", \"reports\"],\n        properties: {\n          currentAction: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionViewCurrent\"\n          },\n          actions: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#actionView\"\n            }\n          },\n          reports: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.admin.defs#reportView\"\n            }\n          }\n        }\n      },\n      blobView: {\n        type: \"object\",\n        required: [\"cid\", \"mimeType\", \"size\", \"createdAt\"],\n        properties: {\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          mimeType: {\n            type: \"string\"\n          },\n          size: {\n            type: \"integer\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          details: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.admin.defs#imageDetails\",\n              \"lex:com.atproto.admin.defs#videoDetails\"\n            ]\n          },\n          moderation: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#moderation\"\n          }\n        }\n      },\n      imageDetails: {\n        type: \"object\",\n        required: [\"width\", \"height\"],\n        properties: {\n          width: {\n            type: \"integer\"\n          },\n          height: {\n            type: \"integer\"\n          }\n        }\n      },\n      videoDetails: {\n        type: \"object\",\n        required: [\"width\", \"height\", \"length\"],\n        properties: {\n          width: {\n            type: \"integer\"\n          },\n          height: {\n            type: \"integer\"\n          },\n          length: {\n            type: \"integer\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminDisableInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.admin.disableInviteCodes\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Disable some set of codes and/or all codes associated with a set of users\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            properties: {\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              accounts: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getInviteCodes\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Admin view of invite codes\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            sort: {\n              type: \"string\",\n              knownValues: [\"recent\", \"usage\"],\n              default: \"recent\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 500,\n              default: 100\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codes\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.server.defs#inviteCode\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationAction: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationAction\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a moderation action.\",\n        parameters: {\n          type: \"params\",\n          required: [\"id\"],\n          properties: {\n            id: {\n              type: \"integer\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationActions: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationActions\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List moderation actions related to a subject.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            subject: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actions\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              actions: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.admin.defs#actionView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationReport: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationReport\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a moderation report.\",\n        parameters: {\n          type: \"params\",\n          required: [\"id\"],\n          properties: {\n            id: {\n              type: \"integer\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#reportViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetModerationReports: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getModerationReports\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List moderation reports related to a subject.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            subject: {\n              type: \"string\"\n            },\n            resolved: {\n              type: \"boolean\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"reports\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              reports: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.admin.defs#reportView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetRecord: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getRecord\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a record.\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#recordViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminGetRepo: {\n    lexicon: 1,\n    id: \"com.atproto.admin.getRepo\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"View details about a repository.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#repoViewDetail\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminResolveModerationReports: {\n    lexicon: 1,\n    id: \"com.atproto.admin.resolveModerationReports\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Resolve moderation reports by an action.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actionId\", \"reportIds\", \"createdBy\"],\n            properties: {\n              actionId: {\n                type: \"integer\"\n              },\n              reportIds: {\n                type: \"array\",\n                items: {\n                  type: \"integer\"\n                }\n              },\n              createdBy: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionView\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminReverseModerationAction: {\n    lexicon: 1,\n    id: \"com.atproto.admin.reverseModerationAction\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Reverse a moderation action.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"id\", \"reason\", \"createdBy\"],\n            properties: {\n              id: {\n                type: \"integer\"\n              },\n              reason: {\n                type: \"string\"\n              },\n              createdBy: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionView\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminSearchRepos: {\n    lexicon: 1,\n    id: \"com.atproto.admin.searchRepos\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find repositories based on a search term.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            term: {\n              type: \"string\"\n            },\n            invitedBy: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repos\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              repos: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.admin.defs#repoView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoAdminTakeModerationAction: {\n    lexicon: 1,\n    id: \"com.atproto.admin.takeModerationAction\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Take a moderation action on a repo.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"action\", \"subject\", \"reason\", \"createdBy\"],\n            properties: {\n              action: {\n                type: \"string\",\n                knownValues: [\n                  \"com.atproto.admin.defs#takedown\",\n                  \"com.atproto.admin.defs#flag\",\n                  \"com.atproto.admin.defs#acknowledge\"\n                ]\n              },\n              subject: {\n                type: \"union\",\n                refs: [\n                  \"lex:com.atproto.admin.defs#repoRef\",\n                  \"lex:com.atproto.repo.strongRef\"\n                ]\n              },\n              subjectBlobCids: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"cid\"\n                }\n              },\n              createLabelVals: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              negateLabelVals: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              reason: {\n                type: \"string\"\n              },\n              createdBy: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.admin.defs#actionView\"\n          }\n        },\n        errors: [\n          {\n            name: \"SubjectHasAction\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoAdminUpdateAccountHandle: {\n    lexicon: 1,\n    id: \"com.atproto.admin.updateAccountHandle\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Administrative action to update an accounts handle\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"did\", \"handle\"],\n            properties: {\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoIdentityResolveHandle: {\n    lexicon: 1,\n    id: \"com.atproto.identity.resolveHandle\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Provides the DID of a repo.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            handle: {\n              type: \"string\",\n              format: \"handle\",\n              description: \"The handle to resolve. If not supplied, will resolve the host's own handle.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"did\"],\n            properties: {\n              did: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoIdentityUpdateHandle: {\n    lexicon: 1,\n    id: \"com.atproto.identity.updateHandle\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Updates the handle of the account\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"handle\"],\n            properties: {\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoLabelDefs: {\n    lexicon: 1,\n    id: \"com.atproto.label.defs\",\n    defs: {\n      label: {\n        type: \"object\",\n        description: \"Metadata tag on an atproto resource (eg, repo or record)\",\n        required: [\"src\", \"uri\", \"val\", \"cts\"],\n        properties: {\n          src: {\n            type: \"string\",\n            format: \"did\",\n            description: \"DID of the actor who created this label\"\n          },\n          uri: {\n            type: \"string\",\n            format: \"uri\",\n            description: \"AT URI of the record, repository (account), or other resource which this label applies to\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\",\n            description: \"optionally, CID specifying the specific version of 'uri' resource this label applies to\"\n          },\n          val: {\n            type: \"string\",\n            maxLength: 128,\n            description: \"the short string name of the value or type of this label\"\n          },\n          neg: {\n            type: \"boolean\",\n            description: \"if true, this is a negation label, overwriting a previous label\"\n          },\n          cts: {\n            type: \"string\",\n            format: \"datetime\",\n            description: \"timestamp when this label was created\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoLabelQueryLabels: {\n    lexicon: 1,\n    id: \"com.atproto.label.queryLabels\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find labels relevant to the provided URI patterns.\",\n        parameters: {\n          type: \"params\",\n          required: [\"uriPatterns\"],\n          properties: {\n            uriPatterns: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              },\n              description: \"List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI\"\n            },\n            sources: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"did\"\n              },\n              description: \"Optional list of label sources (DIDs) to filter on\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 250,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"labels\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              labels: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.label.defs#label\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoLabelSubscribeLabels: {\n    lexicon: 1,\n    id: \"com.atproto.label.subscribeLabels\",\n    defs: {\n      main: {\n        type: \"subscription\",\n        description: \"Subscribe to label updates\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            cursor: {\n              type: \"integer\",\n              description: \"The last known event to backfill from.\"\n            }\n          }\n        },\n        message: {\n          schema: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.label.subscribeLabels#labels\",\n              \"lex:com.atproto.label.subscribeLabels#info\"\n            ]\n          }\n        },\n        errors: [\n          {\n            name: \"FutureCursor\"\n          }\n        ]\n      },\n      labels: {\n        type: \"object\",\n        required: [\"seq\", \"labels\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      info: {\n        type: \"object\",\n        required: [\"name\"],\n        properties: {\n          name: {\n            type: \"string\",\n            knownValues: [\"OutdatedCursor\"]\n          },\n          message: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoModerationCreateReport: {\n    lexicon: 1,\n    id: \"com.atproto.moderation.createReport\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Report a repo or a record.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"reasonType\", \"subject\"],\n            properties: {\n              reasonType: {\n                type: \"ref\",\n                ref: \"lex:com.atproto.moderation.defs#reasonType\"\n              },\n              reason: {\n                type: \"string\"\n              },\n              subject: {\n                type: \"union\",\n                refs: [\n                  \"lex:com.atproto.admin.defs#repoRef\",\n                  \"lex:com.atproto.repo.strongRef\"\n                ]\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\n              \"id\",\n              \"reasonType\",\n              \"subject\",\n              \"reportedBy\",\n              \"createdAt\"\n            ],\n            properties: {\n              id: {\n                type: \"integer\"\n              },\n              reasonType: {\n                type: \"ref\",\n                ref: \"lex:com.atproto.moderation.defs#reasonType\"\n              },\n              reason: {\n                type: \"string\"\n              },\n              subject: {\n                type: \"union\",\n                refs: [\n                  \"lex:com.atproto.admin.defs#repoRef\",\n                  \"lex:com.atproto.repo.strongRef\"\n                ]\n              },\n              reportedBy: {\n                type: \"string\",\n                format: \"did\"\n              },\n              createdAt: {\n                type: \"string\",\n                format: \"datetime\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoModerationDefs: {\n    lexicon: 1,\n    id: \"com.atproto.moderation.defs\",\n    defs: {\n      reasonType: {\n        type: \"string\",\n        knownValues: [\n          \"com.atproto.moderation.defs#reasonSpam\",\n          \"com.atproto.moderation.defs#reasonOther\"\n        ]\n      },\n      reasonSpam: {\n        type: \"token\",\n        description: \"Moderation report reason: Spam.\"\n      },\n      reasonOther: {\n        type: \"token\",\n        description: \"Moderation report reason: Other.\"\n      }\n    }\n  },\n  ComAtprotoRepoApplyWrites: {\n    lexicon: 1,\n    id: \"com.atproto.repo.applyWrites\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Apply a batch transaction of creates, updates, and deletes.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"writes\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              validate: {\n                type: \"boolean\",\n                default: true,\n                description: \"Validate the records?\"\n              },\n              writes: {\n                type: \"array\",\n                items: {\n                  type: \"union\",\n                  refs: [\n                    \"lex:com.atproto.repo.applyWrites#create\",\n                    \"lex:com.atproto.repo.applyWrites#update\",\n                    \"lex:com.atproto.repo.applyWrites#delete\"\n                  ],\n                  closed: true\n                }\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      },\n      create: {\n        type: \"object\",\n        description: \"Create a new record.\",\n        required: [\"action\", \"collection\", \"value\"],\n        properties: {\n          collection: {\n            type: \"string\",\n            format: \"nsid\"\n          },\n          rkey: {\n            type: \"string\"\n          },\n          value: {\n            type: \"unknown\"\n          }\n        }\n      },\n      update: {\n        type: \"object\",\n        description: \"Update an existing record.\",\n        required: [\"action\", \"collection\", \"rkey\", \"value\"],\n        properties: {\n          collection: {\n            type: \"string\",\n            format: \"nsid\"\n          },\n          rkey: {\n            type: \"string\"\n          },\n          value: {\n            type: \"unknown\"\n          }\n        }\n      },\n      delete: {\n        type: \"object\",\n        description: \"Delete an existing record.\",\n        required: [\"action\", \"collection\", \"rkey\"],\n        properties: {\n          collection: {\n            type: \"string\",\n            format: \"nsid\"\n          },\n          rkey: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoCreateRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.createRecord\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create a new record.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"collection\", \"record\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              collection: {\n                type: \"string\",\n                format: \"nsid\",\n                description: \"The NSID of the record collection.\"\n              },\n              rkey: {\n                type: \"string\",\n                description: \"The key of the record.\"\n              },\n              validate: {\n                type: \"boolean\",\n                default: true,\n                description: \"Validate the record?\"\n              },\n              record: {\n                type: \"unknown\",\n                description: \"The record to create.\"\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous commit by cid.\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"cid\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoRepoDeleteRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.deleteRecord\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Delete a record, or ensure it doesn't exist.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"collection\", \"rkey\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              collection: {\n                type: \"string\",\n                format: \"nsid\",\n                description: \"The NSID of the record collection.\"\n              },\n              rkey: {\n                type: \"string\",\n                description: \"The key of the record.\"\n              },\n              swapRecord: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous record by cid.\"\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous commit by cid.\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoRepoDescribeRepo: {\n    lexicon: 1,\n    id: \"com.atproto.repo.describeRepo\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get information about the repo, including the list of collections.\",\n        parameters: {\n          type: \"params\",\n          required: [\"repo\"],\n          properties: {\n            repo: {\n              type: \"string\",\n              format: \"at-identifier\",\n              description: \"The handle or DID of the repo.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\n              \"handle\",\n              \"did\",\n              \"didDoc\",\n              \"collections\",\n              \"handleIsCorrect\"\n            ],\n            properties: {\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              didDoc: {\n                type: \"unknown\"\n              },\n              collections: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"nsid\"\n                }\n              },\n              handleIsCorrect: {\n                type: \"boolean\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoGetRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.getRecord\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a record.\",\n        parameters: {\n          type: \"params\",\n          required: [\"repo\", \"collection\", \"rkey\"],\n          properties: {\n            repo: {\n              type: \"string\",\n              format: \"at-identifier\",\n              description: \"The handle or DID of the repo.\"\n            },\n            collection: {\n              type: \"string\",\n              format: \"nsid\",\n              description: \"The NSID of the record collection.\"\n            },\n            rkey: {\n              type: \"string\",\n              description: \"The key of the record.\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The CID of the version of the record. If not specified, then return the most recent version.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"value\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              },\n              value: {\n                type: \"unknown\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoListRecords: {\n    lexicon: 1,\n    id: \"com.atproto.repo.listRecords\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List a range of records in a collection.\",\n        parameters: {\n          type: \"params\",\n          required: [\"repo\", \"collection\"],\n          properties: {\n            repo: {\n              type: \"string\",\n              format: \"at-identifier\",\n              description: \"The handle or DID of the repo.\"\n            },\n            collection: {\n              type: \"string\",\n              format: \"nsid\",\n              description: \"The NSID of the record type.\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50,\n              description: \"The number of records to return.\"\n            },\n            cursor: {\n              type: \"string\"\n            },\n            rkeyStart: {\n              type: \"string\",\n              description: \"DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)\"\n            },\n            rkeyEnd: {\n              type: \"string\",\n              description: \"DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)\"\n            },\n            reverse: {\n              type: \"boolean\",\n              description: \"Reverse the order of the returned records?\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"records\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              records: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.repo.listRecords#record\"\n                }\n              }\n            }\n          }\n        }\n      },\n      record: {\n        type: \"object\",\n        required: [\"uri\", \"cid\", \"value\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          value: {\n            type: \"unknown\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoPutRecord: {\n    lexicon: 1,\n    id: \"com.atproto.repo.putRecord\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Write a record, creating or updating it as needed.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repo\", \"collection\", \"rkey\", \"record\"],\n            nullable: [\"swapRecord\"],\n            properties: {\n              repo: {\n                type: \"string\",\n                format: \"at-identifier\",\n                description: \"The handle or DID of the repo.\"\n              },\n              collection: {\n                type: \"string\",\n                format: \"nsid\",\n                description: \"The NSID of the record collection.\"\n              },\n              rkey: {\n                type: \"string\",\n                description: \"The key of the record.\"\n              },\n              validate: {\n                type: \"boolean\",\n                default: true,\n                description: \"Validate the record?\"\n              },\n              record: {\n                type: \"unknown\",\n                description: \"The record to write.\"\n              },\n              swapRecord: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous record by cid.\"\n              },\n              swapCommit: {\n                type: \"string\",\n                format: \"cid\",\n                description: \"Compare and swap with the previous commit by cid.\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"cid\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidSwap\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoRepoStrongRef: {\n    lexicon: 1,\n    id: \"com.atproto.repo.strongRef\",\n    description: \"A URI with a content-hash fingerprint.\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"uri\", \"cid\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoRepoUploadBlob: {\n    lexicon: 1,\n    id: \"com.atproto.repo.uploadBlob\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Upload a new blob to be added to repo in a later request.\",\n        input: {\n          encoding: \"*/*\"\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"blob\"],\n            properties: {\n              blob: {\n                type: \"blob\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateAccount: {\n    lexicon: 1,\n    id: \"com.atproto.server.createAccount\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an account.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"handle\", \"email\", \"password\"],\n            properties: {\n              email: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              inviteCode: {\n                type: \"string\"\n              },\n              password: {\n                type: \"string\"\n              },\n              recoveryKey: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"accessJwt\", \"refreshJwt\", \"handle\", \"did\"],\n            properties: {\n              accessJwt: {\n                type: \"string\"\n              },\n              refreshJwt: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"InvalidHandle\"\n          },\n          {\n            name: \"InvalidPassword\"\n          },\n          {\n            name: \"InvalidInviteCode\"\n          },\n          {\n            name: \"HandleNotAvailable\"\n          },\n          {\n            name: \"UnsupportedDomain\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerCreateInviteCode: {\n    lexicon: 1,\n    id: \"com.atproto.server.createInviteCode\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an invite code.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"useCount\"],\n            properties: {\n              useCount: {\n                type: \"integer\"\n              },\n              forAccount: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"code\"],\n            properties: {\n              code: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.server.createInviteCodes\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an invite code.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codeCount\", \"useCount\"],\n            properties: {\n              codeCount: {\n                type: \"integer\",\n                default: 1\n              },\n              useCount: {\n                type: \"integer\"\n              },\n              forAccount: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codes\"],\n            properties: {\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerCreateSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.createSession\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Create an authentication session.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"identifier\", \"password\"],\n            properties: {\n              identifier: {\n                type: \"string\",\n                description: \"Handle or other identifier supported by the server for the authenticating user.\"\n              },\n              password: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"accessJwt\", \"refreshJwt\", \"handle\", \"did\"],\n            properties: {\n              accessJwt: {\n                type: \"string\"\n              },\n              refreshJwt: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"AccountTakedown\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerDefs: {\n    lexicon: 1,\n    id: \"com.atproto.server.defs\",\n    defs: {\n      inviteCode: {\n        type: \"object\",\n        required: [\n          \"code\",\n          \"available\",\n          \"disabled\",\n          \"forAccount\",\n          \"createdBy\",\n          \"createdAt\",\n          \"uses\"\n        ],\n        properties: {\n          code: {\n            type: \"string\"\n          },\n          available: {\n            type: \"integer\"\n          },\n          disabled: {\n            type: \"boolean\"\n          },\n          forAccount: {\n            type: \"string\"\n          },\n          createdBy: {\n            type: \"string\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          uses: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.server.defs#inviteCodeUse\"\n            }\n          }\n        }\n      },\n      inviteCodeUse: {\n        type: \"object\",\n        required: [\"usedBy\", \"usedAt\"],\n        properties: {\n          usedBy: {\n            type: \"string\",\n            format: \"did\"\n          },\n          usedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerDeleteAccount: {\n    lexicon: 1,\n    id: \"com.atproto.server.deleteAccount\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Delete a user account with a token and password.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"did\", \"password\", \"token\"],\n            properties: {\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              password: {\n                type: \"string\"\n              },\n              token: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"ExpiredToken\"\n          },\n          {\n            name: \"InvalidToken\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerDeleteSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.deleteSession\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Delete the current session.\"\n      }\n    }\n  },\n  ComAtprotoServerDescribeServer: {\n    lexicon: 1,\n    id: \"com.atproto.server.describeServer\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a document describing the service's accounts configuration.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"availableUserDomains\"],\n            properties: {\n              inviteCodeRequired: {\n                type: \"boolean\"\n              },\n              availableUserDomains: {\n                type: \"array\",\n                items: {\n                  type: \"string\"\n                }\n              },\n              links: {\n                type: \"ref\",\n                ref: \"lex:com.atproto.server.describeServer#links\"\n              }\n            }\n          }\n        }\n      },\n      links: {\n        type: \"object\",\n        properties: {\n          privacyPolicy: {\n            type: \"string\"\n          },\n          termsOfService: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerGetAccountInviteCodes: {\n    lexicon: 1,\n    id: \"com.atproto.server.getAccountInviteCodes\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get all invite codes for a given account\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            includeUsed: {\n              type: \"boolean\",\n              default: true\n            },\n            createAvailable: {\n              type: \"boolean\",\n              default: true\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"codes\"],\n            properties: {\n              codes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.server.defs#inviteCode\"\n                }\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"DuplicateCreate\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerGetSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.getSession\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get information about the current session.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"handle\", \"did\"],\n            properties: {\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              },\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerRefreshSession: {\n    lexicon: 1,\n    id: \"com.atproto.server.refreshSession\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Refresh an authentication session.\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"accessJwt\", \"refreshJwt\", \"handle\", \"did\"],\n            properties: {\n              accessJwt: {\n                type: \"string\"\n              },\n              refreshJwt: {\n                type: \"string\"\n              },\n              handle: {\n                type: \"string\",\n                format: \"handle\"\n              },\n              did: {\n                type: \"string\",\n                format: \"did\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"AccountTakedown\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoServerRequestAccountDelete: {\n    lexicon: 1,\n    id: \"com.atproto.server.requestAccountDelete\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Initiate a user account deletion via email.\"\n      }\n    }\n  },\n  ComAtprotoServerRequestPasswordReset: {\n    lexicon: 1,\n    id: \"com.atproto.server.requestPasswordReset\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Initiate a user account password reset via email.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"email\"],\n            properties: {\n              email: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoServerResetPassword: {\n    lexicon: 1,\n    id: \"com.atproto.server.resetPassword\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Reset a user account password using a token.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"token\", \"password\"],\n            properties: {\n              token: {\n                type: \"string\"\n              },\n              password: {\n                type: \"string\"\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"ExpiredToken\"\n          },\n          {\n            name: \"InvalidToken\"\n          }\n        ]\n      }\n    }\n  },\n  ComAtprotoSyncGetBlob: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getBlob\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a blob associated with a given repo.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\", \"cid\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The CID of the blob to fetch\"\n            }\n          }\n        },\n        output: {\n          encoding: \"*/*\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetBlocks: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getBlocks\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets blocks from a given repo.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\", \"cids\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            cids: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetCheckout: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getCheckout\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the repo state.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            commit: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The commit to get the checkout from. Defaults to current HEAD.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetCommitPath: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getCommitPath\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the path of repo commits\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            latest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The most recent commit\"\n            },\n            earliest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The earliest commit to start from\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"commits\"],\n            properties: {\n              commits: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"cid\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetHead: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getHead\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the current HEAD CID of a repo.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"root\"],\n            properties: {\n              root: {\n                type: \"string\",\n                format: \"cid\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetRecord: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getRecord\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets blocks needed for existence or non-existence of record.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\", \"collection\", \"rkey\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            collection: {\n              type: \"string\",\n              format: \"nsid\"\n            },\n            rkey: {\n              type: \"string\"\n            },\n            commit: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"An optional past commit CID.\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncGetRepo: {\n    lexicon: 1,\n    id: \"com.atproto.sync.getRepo\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Gets the repo state.\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            earliest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The earliest commit in the commit range (not inclusive)\"\n            },\n            latest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The latest commit you in the commit range (inclusive\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/vnd.ipld.car\"\n        }\n      }\n    }\n  },\n  ComAtprotoSyncListBlobs: {\n    lexicon: 1,\n    id: \"com.atproto.sync.listBlobs\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List blob cids for some range of commits\",\n        parameters: {\n          type: \"params\",\n          required: [\"did\"],\n          properties: {\n            did: {\n              type: \"string\",\n              format: \"did\",\n              description: \"The DID of the repo.\"\n            },\n            latest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The most recent commit\"\n            },\n            earliest: {\n              type: \"string\",\n              format: \"cid\",\n              description: \"The earliest commit to start from\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"cids\"],\n            properties: {\n              cids: {\n                type: \"array\",\n                items: {\n                  type: \"string\",\n                  format: \"cid\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncListRepos: {\n    lexicon: 1,\n    id: \"com.atproto.sync.listRepos\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"List dids and root cids of hosted repos\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 1e3,\n              default: 500\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"repos\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              repos: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:com.atproto.sync.listRepos#repo\"\n                }\n              }\n            }\n          }\n        }\n      },\n      repo: {\n        type: \"object\",\n        required: [\"did\", \"head\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          head: {\n            type: \"string\",\n            format: \"cid\"\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncNotifyOfUpdate: {\n    lexicon: 1,\n    id: \"com.atproto.sync.notifyOfUpdate\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Notify a crawling service of a recent update. Often when a long break between updates causes the connection with the crawling service to break.\",\n        parameters: {\n          type: \"params\",\n          required: [\"hostname\"],\n          properties: {\n            hostname: {\n              type: \"string\",\n              description: \"Hostname of the service that is notifying of update.\"\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncRequestCrawl: {\n    lexicon: 1,\n    id: \"com.atproto.sync.requestCrawl\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Request a service to persistently crawl hosted repos.\",\n        parameters: {\n          type: \"params\",\n          required: [\"hostname\"],\n          properties: {\n            hostname: {\n              type: \"string\",\n              description: \"Hostname of the service that is requesting to be crawled.\"\n            }\n          }\n        }\n      }\n    }\n  },\n  ComAtprotoSyncSubscribeRepos: {\n    lexicon: 1,\n    id: \"com.atproto.sync.subscribeRepos\",\n    defs: {\n      main: {\n        type: \"subscription\",\n        description: \"Subscribe to repo updates\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            cursor: {\n              type: \"integer\",\n              description: \"The last known event to backfill from.\"\n            }\n          }\n        },\n        message: {\n          schema: {\n            type: \"union\",\n            refs: [\n              \"lex:com.atproto.sync.subscribeRepos#commit\",\n              \"lex:com.atproto.sync.subscribeRepos#handle\",\n              \"lex:com.atproto.sync.subscribeRepos#migrate\",\n              \"lex:com.atproto.sync.subscribeRepos#tombstone\",\n              \"lex:com.atproto.sync.subscribeRepos#info\"\n            ]\n          }\n        },\n        errors: [\n          {\n            name: \"FutureCursor\"\n          }\n        ]\n      },\n      commit: {\n        type: \"object\",\n        required: [\n          \"seq\",\n          \"rebase\",\n          \"tooBig\",\n          \"repo\",\n          \"commit\",\n          \"prev\",\n          \"blocks\",\n          \"ops\",\n          \"blobs\",\n          \"time\"\n        ],\n        nullable: [\"prev\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          rebase: {\n            type: \"boolean\"\n          },\n          tooBig: {\n            type: \"boolean\"\n          },\n          repo: {\n            type: \"string\",\n            format: \"did\"\n          },\n          commit: {\n            type: \"cid-link\"\n          },\n          prev: {\n            type: \"cid-link\"\n          },\n          blocks: {\n            type: \"bytes\",\n            description: \"CAR file containing relevant blocks\",\n            maxLength: 1e6\n          },\n          ops: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.sync.subscribeRepos#repoOp\"\n            },\n            maxLength: 200\n          },\n          blobs: {\n            type: \"array\",\n            items: {\n              type: \"cid-link\"\n            }\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      handle: {\n        type: \"object\",\n        required: [\"seq\", \"did\", \"handle\", \"time\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      migrate: {\n        type: \"object\",\n        required: [\"seq\", \"did\", \"migrateTo\", \"time\"],\n        nullable: [\"migrateTo\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          migrateTo: {\n            type: \"string\"\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      tombstone: {\n        type: \"object\",\n        required: [\"seq\", \"did\", \"time\"],\n        properties: {\n          seq: {\n            type: \"integer\"\n          },\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          time: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      info: {\n        type: \"object\",\n        required: [\"name\"],\n        properties: {\n          name: {\n            type: \"string\",\n            knownValues: [\"OutdatedCursor\"]\n          },\n          message: {\n            type: \"string\"\n          }\n        }\n      },\n      repoOp: {\n        type: \"object\",\n        required: [\"action\", \"path\", \"cid\"],\n        nullable: [\"cid\"],\n        properties: {\n          action: {\n            type: \"string\",\n            knownValues: [\"create\", \"update\", \"delete\"]\n          },\n          path: {\n            type: \"string\"\n          },\n          cid: {\n            type: \"cid-link\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorDefs: {\n    lexicon: 1,\n    id: \"app.bsky.actor.defs\",\n    description: \"A reference to an actor in the network.\",\n    defs: {\n      profileViewBasic: {\n        type: \"object\",\n        required: [\"did\", \"handle\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          displayName: {\n            type: \"string\",\n            maxGraphemes: 64,\n            maxLength: 640\n          },\n          avatar: {\n            type: \"string\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      profileView: {\n        type: \"object\",\n        required: [\"did\", \"handle\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          displayName: {\n            type: \"string\",\n            maxGraphemes: 64,\n            maxLength: 640\n          },\n          description: {\n            type: \"string\",\n            maxGraphemes: 256,\n            maxLength: 2560\n          },\n          avatar: {\n            type: \"string\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      profileViewDetailed: {\n        type: \"object\",\n        required: [\"did\", \"handle\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          },\n          handle: {\n            type: \"string\",\n            format: \"handle\"\n          },\n          displayName: {\n            type: \"string\",\n            maxGraphemes: 64,\n            maxLength: 640\n          },\n          description: {\n            type: \"string\",\n            maxGraphemes: 256,\n            maxLength: 2560\n          },\n          avatar: {\n            type: \"string\"\n          },\n          banner: {\n            type: \"string\"\n          },\n          followersCount: {\n            type: \"integer\"\n          },\n          followsCount: {\n            type: \"integer\"\n          },\n          postsCount: {\n            type: \"integer\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      viewerState: {\n        type: \"object\",\n        properties: {\n          muted: {\n            type: \"boolean\"\n          },\n          following: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          followedBy: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorGetProfile: {\n    lexicon: 1,\n    id: \"app.bsky.actor.getProfile\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewDetailed\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorGetProfiles: {\n    lexicon: 1,\n    id: \"app.bsky.actor.getProfiles\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"actors\"],\n          properties: {\n            actors: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"at-identifier\"\n              },\n              maxLength: 25\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"profiles\"],\n            properties: {\n              profiles: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileViewDetailed\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorGetSuggestions: {\n    lexicon: 1,\n    id: \"app.bsky.actor.getSuggestions\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Get a list of actors suggested for following. Used in discovery UIs.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actors\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              actors: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorProfile: {\n    lexicon: 1,\n    id: \"app.bsky.actor.profile\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"literal:self\",\n        record: {\n          type: \"object\",\n          properties: {\n            displayName: {\n              type: \"string\",\n              maxGraphemes: 64,\n              maxLength: 640\n            },\n            description: {\n              type: \"string\",\n              maxGraphemes: 256,\n              maxLength: 2560\n            },\n            avatar: {\n              type: \"blob\",\n              accept: [\"image/png\", \"image/jpeg\"],\n              maxSize: 1e6\n            },\n            banner: {\n              type: \"blob\",\n              accept: [\"image/png\", \"image/jpeg\"],\n              maxSize: 1e6\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorSearchActors: {\n    lexicon: 1,\n    id: \"app.bsky.actor.searchActors\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find actors matching search criteria.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            term: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actors\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              actors: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyActorSearchActorsTypeahead: {\n    lexicon: 1,\n    id: \"app.bsky.actor.searchActorsTypeahead\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Find actor suggestions for a search term.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            term: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actors\"],\n            properties: {\n              actors: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedExternal: {\n    lexicon: 1,\n    id: \"app.bsky.embed.external\",\n    description: \"A representation of some externally linked content, embedded in another form of content\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"external\"],\n        properties: {\n          external: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.external#external\"\n          }\n        }\n      },\n      external: {\n        type: \"object\",\n        required: [\"uri\", \"title\", \"description\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"uri\"\n          },\n          title: {\n            type: \"string\"\n          },\n          description: {\n            type: \"string\"\n          },\n          thumb: {\n            type: \"blob\",\n            accept: [\"image/*\"],\n            maxSize: 1e6\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"external\"],\n        properties: {\n          external: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.external#viewExternal\"\n          }\n        }\n      },\n      viewExternal: {\n        type: \"object\",\n        required: [\"uri\", \"title\", \"description\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"uri\"\n          },\n          title: {\n            type: \"string\"\n          },\n          description: {\n            type: \"string\"\n          },\n          thumb: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedImages: {\n    lexicon: 1,\n    id: \"app.bsky.embed.images\",\n    description: \"A set of images embedded in some other form of content\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"images\"],\n        properties: {\n          images: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:app.bsky.embed.images#image\"\n            },\n            maxLength: 4\n          }\n        }\n      },\n      image: {\n        type: \"object\",\n        required: [\"image\", \"alt\"],\n        properties: {\n          image: {\n            type: \"blob\",\n            accept: [\"image/*\"],\n            maxSize: 1e6\n          },\n          alt: {\n            type: \"string\"\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"images\"],\n        properties: {\n          images: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:app.bsky.embed.images#viewImage\"\n            },\n            maxLength: 4\n          }\n        }\n      },\n      viewImage: {\n        type: \"object\",\n        required: [\"thumb\", \"fullsize\", \"alt\"],\n        properties: {\n          thumb: {\n            type: \"string\"\n          },\n          fullsize: {\n            type: \"string\"\n          },\n          alt: {\n            type: \"string\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedRecord: {\n    lexicon: 1,\n    id: \"app.bsky.embed.record\",\n    description: \"A representation of a record embedded in another form of content\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"record\"],\n        properties: {\n          record: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.repo.strongRef\"\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"record\"],\n        properties: {\n          record: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.embed.record#viewRecord\",\n              \"lex:app.bsky.embed.record#viewNotFound\"\n            ]\n          }\n        }\n      },\n      viewRecord: {\n        type: \"object\",\n        required: [\"uri\", \"cid\", \"author\", \"value\", \"indexedAt\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          author: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n          },\n          value: {\n            type: \"unknown\"\n          },\n          embeds: {\n            type: \"array\",\n            items: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.embed.images#view\",\n                \"lex:app.bsky.embed.external#view\",\n                \"lex:app.bsky.embed.record#view\",\n                \"lex:app.bsky.embed.recordWithMedia#view\"\n              ]\n            }\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      viewNotFound: {\n        type: \"object\",\n        required: [\"uri\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyEmbedRecordWithMedia: {\n    lexicon: 1,\n    id: \"app.bsky.embed.recordWithMedia\",\n    description: \"A representation of a record embedded in another form of content, alongside other compatible embeds\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"record\", \"media\"],\n        properties: {\n          record: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.record\"\n          },\n          media: {\n            type: \"union\",\n            refs: [\"lex:app.bsky.embed.images\", \"lex:app.bsky.embed.external\"]\n          }\n        }\n      },\n      view: {\n        type: \"object\",\n        required: [\"record\", \"media\"],\n        properties: {\n          record: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.embed.record#view\"\n          },\n          media: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.embed.images#view\",\n              \"lex:app.bsky.embed.external#view\"\n            ]\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedDefs: {\n    lexicon: 1,\n    id: \"app.bsky.feed.defs\",\n    defs: {\n      postView: {\n        type: \"object\",\n        required: [\"uri\", \"cid\", \"author\", \"record\", \"indexedAt\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          author: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n          },\n          record: {\n            type: \"unknown\"\n          },\n          embed: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.embed.images#view\",\n              \"lex:app.bsky.embed.external#view\",\n              \"lex:app.bsky.embed.record#view\",\n              \"lex:app.bsky.embed.recordWithMedia#view\"\n            ]\n          },\n          replyCount: {\n            type: \"integer\"\n          },\n          repostCount: {\n            type: \"integer\"\n          },\n          likeCount: {\n            type: \"integer\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          viewer: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#viewerState\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      },\n      viewerState: {\n        type: \"object\",\n        properties: {\n          repost: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          like: {\n            type: \"string\",\n            format: \"at-uri\"\n          }\n        }\n      },\n      feedViewPost: {\n        type: \"object\",\n        required: [\"post\"],\n        properties: {\n          post: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          },\n          reply: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#replyRef\"\n          },\n          reason: {\n            type: \"union\",\n            refs: [\"lex:app.bsky.feed.defs#reasonRepost\"]\n          }\n        }\n      },\n      replyRef: {\n        type: \"object\",\n        required: [\"root\", \"parent\"],\n        properties: {\n          root: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          },\n          parent: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          }\n        }\n      },\n      reasonRepost: {\n        type: \"object\",\n        required: [\"by\", \"indexedAt\"],\n        properties: {\n          by: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileViewBasic\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          }\n        }\n      },\n      threadViewPost: {\n        type: \"object\",\n        required: [\"post\"],\n        properties: {\n          post: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.defs#postView\"\n          },\n          parent: {\n            type: \"union\",\n            refs: [\n              \"lex:app.bsky.feed.defs#threadViewPost\",\n              \"lex:app.bsky.feed.defs#notFoundPost\"\n            ]\n          },\n          replies: {\n            type: \"array\",\n            items: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.feed.defs#threadViewPost\",\n                \"lex:app.bsky.feed.defs#notFoundPost\"\n              ]\n            }\n          }\n        }\n      },\n      notFoundPost: {\n        type: \"object\",\n        required: [\"uri\", \"notFound\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          notFound: {\n            type: \"boolean\",\n            const: true\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetAuthorFeed: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getAuthorFeed\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"A view of an actor's feed.\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"feed\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              feed: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#feedViewPost\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetLikes: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getLikes\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"likes\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              likes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.getLikes#like\"\n                }\n              }\n            }\n          }\n        }\n      },\n      like: {\n        type: \"object\",\n        required: [\"indexedAt\", \"createdAt\", \"actor\"],\n        properties: {\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          createdAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          actor: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileView\"\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetPostThread: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getPostThread\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            depth: {\n              type: \"integer\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"thread\"],\n            properties: {\n              thread: {\n                type: \"union\",\n                refs: [\n                  \"lex:app.bsky.feed.defs#threadViewPost\",\n                  \"lex:app.bsky.feed.defs#notFoundPost\"\n                ]\n              }\n            }\n          }\n        },\n        errors: [\n          {\n            name: \"NotFound\"\n          }\n        ]\n      }\n    }\n  },\n  AppBskyFeedGetRepostedBy: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getRepostedBy\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          required: [\"uri\"],\n          properties: {\n            uri: {\n              type: \"string\",\n              format: \"at-uri\"\n            },\n            cid: {\n              type: \"string\",\n              format: \"cid\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"uri\", \"repostedBy\"],\n            properties: {\n              uri: {\n                type: \"string\",\n                format: \"at-uri\"\n              },\n              cid: {\n                type: \"string\",\n                format: \"cid\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              repostedBy: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedGetTimeline: {\n    lexicon: 1,\n    id: \"app.bsky.feed.getTimeline\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"A view of the user's home timeline.\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            algorithm: {\n              type: \"string\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"feed\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              feed: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#feedViewPost\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedLike: {\n    lexicon: 1,\n    id: \"app.bsky.feed.like\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.repo.strongRef\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedPost: {\n    lexicon: 1,\n    id: \"app.bsky.feed.post\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"text\", \"createdAt\"],\n          properties: {\n            text: {\n              type: \"string\",\n              maxLength: 3e3,\n              maxGraphemes: 300\n            },\n            entities: {\n              type: \"array\",\n              description: \"Deprecated: replaced by app.bsky.richtext.facet.\",\n              items: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.feed.post#entity\"\n              }\n            },\n            facets: {\n              type: \"array\",\n              items: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.richtext.facet\"\n              }\n            },\n            reply: {\n              type: \"ref\",\n              ref: \"lex:app.bsky.feed.post#replyRef\"\n            },\n            embed: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.embed.images\",\n                \"lex:app.bsky.embed.external\",\n                \"lex:app.bsky.embed.record\",\n                \"lex:app.bsky.embed.recordWithMedia\"\n              ]\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      },\n      replyRef: {\n        type: \"object\",\n        required: [\"root\", \"parent\"],\n        properties: {\n          root: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.repo.strongRef\"\n          },\n          parent: {\n            type: \"ref\",\n            ref: \"lex:com.atproto.repo.strongRef\"\n          }\n        }\n      },\n      entity: {\n        type: \"object\",\n        description: \"Deprecated: use facets instead.\",\n        required: [\"index\", \"type\", \"value\"],\n        properties: {\n          index: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.feed.post#textSlice\"\n          },\n          type: {\n            type: \"string\",\n            description: \"Expected values are 'mention' and 'link'.\"\n          },\n          value: {\n            type: \"string\"\n          }\n        }\n      },\n      textSlice: {\n        type: \"object\",\n        description: \"Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.\",\n        required: [\"start\", \"end\"],\n        properties: {\n          start: {\n            type: \"integer\",\n            minimum: 0\n          },\n          end: {\n            type: \"integer\",\n            minimum: 0\n          }\n        }\n      }\n    }\n  },\n  AppBskyFeedRepost: {\n    lexicon: 1,\n    id: \"app.bsky.feed.repost\",\n    defs: {\n      main: {\n        type: \"record\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.repo.strongRef\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphFollow: {\n    lexicon: 1,\n    id: \"app.bsky.graph.follow\",\n    defs: {\n      main: {\n        type: \"record\",\n        description: \"A social follow.\",\n        key: \"tid\",\n        record: {\n          type: \"object\",\n          required: [\"subject\", \"createdAt\"],\n          properties: {\n            subject: {\n              type: \"string\",\n              format: \"did\"\n            },\n            createdAt: {\n              type: \"string\",\n              format: \"datetime\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetFollowers: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getFollowers\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who is following an actor?\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"subject\", \"followers\"],\n            properties: {\n              subject: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.actor.defs#profileView\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              followers: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetFollows: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getFollows\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who is an actor following?\",\n        parameters: {\n          type: \"params\",\n          required: [\"actor\"],\n          properties: {\n            actor: {\n              type: \"string\",\n              format: \"at-identifier\"\n            },\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"subject\", \"follows\"],\n            properties: {\n              subject: {\n                type: \"ref\",\n                ref: \"lex:app.bsky.actor.defs#profileView\"\n              },\n              cursor: {\n                type: \"string\"\n              },\n              follows: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphGetMutes: {\n    lexicon: 1,\n    id: \"app.bsky.graph.getMutes\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"Who does the viewer mute?\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"mutes\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              mutes: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.actor.defs#profileView\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphMuteActor: {\n    lexicon: 1,\n    id: \"app.bsky.graph.muteActor\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Mute an actor by did or handle.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actor\"],\n            properties: {\n              actor: {\n                type: \"string\",\n                format: \"at-identifier\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyGraphUnmuteActor: {\n    lexicon: 1,\n    id: \"app.bsky.graph.unmuteActor\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Unmute an actor by did or handle.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"actor\"],\n            properties: {\n              actor: {\n                type: \"string\",\n                format: \"at-identifier\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyNotificationGetUnreadCount: {\n    lexicon: 1,\n    id: \"app.bsky.notification.getUnreadCount\",\n    defs: {\n      main: {\n        type: \"query\",\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"count\"],\n            properties: {\n              count: {\n                type: \"integer\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyNotificationListNotifications: {\n    lexicon: 1,\n    id: \"app.bsky.notification.listNotifications\",\n    defs: {\n      main: {\n        type: \"query\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"notifications\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              notifications: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.notification.listNotifications#notification\"\n                }\n              }\n            }\n          }\n        }\n      },\n      notification: {\n        type: \"object\",\n        required: [\n          \"uri\",\n          \"cid\",\n          \"author\",\n          \"reason\",\n          \"record\",\n          \"isRead\",\n          \"indexedAt\"\n        ],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          cid: {\n            type: \"string\",\n            format: \"cid\"\n          },\n          author: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.actor.defs#profileView\"\n          },\n          reason: {\n            type: \"string\",\n            description: \"Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.\",\n            knownValues: [\n              \"like\",\n              \"repost\",\n              \"follow\",\n              \"mention\",\n              \"reply\",\n              \"quote\"\n            ]\n          },\n          reasonSubject: {\n            type: \"string\",\n            format: \"at-uri\"\n          },\n          record: {\n            type: \"unknown\"\n          },\n          isRead: {\n            type: \"boolean\"\n          },\n          indexedAt: {\n            type: \"string\",\n            format: \"datetime\"\n          },\n          labels: {\n            type: \"array\",\n            items: {\n              type: \"ref\",\n              ref: \"lex:com.atproto.label.defs#label\"\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyNotificationUpdateSeen: {\n    lexicon: 1,\n    id: \"app.bsky.notification.updateSeen\",\n    defs: {\n      main: {\n        type: \"procedure\",\n        description: \"Notify server that the user has seen notifications.\",\n        input: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"seenAt\"],\n            properties: {\n              seenAt: {\n                type: \"string\",\n                format: \"datetime\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  AppBskyRichtextFacet: {\n    lexicon: 1,\n    id: \"app.bsky.richtext.facet\",\n    defs: {\n      main: {\n        type: \"object\",\n        required: [\"index\", \"features\"],\n        properties: {\n          index: {\n            type: \"ref\",\n            ref: \"lex:app.bsky.richtext.facet#byteSlice\"\n          },\n          features: {\n            type: \"array\",\n            items: {\n              type: \"union\",\n              refs: [\n                \"lex:app.bsky.richtext.facet#mention\",\n                \"lex:app.bsky.richtext.facet#link\"\n              ]\n            }\n          }\n        }\n      },\n      mention: {\n        type: \"object\",\n        description: \"A facet feature for actor mentions.\",\n        required: [\"did\"],\n        properties: {\n          did: {\n            type: \"string\",\n            format: \"did\"\n          }\n        }\n      },\n      link: {\n        type: \"object\",\n        description: \"A facet feature for links.\",\n        required: [\"uri\"],\n        properties: {\n          uri: {\n            type: \"string\",\n            format: \"uri\"\n          }\n        }\n      },\n      byteSlice: {\n        type: \"object\",\n        description: \"A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.\",\n        required: [\"byteStart\", \"byteEnd\"],\n        properties: {\n          byteStart: {\n            type: \"integer\",\n            minimum: 0\n          },\n          byteEnd: {\n            type: \"integer\",\n            minimum: 0\n          }\n        }\n      }\n    }\n  },\n  AppBskyUnspeccedGetPopular: {\n    lexicon: 1,\n    id: \"app.bsky.unspecced.getPopular\",\n    defs: {\n      main: {\n        type: \"query\",\n        description: \"An unspecced view of globally popular items\",\n        parameters: {\n          type: \"params\",\n          properties: {\n            limit: {\n              type: \"integer\",\n              minimum: 1,\n              maximum: 100,\n              default: 50\n            },\n            cursor: {\n              type: \"string\"\n            }\n          }\n        },\n        output: {\n          encoding: \"application/json\",\n          schema: {\n            type: \"object\",\n            required: [\"feed\"],\n            properties: {\n              cursor: {\n                type: \"string\"\n              },\n              feed: {\n                type: \"array\",\n                items: {\n                  type: \"ref\",\n                  ref: \"lex:app.bsky.feed.defs#feedViewPost\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\nvar schemas = Object.values(schemaDict);\nvar lexicons = new Lexicons(schemas);\n\n// src/client/types/com/atproto/admin/disableInviteCodes.ts\nvar disableInviteCodes_exports = {};\n__export(disableInviteCodes_exports, {\n  toKnownErr: () => toKnownErr\n});\nfunction toKnownErr(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getInviteCodes.ts\nvar getInviteCodes_exports = {};\n__export(getInviteCodes_exports, {\n  toKnownErr: () => toKnownErr2\n});\nfunction toKnownErr2(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationAction.ts\nvar getModerationAction_exports = {};\n__export(getModerationAction_exports, {\n  toKnownErr: () => toKnownErr3\n});\nfunction toKnownErr3(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationActions.ts\nvar getModerationActions_exports = {};\n__export(getModerationActions_exports, {\n  toKnownErr: () => toKnownErr4\n});\nfunction toKnownErr4(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationReport.ts\nvar getModerationReport_exports = {};\n__export(getModerationReport_exports, {\n  toKnownErr: () => toKnownErr5\n});\nfunction toKnownErr5(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getModerationReports.ts\nvar getModerationReports_exports = {};\n__export(getModerationReports_exports, {\n  toKnownErr: () => toKnownErr6\n});\nfunction toKnownErr6(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getRecord.ts\nvar getRecord_exports = {};\n__export(getRecord_exports, {\n  toKnownErr: () => toKnownErr7\n});\nfunction toKnownErr7(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/getRepo.ts\nvar getRepo_exports = {};\n__export(getRepo_exports, {\n  toKnownErr: () => toKnownErr8\n});\nfunction toKnownErr8(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/resolveModerationReports.ts\nvar resolveModerationReports_exports = {};\n__export(resolveModerationReports_exports, {\n  toKnownErr: () => toKnownErr9\n});\nfunction toKnownErr9(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/reverseModerationAction.ts\nvar reverseModerationAction_exports = {};\n__export(reverseModerationAction_exports, {\n  toKnownErr: () => toKnownErr10\n});\nfunction toKnownErr10(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/searchRepos.ts\nvar searchRepos_exports = {};\n__export(searchRepos_exports, {\n  toKnownErr: () => toKnownErr11\n});\nfunction toKnownErr11(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/takeModerationAction.ts\nvar takeModerationAction_exports = {};\n__export(takeModerationAction_exports, {\n  SubjectHasActionError: () => SubjectHasActionError,\n  toKnownErr: () => toKnownErr12\n});\nvar SubjectHasActionError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr12(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"SubjectHasAction\")\n      return new SubjectHasActionError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/updateAccountHandle.ts\nvar updateAccountHandle_exports = {};\n__export(updateAccountHandle_exports, {\n  toKnownErr: () => toKnownErr13\n});\nfunction toKnownErr13(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/identity/resolveHandle.ts\nvar resolveHandle_exports = {};\n__export(resolveHandle_exports, {\n  toKnownErr: () => toKnownErr14\n});\nfunction toKnownErr14(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/identity/updateHandle.ts\nvar updateHandle_exports = {};\n__export(updateHandle_exports, {\n  toKnownErr: () => toKnownErr15\n});\nfunction toKnownErr15(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/label/queryLabels.ts\nvar queryLabels_exports = {};\n__export(queryLabels_exports, {\n  toKnownErr: () => toKnownErr16\n});\nfunction toKnownErr16(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/moderation/createReport.ts\nvar createReport_exports = {};\n__export(createReport_exports, {\n  toKnownErr: () => toKnownErr17\n});\nfunction toKnownErr17(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/applyWrites.ts\nvar applyWrites_exports = {};\n__export(applyWrites_exports, {\n  InvalidSwapError: () => InvalidSwapError,\n  isCreate: () => isCreate,\n  isDelete: () => isDelete,\n  isUpdate: () => isUpdate,\n  toKnownErr: () => toKnownErr18,\n  validateCreate: () => validateCreate,\n  validateDelete: () => validateDelete,\n  validateUpdate: () => validateUpdate\n});\n\n// src/client/util.ts\nfunction isObj2(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction hasProp2(data, prop) {\n  return prop in data;\n}\n\n// src/client/types/com/atproto/repo/applyWrites.ts\nvar InvalidSwapError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr18(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError(e);\n  }\n  return e;\n}\nfunction isCreate(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.applyWrites#create\";\n}\nfunction validateCreate(v) {\n  return lexicons.validate(\"com.atproto.repo.applyWrites#create\", v);\n}\nfunction isUpdate(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.applyWrites#update\";\n}\nfunction validateUpdate(v) {\n  return lexicons.validate(\"com.atproto.repo.applyWrites#update\", v);\n}\nfunction isDelete(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.applyWrites#delete\";\n}\nfunction validateDelete(v) {\n  return lexicons.validate(\"com.atproto.repo.applyWrites#delete\", v);\n}\n\n// src/client/types/com/atproto/repo/createRecord.ts\nvar createRecord_exports = {};\n__export(createRecord_exports, {\n  InvalidSwapError: () => InvalidSwapError2,\n  toKnownErr: () => toKnownErr19\n});\nvar InvalidSwapError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr19(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError2(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/deleteRecord.ts\nvar deleteRecord_exports = {};\n__export(deleteRecord_exports, {\n  InvalidSwapError: () => InvalidSwapError3,\n  toKnownErr: () => toKnownErr20\n});\nvar InvalidSwapError3 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr20(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError3(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/describeRepo.ts\nvar describeRepo_exports = {};\n__export(describeRepo_exports, {\n  toKnownErr: () => toKnownErr21\n});\nfunction toKnownErr21(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/getRecord.ts\nvar getRecord_exports2 = {};\n__export(getRecord_exports2, {\n  toKnownErr: () => toKnownErr22\n});\nfunction toKnownErr22(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/listRecords.ts\nvar listRecords_exports = {};\n__export(listRecords_exports, {\n  isRecord: () => isRecord,\n  toKnownErr: () => toKnownErr23,\n  validateRecord: () => validateRecord\n});\nfunction toKnownErr23(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isRecord(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.repo.listRecords#record\";\n}\nfunction validateRecord(v) {\n  return lexicons.validate(\"com.atproto.repo.listRecords#record\", v);\n}\n\n// src/client/types/com/atproto/repo/putRecord.ts\nvar putRecord_exports = {};\n__export(putRecord_exports, {\n  InvalidSwapError: () => InvalidSwapError4,\n  toKnownErr: () => toKnownErr24\n});\nvar InvalidSwapError4 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr24(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidSwap\")\n      return new InvalidSwapError4(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/repo/uploadBlob.ts\nvar uploadBlob_exports = {};\n__export(uploadBlob_exports, {\n  toKnownErr: () => toKnownErr25\n});\nfunction toKnownErr25(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createAccount.ts\nvar createAccount_exports = {};\n__export(createAccount_exports, {\n  HandleNotAvailableError: () => HandleNotAvailableError,\n  InvalidHandleError: () => InvalidHandleError2,\n  InvalidInviteCodeError: () => InvalidInviteCodeError,\n  InvalidPasswordError: () => InvalidPasswordError,\n  UnsupportedDomainError: () => UnsupportedDomainError,\n  toKnownErr: () => toKnownErr26\n});\nvar InvalidHandleError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidPasswordError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidInviteCodeError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar HandleNotAvailableError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar UnsupportedDomainError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr26(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"InvalidHandle\")\n      return new InvalidHandleError2(e);\n    if (e.error === \"InvalidPassword\")\n      return new InvalidPasswordError(e);\n    if (e.error === \"InvalidInviteCode\")\n      return new InvalidInviteCodeError(e);\n    if (e.error === \"HandleNotAvailable\")\n      return new HandleNotAvailableError(e);\n    if (e.error === \"UnsupportedDomain\")\n      return new UnsupportedDomainError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createInviteCode.ts\nvar createInviteCode_exports = {};\n__export(createInviteCode_exports, {\n  toKnownErr: () => toKnownErr27\n});\nfunction toKnownErr27(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createInviteCodes.ts\nvar createInviteCodes_exports = {};\n__export(createInviteCodes_exports, {\n  toKnownErr: () => toKnownErr28\n});\nfunction toKnownErr28(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/createSession.ts\nvar createSession_exports = {};\n__export(createSession_exports, {\n  AccountTakedownError: () => AccountTakedownError,\n  toKnownErr: () => toKnownErr29\n});\nvar AccountTakedownError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr29(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"AccountTakedown\")\n      return new AccountTakedownError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/deleteAccount.ts\nvar deleteAccount_exports = {};\n__export(deleteAccount_exports, {\n  ExpiredTokenError: () => ExpiredTokenError,\n  InvalidTokenError: () => InvalidTokenError,\n  toKnownErr: () => toKnownErr30\n});\nvar ExpiredTokenError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidTokenError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr30(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"ExpiredToken\")\n      return new ExpiredTokenError(e);\n    if (e.error === \"InvalidToken\")\n      return new InvalidTokenError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/deleteSession.ts\nvar deleteSession_exports = {};\n__export(deleteSession_exports, {\n  toKnownErr: () => toKnownErr31\n});\nfunction toKnownErr31(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/describeServer.ts\nvar describeServer_exports = {};\n__export(describeServer_exports, {\n  isLinks: () => isLinks,\n  toKnownErr: () => toKnownErr32,\n  validateLinks: () => validateLinks\n});\nfunction toKnownErr32(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isLinks(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.describeServer#links\";\n}\nfunction validateLinks(v) {\n  return lexicons.validate(\"com.atproto.server.describeServer#links\", v);\n}\n\n// src/client/types/com/atproto/server/getAccountInviteCodes.ts\nvar getAccountInviteCodes_exports = {};\n__export(getAccountInviteCodes_exports, {\n  DuplicateCreateError: () => DuplicateCreateError,\n  toKnownErr: () => toKnownErr33\n});\nvar DuplicateCreateError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr33(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"DuplicateCreate\")\n      return new DuplicateCreateError(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/getSession.ts\nvar getSession_exports = {};\n__export(getSession_exports, {\n  toKnownErr: () => toKnownErr34\n});\nfunction toKnownErr34(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/refreshSession.ts\nvar refreshSession_exports = {};\n__export(refreshSession_exports, {\n  AccountTakedownError: () => AccountTakedownError2,\n  toKnownErr: () => toKnownErr35\n});\nvar AccountTakedownError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr35(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"AccountTakedown\")\n      return new AccountTakedownError2(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/requestAccountDelete.ts\nvar requestAccountDelete_exports = {};\n__export(requestAccountDelete_exports, {\n  toKnownErr: () => toKnownErr36\n});\nfunction toKnownErr36(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/requestPasswordReset.ts\nvar requestPasswordReset_exports = {};\n__export(requestPasswordReset_exports, {\n  toKnownErr: () => toKnownErr37\n});\nfunction toKnownErr37(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/server/resetPassword.ts\nvar resetPassword_exports = {};\n__export(resetPassword_exports, {\n  ExpiredTokenError: () => ExpiredTokenError2,\n  InvalidTokenError: () => InvalidTokenError2,\n  toKnownErr: () => toKnownErr38\n});\nvar ExpiredTokenError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nvar InvalidTokenError2 = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr38(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"ExpiredToken\")\n      return new ExpiredTokenError2(e);\n    if (e.error === \"InvalidToken\")\n      return new InvalidTokenError2(e);\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getBlob.ts\nvar getBlob_exports = {};\n__export(getBlob_exports, {\n  toKnownErr: () => toKnownErr39\n});\nfunction toKnownErr39(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getBlocks.ts\nvar getBlocks_exports = {};\n__export(getBlocks_exports, {\n  toKnownErr: () => toKnownErr40\n});\nfunction toKnownErr40(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getCheckout.ts\nvar getCheckout_exports = {};\n__export(getCheckout_exports, {\n  toKnownErr: () => toKnownErr41\n});\nfunction toKnownErr41(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getCommitPath.ts\nvar getCommitPath_exports = {};\n__export(getCommitPath_exports, {\n  toKnownErr: () => toKnownErr42\n});\nfunction toKnownErr42(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getHead.ts\nvar getHead_exports = {};\n__export(getHead_exports, {\n  toKnownErr: () => toKnownErr43\n});\nfunction toKnownErr43(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getRecord.ts\nvar getRecord_exports3 = {};\n__export(getRecord_exports3, {\n  toKnownErr: () => toKnownErr44\n});\nfunction toKnownErr44(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/getRepo.ts\nvar getRepo_exports2 = {};\n__export(getRepo_exports2, {\n  toKnownErr: () => toKnownErr45\n});\nfunction toKnownErr45(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/listBlobs.ts\nvar listBlobs_exports = {};\n__export(listBlobs_exports, {\n  toKnownErr: () => toKnownErr46\n});\nfunction toKnownErr46(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/listRepos.ts\nvar listRepos_exports = {};\n__export(listRepos_exports, {\n  isRepo: () => isRepo,\n  toKnownErr: () => toKnownErr47,\n  validateRepo: () => validateRepo\n});\nfunction toKnownErr47(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isRepo(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.listRepos#repo\";\n}\nfunction validateRepo(v) {\n  return lexicons.validate(\"com.atproto.sync.listRepos#repo\", v);\n}\n\n// src/client/types/com/atproto/sync/notifyOfUpdate.ts\nvar notifyOfUpdate_exports = {};\n__export(notifyOfUpdate_exports, {\n  toKnownErr: () => toKnownErr48\n});\nfunction toKnownErr48(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/sync/requestCrawl.ts\nvar requestCrawl_exports = {};\n__export(requestCrawl_exports, {\n  toKnownErr: () => toKnownErr49\n});\nfunction toKnownErr49(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/getProfile.ts\nvar getProfile_exports = {};\n__export(getProfile_exports, {\n  toKnownErr: () => toKnownErr50\n});\nfunction toKnownErr50(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/getProfiles.ts\nvar getProfiles_exports = {};\n__export(getProfiles_exports, {\n  toKnownErr: () => toKnownErr51\n});\nfunction toKnownErr51(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/getSuggestions.ts\nvar getSuggestions_exports = {};\n__export(getSuggestions_exports, {\n  toKnownErr: () => toKnownErr52\n});\nfunction toKnownErr52(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/searchActors.ts\nvar searchActors_exports = {};\n__export(searchActors_exports, {\n  toKnownErr: () => toKnownErr53\n});\nfunction toKnownErr53(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/actor/searchActorsTypeahead.ts\nvar searchActorsTypeahead_exports = {};\n__export(searchActorsTypeahead_exports, {\n  toKnownErr: () => toKnownErr54\n});\nfunction toKnownErr54(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getAuthorFeed.ts\nvar getAuthorFeed_exports = {};\n__export(getAuthorFeed_exports, {\n  toKnownErr: () => toKnownErr55\n});\nfunction toKnownErr55(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getLikes.ts\nvar getLikes_exports = {};\n__export(getLikes_exports, {\n  isLike: () => isLike,\n  toKnownErr: () => toKnownErr56,\n  validateLike: () => validateLike\n});\nfunction toKnownErr56(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isLike(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.getLikes#like\";\n}\nfunction validateLike(v) {\n  return lexicons.validate(\"app.bsky.feed.getLikes#like\", v);\n}\n\n// src/client/types/app/bsky/feed/getPostThread.ts\nvar getPostThread_exports = {};\n__export(getPostThread_exports, {\n  NotFoundError: () => NotFoundError,\n  toKnownErr: () => toKnownErr57\n});\nvar NotFoundError = class extends XRPCError {\n  constructor(src2) {\n    super(src2.status, src2.error, src2.message);\n  }\n};\nfunction toKnownErr57(e) {\n  if (e instanceof XRPCError) {\n    if (e.error === \"NotFound\")\n      return new NotFoundError(e);\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getRepostedBy.ts\nvar getRepostedBy_exports = {};\n__export(getRepostedBy_exports, {\n  toKnownErr: () => toKnownErr58\n});\nfunction toKnownErr58(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/feed/getTimeline.ts\nvar getTimeline_exports = {};\n__export(getTimeline_exports, {\n  toKnownErr: () => toKnownErr59\n});\nfunction toKnownErr59(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getFollowers.ts\nvar getFollowers_exports = {};\n__export(getFollowers_exports, {\n  toKnownErr: () => toKnownErr60\n});\nfunction toKnownErr60(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getFollows.ts\nvar getFollows_exports = {};\n__export(getFollows_exports, {\n  toKnownErr: () => toKnownErr61\n});\nfunction toKnownErr61(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/getMutes.ts\nvar getMutes_exports = {};\n__export(getMutes_exports, {\n  toKnownErr: () => toKnownErr62\n});\nfunction toKnownErr62(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/muteActor.ts\nvar muteActor_exports = {};\n__export(muteActor_exports, {\n  toKnownErr: () => toKnownErr63\n});\nfunction toKnownErr63(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/graph/unmuteActor.ts\nvar unmuteActor_exports = {};\n__export(unmuteActor_exports, {\n  toKnownErr: () => toKnownErr64\n});\nfunction toKnownErr64(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/notification/getUnreadCount.ts\nvar getUnreadCount_exports = {};\n__export(getUnreadCount_exports, {\n  toKnownErr: () => toKnownErr65\n});\nfunction toKnownErr65(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/notification/listNotifications.ts\nvar listNotifications_exports = {};\n__export(listNotifications_exports, {\n  isNotification: () => isNotification,\n  toKnownErr: () => toKnownErr66,\n  validateNotification: () => validateNotification\n});\nfunction toKnownErr66(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\nfunction isNotification(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.notification.listNotifications#notification\";\n}\nfunction validateNotification(v) {\n  return lexicons.validate(\n    \"app.bsky.notification.listNotifications#notification\",\n    v\n  );\n}\n\n// src/client/types/app/bsky/notification/updateSeen.ts\nvar updateSeen_exports = {};\n__export(updateSeen_exports, {\n  toKnownErr: () => toKnownErr67\n});\nfunction toKnownErr67(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/app/bsky/unspecced/getPopular.ts\nvar getPopular_exports = {};\n__export(getPopular_exports, {\n  toKnownErr: () => toKnownErr68\n});\nfunction toKnownErr68(e) {\n  if (e instanceof XRPCError) {\n  }\n  return e;\n}\n\n// src/client/types/com/atproto/admin/defs.ts\nvar defs_exports = {};\n__export(defs_exports, {\n  ACKNOWLEDGE: () => ACKNOWLEDGE,\n  FLAG: () => FLAG,\n  TAKEDOWN: () => TAKEDOWN,\n  isActionReversal: () => isActionReversal,\n  isActionView: () => isActionView,\n  isActionViewCurrent: () => isActionViewCurrent,\n  isActionViewDetail: () => isActionViewDetail,\n  isBlobView: () => isBlobView,\n  isImageDetails: () => isImageDetails,\n  isModeration: () => isModeration,\n  isModerationDetail: () => isModerationDetail,\n  isRecordView: () => isRecordView,\n  isRecordViewDetail: () => isRecordViewDetail,\n  isRepoRef: () => isRepoRef,\n  isRepoView: () => isRepoView,\n  isRepoViewDetail: () => isRepoViewDetail,\n  isReportView: () => isReportView,\n  isReportViewDetail: () => isReportViewDetail,\n  isVideoDetails: () => isVideoDetails,\n  validateActionReversal: () => validateActionReversal,\n  validateActionView: () => validateActionView,\n  validateActionViewCurrent: () => validateActionViewCurrent,\n  validateActionViewDetail: () => validateActionViewDetail,\n  validateBlobView: () => validateBlobView,\n  validateImageDetails: () => validateImageDetails,\n  validateModeration: () => validateModeration,\n  validateModerationDetail: () => validateModerationDetail,\n  validateRecordView: () => validateRecordView,\n  validateRecordViewDetail: () => validateRecordViewDetail,\n  validateRepoRef: () => validateRepoRef,\n  validateRepoView: () => validateRepoView,\n  validateRepoViewDetail: () => validateRepoViewDetail,\n  validateReportView: () => validateReportView,\n  validateReportViewDetail: () => validateReportViewDetail,\n  validateVideoDetails: () => validateVideoDetails\n});\nfunction isActionView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionView\";\n}\nfunction validateActionView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionView\", v);\n}\nfunction isActionViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionViewDetail\";\n}\nfunction validateActionViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionViewDetail\", v);\n}\nfunction isActionViewCurrent(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionViewCurrent\";\n}\nfunction validateActionViewCurrent(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionViewCurrent\", v);\n}\nfunction isActionReversal(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#actionReversal\";\n}\nfunction validateActionReversal(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#actionReversal\", v);\n}\nvar TAKEDOWN = \"com.atproto.admin.defs#takedown\";\nvar FLAG = \"com.atproto.admin.defs#flag\";\nvar ACKNOWLEDGE = \"com.atproto.admin.defs#acknowledge\";\nfunction isReportView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#reportView\";\n}\nfunction validateReportView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#reportView\", v);\n}\nfunction isReportViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#reportViewDetail\";\n}\nfunction validateReportViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#reportViewDetail\", v);\n}\nfunction isRepoView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#repoView\";\n}\nfunction validateRepoView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#repoView\", v);\n}\nfunction isRepoViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#repoViewDetail\";\n}\nfunction validateRepoViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#repoViewDetail\", v);\n}\nfunction isRepoRef(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#repoRef\";\n}\nfunction validateRepoRef(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#repoRef\", v);\n}\nfunction isRecordView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#recordView\";\n}\nfunction validateRecordView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#recordView\", v);\n}\nfunction isRecordViewDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#recordViewDetail\";\n}\nfunction validateRecordViewDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#recordViewDetail\", v);\n}\nfunction isModeration(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#moderation\";\n}\nfunction validateModeration(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#moderation\", v);\n}\nfunction isModerationDetail(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#moderationDetail\";\n}\nfunction validateModerationDetail(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#moderationDetail\", v);\n}\nfunction isBlobView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#blobView\";\n}\nfunction validateBlobView(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#blobView\", v);\n}\nfunction isImageDetails(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#imageDetails\";\n}\nfunction validateImageDetails(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#imageDetails\", v);\n}\nfunction isVideoDetails(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.admin.defs#videoDetails\";\n}\nfunction validateVideoDetails(v) {\n  return lexicons.validate(\"com.atproto.admin.defs#videoDetails\", v);\n}\n\n// src/client/types/com/atproto/label/defs.ts\nvar defs_exports2 = {};\n__export(defs_exports2, {\n  isLabel: () => isLabel,\n  validateLabel: () => validateLabel\n});\nfunction isLabel(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.label.defs#label\";\n}\nfunction validateLabel(v) {\n  return lexicons.validate(\"com.atproto.label.defs#label\", v);\n}\n\n// src/client/types/com/atproto/label/subscribeLabels.ts\nvar subscribeLabels_exports = {};\n__export(subscribeLabels_exports, {\n  isInfo: () => isInfo,\n  isLabels: () => isLabels,\n  validateInfo: () => validateInfo,\n  validateLabels: () => validateLabels\n});\nfunction isLabels(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.label.subscribeLabels#labels\";\n}\nfunction validateLabels(v) {\n  return lexicons.validate(\"com.atproto.label.subscribeLabels#labels\", v);\n}\nfunction isInfo(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.label.subscribeLabels#info\";\n}\nfunction validateInfo(v) {\n  return lexicons.validate(\"com.atproto.label.subscribeLabels#info\", v);\n}\n\n// src/client/types/com/atproto/moderation/defs.ts\nvar defs_exports3 = {};\n__export(defs_exports3, {\n  REASONOTHER: () => REASONOTHER,\n  REASONSPAM: () => REASONSPAM\n});\nvar REASONSPAM = \"com.atproto.moderation.defs#reasonSpam\";\nvar REASONOTHER = \"com.atproto.moderation.defs#reasonOther\";\n\n// src/client/types/com/atproto/repo/strongRef.ts\nvar strongRef_exports = {};\n__export(strongRef_exports, {\n  isMain: () => isMain,\n  validateMain: () => validateMain\n});\nfunction isMain(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"com.atproto.repo.strongRef#main\" || v.$type === \"com.atproto.repo.strongRef\");\n}\nfunction validateMain(v) {\n  return lexicons.validate(\"com.atproto.repo.strongRef#main\", v);\n}\n\n// src/client/types/com/atproto/server/defs.ts\nvar defs_exports4 = {};\n__export(defs_exports4, {\n  isInviteCode: () => isInviteCode,\n  isInviteCodeUse: () => isInviteCodeUse,\n  validateInviteCode: () => validateInviteCode,\n  validateInviteCodeUse: () => validateInviteCodeUse\n});\nfunction isInviteCode(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.defs#inviteCode\";\n}\nfunction validateInviteCode(v) {\n  return lexicons.validate(\"com.atproto.server.defs#inviteCode\", v);\n}\nfunction isInviteCodeUse(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.server.defs#inviteCodeUse\";\n}\nfunction validateInviteCodeUse(v) {\n  return lexicons.validate(\"com.atproto.server.defs#inviteCodeUse\", v);\n}\n\n// src/client/types/com/atproto/sync/subscribeRepos.ts\nvar subscribeRepos_exports = {};\n__export(subscribeRepos_exports, {\n  isCommit: () => isCommit,\n  isHandle: () => isHandle,\n  isInfo: () => isInfo2,\n  isMigrate: () => isMigrate,\n  isRepoOp: () => isRepoOp,\n  isTombstone: () => isTombstone,\n  validateCommit: () => validateCommit,\n  validateHandle: () => validateHandle,\n  validateInfo: () => validateInfo2,\n  validateMigrate: () => validateMigrate,\n  validateRepoOp: () => validateRepoOp,\n  validateTombstone: () => validateTombstone\n});\nfunction isCommit(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#commit\";\n}\nfunction validateCommit(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#commit\", v);\n}\nfunction isHandle(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#handle\";\n}\nfunction validateHandle(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#handle\", v);\n}\nfunction isMigrate(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#migrate\";\n}\nfunction validateMigrate(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#migrate\", v);\n}\nfunction isTombstone(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#tombstone\";\n}\nfunction validateTombstone(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#tombstone\", v);\n}\nfunction isInfo2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#info\";\n}\nfunction validateInfo2(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#info\", v);\n}\nfunction isRepoOp(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"com.atproto.sync.subscribeRepos#repoOp\";\n}\nfunction validateRepoOp(v) {\n  return lexicons.validate(\"com.atproto.sync.subscribeRepos#repoOp\", v);\n}\n\n// src/client/types/app/bsky/actor/defs.ts\nvar defs_exports5 = {};\n__export(defs_exports5, {\n  isProfileView: () => isProfileView,\n  isProfileViewBasic: () => isProfileViewBasic,\n  isProfileViewDetailed: () => isProfileViewDetailed,\n  isViewerState: () => isViewerState,\n  validateProfileView: () => validateProfileView,\n  validateProfileViewBasic: () => validateProfileViewBasic,\n  validateProfileViewDetailed: () => validateProfileViewDetailed,\n  validateViewerState: () => validateViewerState\n});\nfunction isProfileViewBasic(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#profileViewBasic\";\n}\nfunction validateProfileViewBasic(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#profileViewBasic\", v);\n}\nfunction isProfileView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#profileView\";\n}\nfunction validateProfileView(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#profileView\", v);\n}\nfunction isProfileViewDetailed(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#profileViewDetailed\";\n}\nfunction validateProfileViewDetailed(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#profileViewDetailed\", v);\n}\nfunction isViewerState(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.actor.defs#viewerState\";\n}\nfunction validateViewerState(v) {\n  return lexicons.validate(\"app.bsky.actor.defs#viewerState\", v);\n}\n\n// src/client/types/app/bsky/actor/profile.ts\nvar profile_exports = {};\n__export(profile_exports, {\n  isRecord: () => isRecord2,\n  validateRecord: () => validateRecord2\n});\nfunction isRecord2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.actor.profile#main\" || v.$type === \"app.bsky.actor.profile\");\n}\nfunction validateRecord2(v) {\n  return lexicons.validate(\"app.bsky.actor.profile#main\", v);\n}\n\n// src/client/types/app/bsky/embed/external.ts\nvar external_exports = {};\n__export(external_exports, {\n  isExternal: () => isExternal,\n  isMain: () => isMain2,\n  isView: () => isView,\n  isViewExternal: () => isViewExternal,\n  validateExternal: () => validateExternal,\n  validateMain: () => validateMain2,\n  validateView: () => validateView,\n  validateViewExternal: () => validateViewExternal\n});\nfunction isMain2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.external#main\" || v.$type === \"app.bsky.embed.external\");\n}\nfunction validateMain2(v) {\n  return lexicons.validate(\"app.bsky.embed.external#main\", v);\n}\nfunction isExternal(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.external#external\";\n}\nfunction validateExternal(v) {\n  return lexicons.validate(\"app.bsky.embed.external#external\", v);\n}\nfunction isView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.external#view\";\n}\nfunction validateView(v) {\n  return lexicons.validate(\"app.bsky.embed.external#view\", v);\n}\nfunction isViewExternal(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.external#viewExternal\";\n}\nfunction validateViewExternal(v) {\n  return lexicons.validate(\"app.bsky.embed.external#viewExternal\", v);\n}\n\n// src/client/types/app/bsky/embed/images.ts\nvar images_exports = {};\n__export(images_exports, {\n  isImage: () => isImage,\n  isMain: () => isMain3,\n  isView: () => isView2,\n  isViewImage: () => isViewImage,\n  validateImage: () => validateImage,\n  validateMain: () => validateMain3,\n  validateView: () => validateView2,\n  validateViewImage: () => validateViewImage\n});\nfunction isMain3(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.images#main\" || v.$type === \"app.bsky.embed.images\");\n}\nfunction validateMain3(v) {\n  return lexicons.validate(\"app.bsky.embed.images#main\", v);\n}\nfunction isImage(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.images#image\";\n}\nfunction validateImage(v) {\n  return lexicons.validate(\"app.bsky.embed.images#image\", v);\n}\nfunction isView2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.images#view\";\n}\nfunction validateView2(v) {\n  return lexicons.validate(\"app.bsky.embed.images#view\", v);\n}\nfunction isViewImage(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.images#viewImage\";\n}\nfunction validateViewImage(v) {\n  return lexicons.validate(\"app.bsky.embed.images#viewImage\", v);\n}\n\n// src/client/types/app/bsky/embed/record.ts\nvar record_exports = {};\n__export(record_exports, {\n  isMain: () => isMain4,\n  isView: () => isView3,\n  isViewNotFound: () => isViewNotFound,\n  isViewRecord: () => isViewRecord,\n  validateMain: () => validateMain4,\n  validateView: () => validateView3,\n  validateViewNotFound: () => validateViewNotFound,\n  validateViewRecord: () => validateViewRecord\n});\nfunction isMain4(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.record#main\" || v.$type === \"app.bsky.embed.record\");\n}\nfunction validateMain4(v) {\n  return lexicons.validate(\"app.bsky.embed.record#main\", v);\n}\nfunction isView3(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#view\";\n}\nfunction validateView3(v) {\n  return lexicons.validate(\"app.bsky.embed.record#view\", v);\n}\nfunction isViewRecord(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#viewRecord\";\n}\nfunction validateViewRecord(v) {\n  return lexicons.validate(\"app.bsky.embed.record#viewRecord\", v);\n}\nfunction isViewNotFound(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.record#viewNotFound\";\n}\nfunction validateViewNotFound(v) {\n  return lexicons.validate(\"app.bsky.embed.record#viewNotFound\", v);\n}\n\n// src/client/types/app/bsky/embed/recordWithMedia.ts\nvar recordWithMedia_exports = {};\n__export(recordWithMedia_exports, {\n  isMain: () => isMain5,\n  isView: () => isView4,\n  validateMain: () => validateMain5,\n  validateView: () => validateView4\n});\nfunction isMain5(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.embed.recordWithMedia#main\" || v.$type === \"app.bsky.embed.recordWithMedia\");\n}\nfunction validateMain5(v) {\n  return lexicons.validate(\"app.bsky.embed.recordWithMedia#main\", v);\n}\nfunction isView4(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.embed.recordWithMedia#view\";\n}\nfunction validateView4(v) {\n  return lexicons.validate(\"app.bsky.embed.recordWithMedia#view\", v);\n}\n\n// src/client/types/app/bsky/feed/defs.ts\nvar defs_exports6 = {};\n__export(defs_exports6, {\n  isFeedViewPost: () => isFeedViewPost,\n  isNotFoundPost: () => isNotFoundPost,\n  isPostView: () => isPostView,\n  isReasonRepost: () => isReasonRepost,\n  isReplyRef: () => isReplyRef,\n  isThreadViewPost: () => isThreadViewPost,\n  isViewerState: () => isViewerState2,\n  validateFeedViewPost: () => validateFeedViewPost,\n  validateNotFoundPost: () => validateNotFoundPost,\n  validatePostView: () => validatePostView,\n  validateReasonRepost: () => validateReasonRepost,\n  validateReplyRef: () => validateReplyRef,\n  validateThreadViewPost: () => validateThreadViewPost,\n  validateViewerState: () => validateViewerState2\n});\nfunction isPostView(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#postView\";\n}\nfunction validatePostView(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#postView\", v);\n}\nfunction isViewerState2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#viewerState\";\n}\nfunction validateViewerState2(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#viewerState\", v);\n}\nfunction isFeedViewPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#feedViewPost\";\n}\nfunction validateFeedViewPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#feedViewPost\", v);\n}\nfunction isReplyRef(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#replyRef\";\n}\nfunction validateReplyRef(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#replyRef\", v);\n}\nfunction isReasonRepost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#reasonRepost\";\n}\nfunction validateReasonRepost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#reasonRepost\", v);\n}\nfunction isThreadViewPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#threadViewPost\";\n}\nfunction validateThreadViewPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#threadViewPost\", v);\n}\nfunction isNotFoundPost(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.defs#notFoundPost\";\n}\nfunction validateNotFoundPost(v) {\n  return lexicons.validate(\"app.bsky.feed.defs#notFoundPost\", v);\n}\n\n// src/client/types/app/bsky/feed/like.ts\nvar like_exports = {};\n__export(like_exports, {\n  isRecord: () => isRecord3,\n  validateRecord: () => validateRecord3\n});\nfunction isRecord3(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.feed.like#main\" || v.$type === \"app.bsky.feed.like\");\n}\nfunction validateRecord3(v) {\n  return lexicons.validate(\"app.bsky.feed.like#main\", v);\n}\n\n// src/client/types/app/bsky/feed/post.ts\nvar post_exports = {};\n__export(post_exports, {\n  isEntity: () => isEntity,\n  isRecord: () => isRecord4,\n  isReplyRef: () => isReplyRef2,\n  isTextSlice: () => isTextSlice,\n  validateEntity: () => validateEntity,\n  validateRecord: () => validateRecord4,\n  validateReplyRef: () => validateReplyRef2,\n  validateTextSlice: () => validateTextSlice\n});\nfunction isRecord4(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.feed.post#main\" || v.$type === \"app.bsky.feed.post\");\n}\nfunction validateRecord4(v) {\n  return lexicons.validate(\"app.bsky.feed.post#main\", v);\n}\nfunction isReplyRef2(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.post#replyRef\";\n}\nfunction validateReplyRef2(v) {\n  return lexicons.validate(\"app.bsky.feed.post#replyRef\", v);\n}\nfunction isEntity(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.post#entity\";\n}\nfunction validateEntity(v) {\n  return lexicons.validate(\"app.bsky.feed.post#entity\", v);\n}\nfunction isTextSlice(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.feed.post#textSlice\";\n}\nfunction validateTextSlice(v) {\n  return lexicons.validate(\"app.bsky.feed.post#textSlice\", v);\n}\n\n// src/client/types/app/bsky/feed/repost.ts\nvar repost_exports = {};\n__export(repost_exports, {\n  isRecord: () => isRecord5,\n  validateRecord: () => validateRecord5\n});\nfunction isRecord5(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.feed.repost#main\" || v.$type === \"app.bsky.feed.repost\");\n}\nfunction validateRecord5(v) {\n  return lexicons.validate(\"app.bsky.feed.repost#main\", v);\n}\n\n// src/client/types/app/bsky/graph/follow.ts\nvar follow_exports = {};\n__export(follow_exports, {\n  isRecord: () => isRecord6,\n  validateRecord: () => validateRecord6\n});\nfunction isRecord6(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.graph.follow#main\" || v.$type === \"app.bsky.graph.follow\");\n}\nfunction validateRecord6(v) {\n  return lexicons.validate(\"app.bsky.graph.follow#main\", v);\n}\n\n// src/client/types/app/bsky/richtext/facet.ts\nvar facet_exports = {};\n__export(facet_exports, {\n  isByteSlice: () => isByteSlice,\n  isLink: () => isLink,\n  isMain: () => isMain6,\n  isMention: () => isMention,\n  validateByteSlice: () => validateByteSlice,\n  validateLink: () => validateLink,\n  validateMain: () => validateMain6,\n  validateMention: () => validateMention\n});\nfunction isMain6(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && (v.$type === \"app.bsky.richtext.facet#main\" || v.$type === \"app.bsky.richtext.facet\");\n}\nfunction validateMain6(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#main\", v);\n}\nfunction isMention(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.richtext.facet#mention\";\n}\nfunction validateMention(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#mention\", v);\n}\nfunction isLink(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.richtext.facet#link\";\n}\nfunction validateLink(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#link\", v);\n}\nfunction isByteSlice(v) {\n  return isObj2(v) && hasProp2(v, \"$type\") && v.$type === \"app.bsky.richtext.facet#byteSlice\";\n}\nfunction validateByteSlice(v) {\n  return lexicons.validate(\"app.bsky.richtext.facet#byteSlice\", v);\n}\n\n// src/client/index.ts\nvar COM_ATPROTO_ADMIN = {\n  DefsTakedown: \"com.atproto.admin.defs#takedown\",\n  DefsFlag: \"com.atproto.admin.defs#flag\",\n  DefsAcknowledge: \"com.atproto.admin.defs#acknowledge\"\n};\nvar COM_ATPROTO_MODERATION = {\n  DefsReasonSpam: \"com.atproto.moderation.defs#reasonSpam\",\n  DefsReasonOther: \"com.atproto.moderation.defs#reasonOther\"\n};\nvar AtpBaseClient = class {\n  constructor() {\n    this.xrpc = new Client();\n    this.xrpc.addLexicons(schemas);\n  }\n  service(serviceUri) {\n    return new AtpServiceClient(this, this.xrpc.service(serviceUri));\n  }\n};\nvar AtpServiceClient = class {\n  constructor(baseClient, xrpcService) {\n    this._baseClient = baseClient;\n    this.xrpc = xrpcService;\n    this.com = new ComNS(this);\n    this.app = new AppNS(this);\n  }\n  setHeader(key, value) {\n    this.xrpc.setHeader(key, value);\n  }\n};\nvar ComNS = class {\n  constructor(service) {\n    this._service = service;\n    this.atproto = new AtprotoNS(service);\n  }\n};\nvar AtprotoNS = class {\n  constructor(service) {\n    this._service = service;\n    this.admin = new AdminNS(service);\n    this.identity = new IdentityNS(service);\n    this.label = new LabelNS(service);\n    this.moderation = new ModerationNS(service);\n    this.repo = new RepoNS(service);\n    this.server = new ServerNS(service);\n    this.sync = new SyncNS(service);\n  }\n};\nvar AdminNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  disableInviteCodes(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.disableInviteCodes\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr(e);\n    });\n  }\n  getInviteCodes(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getInviteCodes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr2(e);\n    });\n  }\n  getModerationAction(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationAction\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr3(e);\n    });\n  }\n  getModerationActions(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationActions\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr4(e);\n    });\n  }\n  getModerationReport(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationReport\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr5(e);\n    });\n  }\n  getModerationReports(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getModerationReports\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr6(e);\n    });\n  }\n  getRecord(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getRecord\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr7(e);\n    });\n  }\n  getRepo(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.getRepo\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr8(e);\n    });\n  }\n  resolveModerationReports(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.resolveModerationReports\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr9(e);\n    });\n  }\n  reverseModerationAction(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.reverseModerationAction\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr10(e);\n    });\n  }\n  searchRepos(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.searchRepos\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr11(e);\n    });\n  }\n  takeModerationAction(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.takeModerationAction\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr12(e);\n    });\n  }\n  updateAccountHandle(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.admin.updateAccountHandle\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr13(e);\n    });\n  }\n};\nvar IdentityNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  resolveHandle(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.identity.resolveHandle\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr14(e);\n    });\n  }\n  updateHandle(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.identity.updateHandle\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr15(e);\n    });\n  }\n};\nvar LabelNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  queryLabels(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.label.queryLabels\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr16(e);\n    });\n  }\n};\nvar ModerationNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  createReport(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.moderation.createReport\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr17(e);\n    });\n  }\n};\nvar RepoNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  applyWrites(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.applyWrites\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr18(e);\n    });\n  }\n  createRecord(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.createRecord\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr19(e);\n    });\n  }\n  deleteRecord(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.deleteRecord\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr20(e);\n    });\n  }\n  describeRepo(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.describeRepo\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr21(e);\n    });\n  }\n  getRecord(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.getRecord\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr22(e);\n    });\n  }\n  listRecords(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.listRecords\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr23(e);\n    });\n  }\n  putRecord(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.putRecord\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr24(e);\n    });\n  }\n  uploadBlob(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.repo.uploadBlob\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr25(e);\n    });\n  }\n};\nvar ServerNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  createAccount(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createAccount\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr26(e);\n    });\n  }\n  createInviteCode(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createInviteCode\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr27(e);\n    });\n  }\n  createInviteCodes(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createInviteCodes\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr28(e);\n    });\n  }\n  createSession(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.createSession\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr29(e);\n    });\n  }\n  deleteAccount(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.deleteAccount\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr30(e);\n    });\n  }\n  deleteSession(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.deleteSession\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr31(e);\n    });\n  }\n  describeServer(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.describeServer\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr32(e);\n    });\n  }\n  getAccountInviteCodes(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.getAccountInviteCodes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr33(e);\n    });\n  }\n  getSession(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.getSession\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr34(e);\n    });\n  }\n  refreshSession(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.refreshSession\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr35(e);\n    });\n  }\n  requestAccountDelete(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.requestAccountDelete\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr36(e);\n    });\n  }\n  requestPasswordReset(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.requestPasswordReset\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr37(e);\n    });\n  }\n  resetPassword(data, opts) {\n    return this._service.xrpc.call(\"com.atproto.server.resetPassword\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr38(e);\n    });\n  }\n};\nvar SyncNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  getBlob(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getBlob\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr39(e);\n    });\n  }\n  getBlocks(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getBlocks\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr40(e);\n    });\n  }\n  getCheckout(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getCheckout\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr41(e);\n    });\n  }\n  getCommitPath(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getCommitPath\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr42(e);\n    });\n  }\n  getHead(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getHead\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr43(e);\n    });\n  }\n  getRecord(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getRecord\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr44(e);\n    });\n  }\n  getRepo(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.getRepo\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr45(e);\n    });\n  }\n  listBlobs(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.listBlobs\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr46(e);\n    });\n  }\n  listRepos(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.listRepos\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr47(e);\n    });\n  }\n  notifyOfUpdate(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.notifyOfUpdate\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr48(e);\n    });\n  }\n  requestCrawl(params2, opts) {\n    return this._service.xrpc.call(\"com.atproto.sync.requestCrawl\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr49(e);\n    });\n  }\n};\nvar AppNS = class {\n  constructor(service) {\n    this._service = service;\n    this.bsky = new BskyNS(service);\n  }\n};\nvar BskyNS = class {\n  constructor(service) {\n    this._service = service;\n    this.actor = new ActorNS(service);\n    this.embed = new EmbedNS(service);\n    this.feed = new FeedNS(service);\n    this.graph = new GraphNS(service);\n    this.notification = new NotificationNS(service);\n    this.richtext = new RichtextNS(service);\n    this.unspecced = new UnspeccedNS(service);\n  }\n};\nvar ActorNS = class {\n  constructor(service) {\n    this._service = service;\n    this.profile = new ProfileRecord(service);\n  }\n  getProfile(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.getProfile\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr50(e);\n    });\n  }\n  getProfiles(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.getProfiles\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr51(e);\n    });\n  }\n  getSuggestions(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.getSuggestions\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr52(e);\n    });\n  }\n  searchActors(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.searchActors\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr53(e);\n    });\n  }\n  searchActorsTypeahead(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.actor.searchActorsTypeahead\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr54(e);\n    });\n  }\n};\nvar ProfileRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.actor.profile\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.actor.profile\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.actor.profile\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.actor.profile\", rkey: \"self\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.actor.profile\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar EmbedNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n};\nvar FeedNS = class {\n  constructor(service) {\n    this._service = service;\n    this.like = new LikeRecord(service);\n    this.post = new PostRecord(service);\n    this.repost = new RepostRecord(service);\n  }\n  getAuthorFeed(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getAuthorFeed\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr55(e);\n    });\n  }\n  getLikes(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getLikes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr56(e);\n    });\n  }\n  getPostThread(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getPostThread\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr57(e);\n    });\n  }\n  getRepostedBy(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getRepostedBy\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr58(e);\n    });\n  }\n  getTimeline(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.feed.getTimeline\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr59(e);\n    });\n  }\n};\nvar LikeRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.feed.like\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.feed.like\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.feed.like\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.like\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.like\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar PostRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.feed.post\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.feed.post\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.feed.post\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.post\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.post\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar RepostRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.feed.repost\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.feed.repost\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.feed.repost\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.repost\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.feed.repost\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar GraphNS = class {\n  constructor(service) {\n    this._service = service;\n    this.follow = new FollowRecord(service);\n  }\n  getFollowers(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getFollowers\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr60(e);\n    });\n  }\n  getFollows(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getFollows\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr61(e);\n    });\n  }\n  getMutes(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.getMutes\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr62(e);\n    });\n  }\n  muteActor(data, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.muteActor\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr63(e);\n    });\n  }\n  unmuteActor(data, opts) {\n    return this._service.xrpc.call(\"app.bsky.graph.unmuteActor\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr64(e);\n    });\n  }\n};\nvar FollowRecord = class {\n  constructor(service) {\n    this._service = service;\n  }\n  async list(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.listRecords\", {\n      collection: \"app.bsky.graph.follow\",\n      ...params2\n    });\n    return res.data;\n  }\n  async get(params2) {\n    const res = await this._service.xrpc.call(\"com.atproto.repo.getRecord\", {\n      collection: \"app.bsky.graph.follow\",\n      ...params2\n    });\n    return res.data;\n  }\n  async create(params2, record, headers) {\n    record.$type = \"app.bsky.graph.follow\";\n    const res = await this._service.xrpc.call(\n      \"com.atproto.repo.createRecord\",\n      void 0,\n      { collection: \"app.bsky.graph.follow\", ...params2, record },\n      { encoding: \"application/json\", headers }\n    );\n    return res.data;\n  }\n  async delete(params2, headers) {\n    await this._service.xrpc.call(\n      \"com.atproto.repo.deleteRecord\",\n      void 0,\n      { collection: \"app.bsky.graph.follow\", ...params2 },\n      { headers }\n    );\n  }\n};\nvar NotificationNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  getUnreadCount(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.notification.getUnreadCount\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr65(e);\n    });\n  }\n  listNotifications(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.notification.listNotifications\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr66(e);\n    });\n  }\n  updateSeen(data, opts) {\n    return this._service.xrpc.call(\"app.bsky.notification.updateSeen\", opts?.qp, data, opts).catch((e) => {\n      throw toKnownErr67(e);\n    });\n  }\n};\nvar RichtextNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n};\nvar UnspeccedNS = class {\n  constructor(service) {\n    this._service = service;\n  }\n  getPopular(params2, opts) {\n    return this._service.xrpc.call(\"app.bsky.unspecced.getPopular\", params2, void 0, opts).catch((e) => {\n      throw toKnownErr68(e);\n    });\n  }\n};\n\n// src/agent.ts\nvar REFRESH_SESSION = \"com.atproto.server.refreshSession\";\nvar _AtpAgent = class {\n  constructor(opts) {\n    this.uploadBlob = (data, opts) => this.api.com.atproto.repo.uploadBlob(data, opts);\n    this.resolveHandle = (params2, opts) => this.api.com.atproto.identity.resolveHandle(params2, opts);\n    this.updateHandle = (data, opts) => this.api.com.atproto.identity.updateHandle(data, opts);\n    this.createModerationReport = (data, opts) => this.api.com.atproto.moderation.createReport(data, opts);\n    this.service = opts.service instanceof URL ? opts.service : new URL(opts.service);\n    this._persistSession = opts.persistSession;\n    this._baseClient = new AtpBaseClient();\n    this._baseClient.xrpc.fetch = this._fetch.bind(this);\n    this.api = this._baseClient.service(opts.service);\n  }\n  get com() {\n    return this.api.com;\n  }\n  static configure(opts) {\n    _AtpAgent.fetch = opts.fetch;\n  }\n  get hasSession() {\n    return !!this.session;\n  }\n  setPersistSessionHandler(handler) {\n    this._persistSession = handler;\n  }\n  async createAccount(opts) {\n    try {\n      const res = await this.api.com.atproto.server.createAccount({\n        handle: opts.handle,\n        password: opts.password,\n        email: opts.email,\n        inviteCode: opts.inviteCode\n      });\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: opts.email\n      };\n      return res;\n    } catch (e) {\n      this.session = void 0;\n      throw e;\n    } finally {\n      if (this.session) {\n        this._persistSession?.(\"create\", this.session);\n      } else {\n        this._persistSession?.(\"create-failed\", void 0);\n      }\n    }\n  }\n  async login(opts) {\n    try {\n      const res = await this.api.com.atproto.server.createSession({\n        identifier: opts.identifier,\n        password: opts.password\n      });\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: res.data.email\n      };\n      return res;\n    } catch (e) {\n      this.session = void 0;\n      throw e;\n    } finally {\n      if (this.session) {\n        this._persistSession?.(\"create\", this.session);\n      } else {\n        this._persistSession?.(\"create-failed\", void 0);\n      }\n    }\n  }\n  async resumeSession(session) {\n    try {\n      this.session = session;\n      const res = await this.api.com.atproto.server.getSession();\n      if (!res.success || res.data.did !== this.session.did) {\n        throw new Error(\"Invalid session\");\n      }\n      this.session.email = res.data.email;\n      this.session.handle = res.data.handle;\n      return res;\n    } catch (e) {\n      this.session = void 0;\n      throw e;\n    } finally {\n      if (this.session) {\n        this._persistSession?.(\"create\", this.session);\n      } else {\n        this._persistSession?.(\"create-failed\", void 0);\n      }\n    }\n  }\n  _addAuthHeader(reqHeaders) {\n    if (!reqHeaders.authorization && this.session?.accessJwt) {\n      return {\n        ...reqHeaders,\n        authorization: `Bearer ${this.session.accessJwt}`\n      };\n    }\n    return reqHeaders;\n  }\n  async _fetch(reqUri, reqMethod, reqHeaders, reqBody) {\n    if (!_AtpAgent.fetch) {\n      throw new Error(\"AtpAgent fetch() method not configured\");\n    }\n    await this._refreshSessionPromise;\n    let res = await _AtpAgent.fetch(\n      reqUri,\n      reqMethod,\n      this._addAuthHeader(reqHeaders),\n      reqBody\n    );\n    if (isErrorResponse(res, [\"ExpiredToken\"]) && this.session?.refreshJwt) {\n      await this._refreshSession();\n      res = await _AtpAgent.fetch(\n        reqUri,\n        reqMethod,\n        this._addAuthHeader(reqHeaders),\n        reqBody\n      );\n    }\n    return res;\n  }\n  async _refreshSession() {\n    if (this._refreshSessionPromise) {\n      return this._refreshSessionPromise;\n    }\n    this._refreshSessionPromise = this._refreshSessionInner();\n    try {\n      await this._refreshSessionPromise;\n    } finally {\n      this._refreshSessionPromise = void 0;\n    }\n  }\n  async _refreshSessionInner() {\n    if (!_AtpAgent.fetch) {\n      throw new Error(\"AtpAgent fetch() method not configured\");\n    }\n    if (!this.session?.refreshJwt) {\n      return;\n    }\n    const url = new URL(this.service.origin);\n    url.pathname = `/xrpc/${REFRESH_SESSION}`;\n    const res = await _AtpAgent.fetch(\n      url.toString(),\n      \"POST\",\n      {\n        authorization: `Bearer ${this.session.refreshJwt}`\n      },\n      void 0\n    );\n    if (isErrorResponse(res, [\"ExpiredToken\", \"InvalidToken\"])) {\n      this.session = void 0;\n      this._persistSession?.(\"expired\", void 0);\n    } else if (isNewSessionObject(this._baseClient, res.body)) {\n      this.session = {\n        accessJwt: res.body.accessJwt,\n        refreshJwt: res.body.refreshJwt,\n        handle: res.body.handle,\n        did: res.body.did\n      };\n      this._persistSession?.(\"update\", this.session);\n    }\n  }\n};\nvar AtpAgent = _AtpAgent;\nAtpAgent.fetch = defaultFetchHandler;\nfunction isErrorObject(v) {\n  return errorResponseBody.safeParse(v).success;\n}\nfunction isErrorResponse(res, errorNames) {\n  if (res.status !== 400) {\n    return false;\n  }\n  if (!isErrorObject(res.body)) {\n    return false;\n  }\n  return typeof res.body.error === \"string\" && errorNames.includes(res.body.error);\n}\nfunction isNewSessionObject(client, v) {\n  try {\n    client.xrpc.lex.assertValidXrpcOutput(\n      \"com.atproto.server.refreshSession\",\n      v\n    );\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// src/rich-text/unicode.ts\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar UnicodeString = class {\n  constructor(utf16) {\n    this.utf16 = utf16;\n    this.utf8 = encoder.encode(utf16);\n  }\n  get length() {\n    return this.utf8.byteLength;\n  }\n  get graphemeLength() {\n    if (!this._graphemeLen) {\n      this._graphemeLen = graphemeLen(this.utf16);\n    }\n    return this._graphemeLen;\n  }\n  slice(start, end) {\n    return decoder.decode(this.utf8.slice(start, end));\n  }\n  utf16IndexToUtf8Index(i) {\n    return encoder.encode(this.utf16.slice(0, i)).byteLength;\n  }\n  toString() {\n    return this.utf16;\n  }\n};\n\n// src/rich-text/sanitization.ts\nvar EXCESS_SPACE_RE = /[\\r\\n]([\\u00AD\\u2060\\u200D\\u200C\\u200B\\s]*[\\r\\n]){2,}/;\nvar REPLACEMENT_STR = \"\\n\\n\";\nfunction sanitizeRichText(richText, opts) {\n  if (opts.cleanNewlines) {\n    richText = clean(richText, EXCESS_SPACE_RE, REPLACEMENT_STR);\n  }\n  return richText;\n}\nfunction clean(richText, targetRegexp, replacementString) {\n  richText = richText.clone();\n  let match = richText.unicodeText.utf16.match(targetRegexp);\n  while (match && typeof match.index !== \"undefined\") {\n    const oldText = richText.unicodeText;\n    const removeStartIndex = richText.unicodeText.utf16IndexToUtf8Index(\n      match.index\n    );\n    const removeEndIndex = removeStartIndex + new UnicodeString(match[0]).length;\n    richText.delete(removeStartIndex, removeEndIndex);\n    if (richText.unicodeText.utf16 === oldText.utf16) {\n      break;\n    }\n    richText.insert(removeStartIndex, replacementString);\n    match = richText.unicodeText.utf16.match(targetRegexp);\n  }\n  return richText;\n}\n\n// ../../node_modules/tlds/index.json\nvar tlds_default = [\n  \"aaa\",\n  \"aarp\",\n  \"abarth\",\n  \"abb\",\n  \"abbott\",\n  \"abbvie\",\n  \"abc\",\n  \"able\",\n  \"abogado\",\n  \"abudhabi\",\n  \"ac\",\n  \"academy\",\n  \"accenture\",\n  \"accountant\",\n  \"accountants\",\n  \"aco\",\n  \"actor\",\n  \"ad\",\n  \"ads\",\n  \"adult\",\n  \"ae\",\n  \"aeg\",\n  \"aero\",\n  \"aetna\",\n  \"af\",\n  \"afl\",\n  \"africa\",\n  \"ag\",\n  \"agakhan\",\n  \"agency\",\n  \"ai\",\n  \"aig\",\n  \"airbus\",\n  \"airforce\",\n  \"airtel\",\n  \"akdn\",\n  \"al\",\n  \"alfaromeo\",\n  \"alibaba\",\n  \"alipay\",\n  \"allfinanz\",\n  \"allstate\",\n  \"ally\",\n  \"alsace\",\n  \"alstom\",\n  \"am\",\n  \"amazon\",\n  \"americanexpress\",\n  \"americanfamily\",\n  \"amex\",\n  \"amfam\",\n  \"amica\",\n  \"amsterdam\",\n  \"analytics\",\n  \"android\",\n  \"anquan\",\n  \"anz\",\n  \"ao\",\n  \"aol\",\n  \"apartments\",\n  \"app\",\n  \"apple\",\n  \"aq\",\n  \"aquarelle\",\n  \"ar\",\n  \"arab\",\n  \"aramco\",\n  \"archi\",\n  \"army\",\n  \"arpa\",\n  \"art\",\n  \"arte\",\n  \"as\",\n  \"asda\",\n  \"asia\",\n  \"associates\",\n  \"at\",\n  \"athleta\",\n  \"attorney\",\n  \"au\",\n  \"auction\",\n  \"audi\",\n  \"audible\",\n  \"audio\",\n  \"auspost\",\n  \"author\",\n  \"auto\",\n  \"autos\",\n  \"avianca\",\n  \"aw\",\n  \"aws\",\n  \"ax\",\n  \"axa\",\n  \"az\",\n  \"azure\",\n  \"ba\",\n  \"baby\",\n  \"baidu\",\n  \"banamex\",\n  \"bananarepublic\",\n  \"band\",\n  \"bank\",\n  \"bar\",\n  \"barcelona\",\n  \"barclaycard\",\n  \"barclays\",\n  \"barefoot\",\n  \"bargains\",\n  \"baseball\",\n  \"basketball\",\n  \"bauhaus\",\n  \"bayern\",\n  \"bb\",\n  \"bbc\",\n  \"bbt\",\n  \"bbva\",\n  \"bcg\",\n  \"bcn\",\n  \"bd\",\n  \"be\",\n  \"beats\",\n  \"beauty\",\n  \"beer\",\n  \"bentley\",\n  \"berlin\",\n  \"best\",\n  \"bestbuy\",\n  \"bet\",\n  \"bf\",\n  \"bg\",\n  \"bh\",\n  \"bharti\",\n  \"bi\",\n  \"bible\",\n  \"bid\",\n  \"bike\",\n  \"bing\",\n  \"bingo\",\n  \"bio\",\n  \"biz\",\n  \"bj\",\n  \"black\",\n  \"blackfriday\",\n  \"blockbuster\",\n  \"blog\",\n  \"bloomberg\",\n  \"blue\",\n  \"bm\",\n  \"bms\",\n  \"bmw\",\n  \"bn\",\n  \"bnpparibas\",\n  \"bo\",\n  \"boats\",\n  \"boehringer\",\n  \"bofa\",\n  \"bom\",\n  \"bond\",\n  \"boo\",\n  \"book\",\n  \"booking\",\n  \"bosch\",\n  \"bostik\",\n  \"boston\",\n  \"bot\",\n  \"boutique\",\n  \"box\",\n  \"br\",\n  \"bradesco\",\n  \"bridgestone\",\n  \"broadway\",\n  \"broker\",\n  \"brother\",\n  \"brussels\",\n  \"bs\",\n  \"bt\",\n  \"build\",\n  \"builders\",\n  \"business\",\n  \"buy\",\n  \"buzz\",\n  \"bv\",\n  \"bw\",\n  \"by\",\n  \"bz\",\n  \"bzh\",\n  \"ca\",\n  \"cab\",\n  \"cafe\",\n  \"cal\",\n  \"call\",\n  \"calvinklein\",\n  \"cam\",\n  \"camera\",\n  \"camp\",\n  \"canon\",\n  \"capetown\",\n  \"capital\",\n  \"capitalone\",\n  \"car\",\n  \"caravan\",\n  \"cards\",\n  \"care\",\n  \"career\",\n  \"careers\",\n  \"cars\",\n  \"casa\",\n  \"case\",\n  \"cash\",\n  \"casino\",\n  \"cat\",\n  \"catering\",\n  \"catholic\",\n  \"cba\",\n  \"cbn\",\n  \"cbre\",\n  \"cbs\",\n  \"cc\",\n  \"cd\",\n  \"center\",\n  \"ceo\",\n  \"cern\",\n  \"cf\",\n  \"cfa\",\n  \"cfd\",\n  \"cg\",\n  \"ch\",\n  \"chanel\",\n  \"channel\",\n  \"charity\",\n  \"chase\",\n  \"chat\",\n  \"cheap\",\n  \"chintai\",\n  \"christmas\",\n  \"chrome\",\n  \"church\",\n  \"ci\",\n  \"cipriani\",\n  \"circle\",\n  \"cisco\",\n  \"citadel\",\n  \"citi\",\n  \"citic\",\n  \"city\",\n  \"cityeats\",\n  \"ck\",\n  \"cl\",\n  \"claims\",\n  \"cleaning\",\n  \"click\",\n  \"clinic\",\n  \"clinique\",\n  \"clothing\",\n  \"cloud\",\n  \"club\",\n  \"clubmed\",\n  \"cm\",\n  \"cn\",\n  \"co\",\n  \"coach\",\n  \"codes\",\n  \"coffee\",\n  \"college\",\n  \"cologne\",\n  \"com\",\n  \"comcast\",\n  \"commbank\",\n  \"community\",\n  \"company\",\n  \"compare\",\n  \"computer\",\n  \"comsec\",\n  \"condos\",\n  \"construction\",\n  \"consulting\",\n  \"contact\",\n  \"contractors\",\n  \"cooking\",\n  \"cookingchannel\",\n  \"cool\",\n  \"coop\",\n  \"corsica\",\n  \"country\",\n  \"coupon\",\n  \"coupons\",\n  \"courses\",\n  \"cpa\",\n  \"cr\",\n  \"credit\",\n  \"creditcard\",\n  \"creditunion\",\n  \"cricket\",\n  \"crown\",\n  \"crs\",\n  \"cruise\",\n  \"cruises\",\n  \"cu\",\n  \"cuisinella\",\n  \"cv\",\n  \"cw\",\n  \"cx\",\n  \"cy\",\n  \"cymru\",\n  \"cyou\",\n  \"cz\",\n  \"dabur\",\n  \"dad\",\n  \"dance\",\n  \"data\",\n  \"date\",\n  \"dating\",\n  \"datsun\",\n  \"day\",\n  \"dclk\",\n  \"dds\",\n  \"de\",\n  \"deal\",\n  \"dealer\",\n  \"deals\",\n  \"degree\",\n  \"delivery\",\n  \"dell\",\n  \"deloitte\",\n  \"delta\",\n  \"democrat\",\n  \"dental\",\n  \"dentist\",\n  \"desi\",\n  \"design\",\n  \"dev\",\n  \"dhl\",\n  \"diamonds\",\n  \"diet\",\n  \"digital\",\n  \"direct\",\n  \"directory\",\n  \"discount\",\n  \"discover\",\n  \"dish\",\n  \"diy\",\n  \"dj\",\n  \"dk\",\n  \"dm\",\n  \"dnp\",\n  \"do\",\n  \"docs\",\n  \"doctor\",\n  \"dog\",\n  \"domains\",\n  \"dot\",\n  \"download\",\n  \"drive\",\n  \"dtv\",\n  \"dubai\",\n  \"dunlop\",\n  \"dupont\",\n  \"durban\",\n  \"dvag\",\n  \"dvr\",\n  \"dz\",\n  \"earth\",\n  \"eat\",\n  \"ec\",\n  \"eco\",\n  \"edeka\",\n  \"edu\",\n  \"education\",\n  \"ee\",\n  \"eg\",\n  \"email\",\n  \"emerck\",\n  \"energy\",\n  \"engineer\",\n  \"engineering\",\n  \"enterprises\",\n  \"epson\",\n  \"equipment\",\n  \"er\",\n  \"ericsson\",\n  \"erni\",\n  \"es\",\n  \"esq\",\n  \"estate\",\n  \"et\",\n  \"etisalat\",\n  \"eu\",\n  \"eurovision\",\n  \"eus\",\n  \"events\",\n  \"exchange\",\n  \"expert\",\n  \"exposed\",\n  \"express\",\n  \"extraspace\",\n  \"fage\",\n  \"fail\",\n  \"fairwinds\",\n  \"faith\",\n  \"family\",\n  \"fan\",\n  \"fans\",\n  \"farm\",\n  \"farmers\",\n  \"fashion\",\n  \"fast\",\n  \"fedex\",\n  \"feedback\",\n  \"ferrari\",\n  \"ferrero\",\n  \"fi\",\n  \"fiat\",\n  \"fidelity\",\n  \"fido\",\n  \"film\",\n  \"final\",\n  \"finance\",\n  \"financial\",\n  \"fire\",\n  \"firestone\",\n  \"firmdale\",\n  \"fish\",\n  \"fishing\",\n  \"fit\",\n  \"fitness\",\n  \"fj\",\n  \"fk\",\n  \"flickr\",\n  \"flights\",\n  \"flir\",\n  \"florist\",\n  \"flowers\",\n  \"fly\",\n  \"fm\",\n  \"fo\",\n  \"foo\",\n  \"food\",\n  \"foodnetwork\",\n  \"football\",\n  \"ford\",\n  \"forex\",\n  \"forsale\",\n  \"forum\",\n  \"foundation\",\n  \"fox\",\n  \"fr\",\n  \"free\",\n  \"fresenius\",\n  \"frl\",\n  \"frogans\",\n  \"frontdoor\",\n  \"frontier\",\n  \"ftr\",\n  \"fujitsu\",\n  \"fun\",\n  \"fund\",\n  \"furniture\",\n  \"futbol\",\n  \"fyi\",\n  \"ga\",\n  \"gal\",\n  \"gallery\",\n  \"gallo\",\n  \"gallup\",\n  \"game\",\n  \"games\",\n  \"gap\",\n  \"garden\",\n  \"gay\",\n  \"gb\",\n  \"gbiz\",\n  \"gd\",\n  \"gdn\",\n  \"ge\",\n  \"gea\",\n  \"gent\",\n  \"genting\",\n  \"george\",\n  \"gf\",\n  \"gg\",\n  \"ggee\",\n  \"gh\",\n  \"gi\",\n  \"gift\",\n  \"gifts\",\n  \"gives\",\n  \"giving\",\n  \"gl\",\n  \"glass\",\n  \"gle\",\n  \"global\",\n  \"globo\",\n  \"gm\",\n  \"gmail\",\n  \"gmbh\",\n  \"gmo\",\n  \"gmx\",\n  \"gn\",\n  \"godaddy\",\n  \"gold\",\n  \"goldpoint\",\n  \"golf\",\n  \"goo\",\n  \"goodyear\",\n  \"goog\",\n  \"google\",\n  \"gop\",\n  \"got\",\n  \"gov\",\n  \"gp\",\n  \"gq\",\n  \"gr\",\n  \"grainger\",\n  \"graphics\",\n  \"gratis\",\n  \"green\",\n  \"gripe\",\n  \"grocery\",\n  \"group\",\n  \"gs\",\n  \"gt\",\n  \"gu\",\n  \"guardian\",\n  \"gucci\",\n  \"guge\",\n  \"guide\",\n  \"guitars\",\n  \"guru\",\n  \"gw\",\n  \"gy\",\n  \"hair\",\n  \"hamburg\",\n  \"hangout\",\n  \"haus\",\n  \"hbo\",\n  \"hdfc\",\n  \"hdfcbank\",\n  \"health\",\n  \"healthcare\",\n  \"help\",\n  \"helsinki\",\n  \"here\",\n  \"hermes\",\n  \"hgtv\",\n  \"hiphop\",\n  \"hisamitsu\",\n  \"hitachi\",\n  \"hiv\",\n  \"hk\",\n  \"hkt\",\n  \"hm\",\n  \"hn\",\n  \"hockey\",\n  \"holdings\",\n  \"holiday\",\n  \"homedepot\",\n  \"homegoods\",\n  \"homes\",\n  \"homesense\",\n  \"honda\",\n  \"horse\",\n  \"hospital\",\n  \"host\",\n  \"hosting\",\n  \"hot\",\n  \"hoteles\",\n  \"hotels\",\n  \"hotmail\",\n  \"house\",\n  \"how\",\n  \"hr\",\n  \"hsbc\",\n  \"ht\",\n  \"hu\",\n  \"hughes\",\n  \"hyatt\",\n  \"hyundai\",\n  \"ibm\",\n  \"icbc\",\n  \"ice\",\n  \"icu\",\n  \"id\",\n  \"ie\",\n  \"ieee\",\n  \"ifm\",\n  \"ikano\",\n  \"il\",\n  \"im\",\n  \"imamat\",\n  \"imdb\",\n  \"immo\",\n  \"immobilien\",\n  \"in\",\n  \"inc\",\n  \"industries\",\n  \"infiniti\",\n  \"info\",\n  \"ing\",\n  \"ink\",\n  \"institute\",\n  \"insurance\",\n  \"insure\",\n  \"int\",\n  \"international\",\n  \"intuit\",\n  \"investments\",\n  \"io\",\n  \"ipiranga\",\n  \"iq\",\n  \"ir\",\n  \"irish\",\n  \"is\",\n  \"ismaili\",\n  \"ist\",\n  \"istanbul\",\n  \"it\",\n  \"itau\",\n  \"itv\",\n  \"jaguar\",\n  \"java\",\n  \"jcb\",\n  \"je\",\n  \"jeep\",\n  \"jetzt\",\n  \"jewelry\",\n  \"jio\",\n  \"jll\",\n  \"jm\",\n  \"jmp\",\n  \"jnj\",\n  \"jo\",\n  \"jobs\",\n  \"joburg\",\n  \"jot\",\n  \"joy\",\n  \"jp\",\n  \"jpmorgan\",\n  \"jprs\",\n  \"juegos\",\n  \"juniper\",\n  \"kaufen\",\n  \"kddi\",\n  \"ke\",\n  \"kerryhotels\",\n  \"kerrylogistics\",\n  \"kerryproperties\",\n  \"kfh\",\n  \"kg\",\n  \"kh\",\n  \"ki\",\n  \"kia\",\n  \"kids\",\n  \"kim\",\n  \"kinder\",\n  \"kindle\",\n  \"kitchen\",\n  \"kiwi\",\n  \"km\",\n  \"kn\",\n  \"koeln\",\n  \"komatsu\",\n  \"kosher\",\n  \"kp\",\n  \"kpmg\",\n  \"kpn\",\n  \"kr\",\n  \"krd\",\n  \"kred\",\n  \"kuokgroup\",\n  \"kw\",\n  \"ky\",\n  \"kyoto\",\n  \"kz\",\n  \"la\",\n  \"lacaixa\",\n  \"lamborghini\",\n  \"lamer\",\n  \"lancaster\",\n  \"lancia\",\n  \"land\",\n  \"landrover\",\n  \"lanxess\",\n  \"lasalle\",\n  \"lat\",\n  \"latino\",\n  \"latrobe\",\n  \"law\",\n  \"lawyer\",\n  \"lb\",\n  \"lc\",\n  \"lds\",\n  \"lease\",\n  \"leclerc\",\n  \"lefrak\",\n  \"legal\",\n  \"lego\",\n  \"lexus\",\n  \"lgbt\",\n  \"li\",\n  \"lidl\",\n  \"life\",\n  \"lifeinsurance\",\n  \"lifestyle\",\n  \"lighting\",\n  \"like\",\n  \"lilly\",\n  \"limited\",\n  \"limo\",\n  \"lincoln\",\n  \"link\",\n  \"lipsy\",\n  \"live\",\n  \"living\",\n  \"lk\",\n  \"llc\",\n  \"llp\",\n  \"loan\",\n  \"loans\",\n  \"locker\",\n  \"locus\",\n  \"lol\",\n  \"london\",\n  \"lotte\",\n  \"lotto\",\n  \"love\",\n  \"lpl\",\n  \"lplfinancial\",\n  \"lr\",\n  \"ls\",\n  \"lt\",\n  \"ltd\",\n  \"ltda\",\n  \"lu\",\n  \"lundbeck\",\n  \"luxe\",\n  \"luxury\",\n  \"lv\",\n  \"ly\",\n  \"ma\",\n  \"madrid\",\n  \"maif\",\n  \"maison\",\n  \"makeup\",\n  \"man\",\n  \"management\",\n  \"mango\",\n  \"map\",\n  \"market\",\n  \"marketing\",\n  \"markets\",\n  \"marriott\",\n  \"marshalls\",\n  \"maserati\",\n  \"mattel\",\n  \"mba\",\n  \"mc\",\n  \"mckinsey\",\n  \"md\",\n  \"me\",\n  \"med\",\n  \"media\",\n  \"meet\",\n  \"melbourne\",\n  \"meme\",\n  \"memorial\",\n  \"men\",\n  \"menu\",\n  \"merckmsd\",\n  \"mg\",\n  \"mh\",\n  \"miami\",\n  \"microsoft\",\n  \"mil\",\n  \"mini\",\n  \"mint\",\n  \"mit\",\n  \"mitsubishi\",\n  \"mk\",\n  \"ml\",\n  \"mlb\",\n  \"mls\",\n  \"mm\",\n  \"mma\",\n  \"mn\",\n  \"mo\",\n  \"mobi\",\n  \"mobile\",\n  \"moda\",\n  \"moe\",\n  \"moi\",\n  \"mom\",\n  \"monash\",\n  \"money\",\n  \"monster\",\n  \"mormon\",\n  \"mortgage\",\n  \"moscow\",\n  \"moto\",\n  \"motorcycles\",\n  \"mov\",\n  \"movie\",\n  \"mp\",\n  \"mq\",\n  \"mr\",\n  \"ms\",\n  \"msd\",\n  \"mt\",\n  \"mtn\",\n  \"mtr\",\n  \"mu\",\n  \"museum\",\n  \"music\",\n  \"mutual\",\n  \"mv\",\n  \"mw\",\n  \"mx\",\n  \"my\",\n  \"mz\",\n  \"na\",\n  \"nab\",\n  \"nagoya\",\n  \"name\",\n  \"natura\",\n  \"navy\",\n  \"nba\",\n  \"nc\",\n  \"ne\",\n  \"nec\",\n  \"net\",\n  \"netbank\",\n  \"netflix\",\n  \"network\",\n  \"neustar\",\n  \"new\",\n  \"news\",\n  \"next\",\n  \"nextdirect\",\n  \"nexus\",\n  \"nf\",\n  \"nfl\",\n  \"ng\",\n  \"ngo\",\n  \"nhk\",\n  \"ni\",\n  \"nico\",\n  \"nike\",\n  \"nikon\",\n  \"ninja\",\n  \"nissan\",\n  \"nissay\",\n  \"nl\",\n  \"no\",\n  \"nokia\",\n  \"northwesternmutual\",\n  \"norton\",\n  \"now\",\n  \"nowruz\",\n  \"nowtv\",\n  \"np\",\n  \"nr\",\n  \"nra\",\n  \"nrw\",\n  \"ntt\",\n  \"nu\",\n  \"nyc\",\n  \"nz\",\n  \"obi\",\n  \"observer\",\n  \"office\",\n  \"okinawa\",\n  \"olayan\",\n  \"olayangroup\",\n  \"oldnavy\",\n  \"ollo\",\n  \"om\",\n  \"omega\",\n  \"one\",\n  \"ong\",\n  \"onl\",\n  \"online\",\n  \"ooo\",\n  \"open\",\n  \"oracle\",\n  \"orange\",\n  \"org\",\n  \"organic\",\n  \"origins\",\n  \"osaka\",\n  \"otsuka\",\n  \"ott\",\n  \"ovh\",\n  \"pa\",\n  \"page\",\n  \"panasonic\",\n  \"paris\",\n  \"pars\",\n  \"partners\",\n  \"parts\",\n  \"party\",\n  \"passagens\",\n  \"pay\",\n  \"pccw\",\n  \"pe\",\n  \"pet\",\n  \"pf\",\n  \"pfizer\",\n  \"pg\",\n  \"ph\",\n  \"pharmacy\",\n  \"phd\",\n  \"philips\",\n  \"phone\",\n  \"photo\",\n  \"photography\",\n  \"photos\",\n  \"physio\",\n  \"pics\",\n  \"pictet\",\n  \"pictures\",\n  \"pid\",\n  \"pin\",\n  \"ping\",\n  \"pink\",\n  \"pioneer\",\n  \"pizza\",\n  \"pk\",\n  \"pl\",\n  \"place\",\n  \"play\",\n  \"playstation\",\n  \"plumbing\",\n  \"plus\",\n  \"pm\",\n  \"pn\",\n  \"pnc\",\n  \"pohl\",\n  \"poker\",\n  \"politie\",\n  \"porn\",\n  \"post\",\n  \"pr\",\n  \"pramerica\",\n  \"praxi\",\n  \"press\",\n  \"prime\",\n  \"pro\",\n  \"prod\",\n  \"productions\",\n  \"prof\",\n  \"progressive\",\n  \"promo\",\n  \"properties\",\n  \"property\",\n  \"protection\",\n  \"pru\",\n  \"prudential\",\n  \"ps\",\n  \"pt\",\n  \"pub\",\n  \"pw\",\n  \"pwc\",\n  \"py\",\n  \"qa\",\n  \"qpon\",\n  \"quebec\",\n  \"quest\",\n  \"racing\",\n  \"radio\",\n  \"re\",\n  \"read\",\n  \"realestate\",\n  \"realtor\",\n  \"realty\",\n  \"recipes\",\n  \"red\",\n  \"redstone\",\n  \"redumbrella\",\n  \"rehab\",\n  \"reise\",\n  \"reisen\",\n  \"reit\",\n  \"reliance\",\n  \"ren\",\n  \"rent\",\n  \"rentals\",\n  \"repair\",\n  \"report\",\n  \"republican\",\n  \"rest\",\n  \"restaurant\",\n  \"review\",\n  \"reviews\",\n  \"rexroth\",\n  \"rich\",\n  \"richardli\",\n  \"ricoh\",\n  \"ril\",\n  \"rio\",\n  \"rip\",\n  \"ro\",\n  \"rocher\",\n  \"rocks\",\n  \"rodeo\",\n  \"rogers\",\n  \"room\",\n  \"rs\",\n  \"rsvp\",\n  \"ru\",\n  \"rugby\",\n  \"ruhr\",\n  \"run\",\n  \"rw\",\n  \"rwe\",\n  \"ryukyu\",\n  \"sa\",\n  \"saarland\",\n  \"safe\",\n  \"safety\",\n  \"sakura\",\n  \"sale\",\n  \"salon\",\n  \"samsclub\",\n  \"samsung\",\n  \"sandvik\",\n  \"sandvikcoromant\",\n  \"sanofi\",\n  \"sap\",\n  \"sarl\",\n  \"sas\",\n  \"save\",\n  \"saxo\",\n  \"sb\",\n  \"sbi\",\n  \"sbs\",\n  \"sc\",\n  \"sca\",\n  \"scb\",\n  \"schaeffler\",\n  \"schmidt\",\n  \"scholarships\",\n  \"school\",\n  \"schule\",\n  \"schwarz\",\n  \"science\",\n  \"scot\",\n  \"sd\",\n  \"se\",\n  \"search\",\n  \"seat\",\n  \"secure\",\n  \"security\",\n  \"seek\",\n  \"select\",\n  \"sener\",\n  \"services\",\n  \"seven\",\n  \"sew\",\n  \"sex\",\n  \"sexy\",\n  \"sfr\",\n  \"sg\",\n  \"sh\",\n  \"shangrila\",\n  \"sharp\",\n  \"shaw\",\n  \"shell\",\n  \"shia\",\n  \"shiksha\",\n  \"shoes\",\n  \"shop\",\n  \"shopping\",\n  \"shouji\",\n  \"show\",\n  \"showtime\",\n  \"si\",\n  \"silk\",\n  \"sina\",\n  \"singles\",\n  \"site\",\n  \"sj\",\n  \"sk\",\n  \"ski\",\n  \"skin\",\n  \"sky\",\n  \"skype\",\n  \"sl\",\n  \"sling\",\n  \"sm\",\n  \"smart\",\n  \"smile\",\n  \"sn\",\n  \"sncf\",\n  \"so\",\n  \"soccer\",\n  \"social\",\n  \"softbank\",\n  \"software\",\n  \"sohu\",\n  \"solar\",\n  \"solutions\",\n  \"song\",\n  \"sony\",\n  \"soy\",\n  \"spa\",\n  \"space\",\n  \"sport\",\n  \"spot\",\n  \"sr\",\n  \"srl\",\n  \"ss\",\n  \"st\",\n  \"stada\",\n  \"staples\",\n  \"star\",\n  \"statebank\",\n  \"statefarm\",\n  \"stc\",\n  \"stcgroup\",\n  \"stockholm\",\n  \"storage\",\n  \"store\",\n  \"stream\",\n  \"studio\",\n  \"study\",\n  \"style\",\n  \"su\",\n  \"sucks\",\n  \"supplies\",\n  \"supply\",\n  \"support\",\n  \"surf\",\n  \"surgery\",\n  \"suzuki\",\n  \"sv\",\n  \"swatch\",\n  \"swiss\",\n  \"sx\",\n  \"sy\",\n  \"sydney\",\n  \"systems\",\n  \"sz\",\n  \"tab\",\n  \"taipei\",\n  \"talk\",\n  \"taobao\",\n  \"target\",\n  \"tatamotors\",\n  \"tatar\",\n  \"tattoo\",\n  \"tax\",\n  \"taxi\",\n  \"tc\",\n  \"tci\",\n  \"td\",\n  \"tdk\",\n  \"team\",\n  \"tech\",\n  \"technology\",\n  \"tel\",\n  \"temasek\",\n  \"tennis\",\n  \"teva\",\n  \"tf\",\n  \"tg\",\n  \"th\",\n  \"thd\",\n  \"theater\",\n  \"theatre\",\n  \"tiaa\",\n  \"tickets\",\n  \"tienda\",\n  \"tiffany\",\n  \"tips\",\n  \"tires\",\n  \"tirol\",\n  \"tj\",\n  \"tjmaxx\",\n  \"tjx\",\n  \"tk\",\n  \"tkmaxx\",\n  \"tl\",\n  \"tm\",\n  \"tmall\",\n  \"tn\",\n  \"to\",\n  \"today\",\n  \"tokyo\",\n  \"tools\",\n  \"top\",\n  \"toray\",\n  \"toshiba\",\n  \"total\",\n  \"tours\",\n  \"town\",\n  \"toyota\",\n  \"toys\",\n  \"tr\",\n  \"trade\",\n  \"trading\",\n  \"training\",\n  \"travel\",\n  \"travelchannel\",\n  \"travelers\",\n  \"travelersinsurance\",\n  \"trust\",\n  \"trv\",\n  \"tt\",\n  \"tube\",\n  \"tui\",\n  \"tunes\",\n  \"tushu\",\n  \"tv\",\n  \"tvs\",\n  \"tw\",\n  \"tz\",\n  \"ua\",\n  \"ubank\",\n  \"ubs\",\n  \"ug\",\n  \"uk\",\n  \"unicom\",\n  \"university\",\n  \"uno\",\n  \"uol\",\n  \"ups\",\n  \"us\",\n  \"uy\",\n  \"uz\",\n  \"va\",\n  \"vacations\",\n  \"vana\",\n  \"vanguard\",\n  \"vc\",\n  \"ve\",\n  \"vegas\",\n  \"ventures\",\n  \"verisign\",\n  \"verm\\xF6gensberater\",\n  \"verm\\xF6gensberatung\",\n  \"versicherung\",\n  \"vet\",\n  \"vg\",\n  \"vi\",\n  \"viajes\",\n  \"video\",\n  \"vig\",\n  \"viking\",\n  \"villas\",\n  \"vin\",\n  \"vip\",\n  \"virgin\",\n  \"visa\",\n  \"vision\",\n  \"viva\",\n  \"vivo\",\n  \"vlaanderen\",\n  \"vn\",\n  \"vodka\",\n  \"volkswagen\",\n  \"volvo\",\n  \"vote\",\n  \"voting\",\n  \"voto\",\n  \"voyage\",\n  \"vu\",\n  \"vuelos\",\n  \"wales\",\n  \"walmart\",\n  \"walter\",\n  \"wang\",\n  \"wanggou\",\n  \"watch\",\n  \"watches\",\n  \"weather\",\n  \"weatherchannel\",\n  \"webcam\",\n  \"weber\",\n  \"website\",\n  \"wed\",\n  \"wedding\",\n  \"weibo\",\n  \"weir\",\n  \"wf\",\n  \"whoswho\",\n  \"wien\",\n  \"wiki\",\n  \"williamhill\",\n  \"win\",\n  \"windows\",\n  \"wine\",\n  \"winners\",\n  \"wme\",\n  \"wolterskluwer\",\n  \"woodside\",\n  \"work\",\n  \"works\",\n  \"world\",\n  \"wow\",\n  \"ws\",\n  \"wtc\",\n  \"wtf\",\n  \"xbox\",\n  \"xerox\",\n  \"xfinity\",\n  \"xihuan\",\n  \"xin\",\n  \"xxx\",\n  \"xyz\",\n  \"yachts\",\n  \"yahoo\",\n  \"yamaxun\",\n  \"yandex\",\n  \"ye\",\n  \"yodobashi\",\n  \"yoga\",\n  \"yokohama\",\n  \"you\",\n  \"youtube\",\n  \"yt\",\n  \"yun\",\n  \"za\",\n  \"zappos\",\n  \"zara\",\n  \"zero\",\n  \"zip\",\n  \"zm\",\n  \"zone\",\n  \"zuerich\",\n  \"zw\",\n  \"\\u03B5\\u03BB\",\n  \"\\u03B5\\u03C5\",\n  \"\\u0431\\u0433\",\n  \"\\u0431\\u0435\\u043B\",\n  \"\\u0434\\u0435\\u0442\\u0438\",\n  \"\\u0435\\u044E\",\n  \"\\u043A\\u0430\\u0442\\u043E\\u043B\\u0438\\u043A\",\n  \"\\u043A\\u043E\\u043C\",\n  \"\\u043C\\u043A\\u0434\",\n  \"\\u043C\\u043E\\u043D\",\n  \"\\u043C\\u043E\\u0441\\u043A\\u0432\\u0430\",\n  \"\\u043E\\u043D\\u043B\\u0430\\u0439\\u043D\",\n  \"\\u043E\\u0440\\u0433\",\n  \"\\u0440\\u0443\\u0441\",\n  \"\\u0440\\u0444\",\n  \"\\u0441\\u0430\\u0439\\u0442\",\n  \"\\u0441\\u0440\\u0431\",\n  \"\\u0443\\u043A\\u0440\",\n  \"\\u049B\\u0430\\u0437\",\n  \"\\u0570\\u0561\\u0575\",\n  \"\\u05D9\\u05E9\\u05E8\\u05D0\\u05DC\",\n  \"\\u05E7\\u05D5\\u05DD\",\n  \"\\u0627\\u0628\\u0648\\u0638\\u0628\\u064A\",\n  \"\\u0627\\u062A\\u0635\\u0627\\u0644\\u0627\\u062A\",\n  \"\\u0627\\u0631\\u0627\\u0645\\u0643\\u0648\",\n  \"\\u0627\\u0644\\u0627\\u0631\\u062F\\u0646\",\n  \"\\u0627\\u0644\\u0628\\u062D\\u0631\\u064A\\u0646\",\n  \"\\u0627\\u0644\\u062C\\u0632\\u0627\\u0626\\u0631\",\n  \"\\u0627\\u0644\\u0633\\u0639\\u0648\\u062F\\u064A\\u0629\",\n  \"\\u0627\\u0644\\u0639\\u0644\\u064A\\u0627\\u0646\",\n  \"\\u0627\\u0644\\u0645\\u063A\\u0631\\u0628\",\n  \"\\u0627\\u0645\\u0627\\u0631\\u0627\\u062A\",\n  \"\\u0627\\u06CC\\u0631\\u0627\\u0646\",\n  \"\\u0628\\u0627\\u0631\\u062A\",\n  \"\\u0628\\u0627\\u0632\\u0627\\u0631\",\n  \"\\u0628\\u064A\\u062A\\u0643\",\n  \"\\u0628\\u06BE\\u0627\\u0631\\u062A\",\n  \"\\u062A\\u0648\\u0646\\u0633\",\n  \"\\u0633\\u0648\\u062F\\u0627\\u0646\",\n  \"\\u0633\\u0648\\u0631\\u064A\\u0629\",\n  \"\\u0634\\u0628\\u0643\\u0629\",\n  \"\\u0639\\u0631\\u0627\\u0642\",\n  \"\\u0639\\u0631\\u0628\",\n  \"\\u0639\\u0645\\u0627\\u0646\",\n  \"\\u0641\\u0644\\u0633\\u0637\\u064A\\u0646\",\n  \"\\u0642\\u0637\\u0631\",\n  \"\\u0643\\u0627\\u062B\\u0648\\u0644\\u064A\\u0643\",\n  \"\\u0643\\u0648\\u0645\",\n  \"\\u0645\\u0635\\u0631\",\n  \"\\u0645\\u0644\\u064A\\u0633\\u064A\\u0627\",\n  \"\\u0645\\u0648\\u0631\\u064A\\u062A\\u0627\\u0646\\u064A\\u0627\",\n  \"\\u0645\\u0648\\u0642\\u0639\",\n  \"\\u0647\\u0645\\u0631\\u0627\\u0647\",\n  \"\\u067E\\u0627\\u06A9\\u0633\\u062A\\u0627\\u0646\",\n  \"\\u0680\\u0627\\u0631\\u062A\",\n  \"\\u0915\\u0949\\u092E\",\n  \"\\u0928\\u0947\\u091F\",\n  \"\\u092D\\u093E\\u0930\\u0924\",\n  \"\\u092D\\u093E\\u0930\\u0924\\u092E\\u094D\",\n  \"\\u092D\\u093E\\u0930\\u094B\\u0924\",\n  \"\\u0938\\u0902\\u0917\\u0920\\u0928\",\n  \"\\u09AC\\u09BE\\u0982\\u09B2\\u09BE\",\n  \"\\u09AD\\u09BE\\u09B0\\u09A4\",\n  \"\\u09AD\\u09BE\\u09F0\\u09A4\",\n  \"\\u0A2D\\u0A3E\\u0A30\\u0A24\",\n  \"\\u0AAD\\u0ABE\\u0AB0\\u0AA4\",\n  \"\\u0B2D\\u0B3E\\u0B30\\u0B24\",\n  \"\\u0B87\\u0BA8\\u0BCD\\u0BA4\\u0BBF\\u0BAF\\u0BBE\",\n  \"\\u0B87\\u0BB2\\u0B99\\u0BCD\\u0B95\\u0BC8\",\n  \"\\u0B9A\\u0BBF\\u0B99\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0BC2\\u0BB0\\u0BCD\",\n  \"\\u0C2D\\u0C3E\\u0C30\\u0C24\\u0C4D\",\n  \"\\u0CAD\\u0CBE\\u0CB0\\u0CA4\",\n  \"\\u0D2D\\u0D3E\\u0D30\\u0D24\\u0D02\",\n  \"\\u0DBD\\u0D82\\u0D9A\\u0DCF\",\n  \"\\u0E04\\u0E2D\\u0E21\",\n  \"\\u0E44\\u0E17\\u0E22\",\n  \"\\u0EA5\\u0EB2\\u0EA7\",\n  \"\\u10D2\\u10D4\",\n  \"\\u307F\\u3093\\u306A\",\n  \"\\u30A2\\u30DE\\u30BE\\u30F3\",\n  \"\\u30AF\\u30E9\\u30A6\\u30C9\",\n  \"\\u30B0\\u30FC\\u30B0\\u30EB\",\n  \"\\u30B3\\u30E0\",\n  \"\\u30B9\\u30C8\\u30A2\",\n  \"\\u30BB\\u30FC\\u30EB\",\n  \"\\u30D5\\u30A1\\u30C3\\u30B7\\u30E7\\u30F3\",\n  \"\\u30DD\\u30A4\\u30F3\\u30C8\",\n  \"\\u4E16\\u754C\",\n  \"\\u4E2D\\u4FE1\",\n  \"\\u4E2D\\u56FD\",\n  \"\\u4E2D\\u570B\",\n  \"\\u4E2D\\u6587\\u7F51\",\n  \"\\u4E9A\\u9A6C\\u900A\",\n  \"\\u4F01\\u4E1A\",\n  \"\\u4F5B\\u5C71\",\n  \"\\u4FE1\\u606F\",\n  \"\\u5065\\u5EB7\",\n  \"\\u516B\\u5366\",\n  \"\\u516C\\u53F8\",\n  \"\\u516C\\u76CA\",\n  \"\\u53F0\\u6E7E\",\n  \"\\u53F0\\u7063\",\n  \"\\u5546\\u57CE\",\n  \"\\u5546\\u5E97\",\n  \"\\u5546\\u6807\",\n  \"\\u5609\\u91CC\",\n  \"\\u5609\\u91CC\\u5927\\u9152\\u5E97\",\n  \"\\u5728\\u7EBF\",\n  \"\\u5927\\u62FF\",\n  \"\\u5929\\u4E3B\\u6559\",\n  \"\\u5A31\\u4E50\",\n  \"\\u5BB6\\u96FB\",\n  \"\\u5E7F\\u4E1C\",\n  \"\\u5FAE\\u535A\",\n  \"\\u6148\\u5584\",\n  \"\\u6211\\u7231\\u4F60\",\n  \"\\u624B\\u673A\",\n  \"\\u62DB\\u8058\",\n  \"\\u653F\\u52A1\",\n  \"\\u653F\\u5E9C\",\n  \"\\u65B0\\u52A0\\u5761\",\n  \"\\u65B0\\u95FB\",\n  \"\\u65F6\\u5C1A\",\n  \"\\u66F8\\u7C4D\",\n  \"\\u673A\\u6784\",\n  \"\\u6DE1\\u9A6C\\u9521\",\n  \"\\u6E38\\u620F\",\n  \"\\u6FB3\\u9580\",\n  \"\\u70B9\\u770B\",\n  \"\\u79FB\\u52A8\",\n  \"\\u7EC4\\u7EC7\\u673A\\u6784\",\n  \"\\u7F51\\u5740\",\n  \"\\u7F51\\u5E97\",\n  \"\\u7F51\\u7AD9\",\n  \"\\u7F51\\u7EDC\",\n  \"\\u8054\\u901A\",\n  \"\\u8C37\\u6B4C\",\n  \"\\u8D2D\\u7269\",\n  \"\\u901A\\u8CA9\",\n  \"\\u96C6\\u56E2\",\n  \"\\u96FB\\u8A0A\\u76C8\\u79D1\",\n  \"\\u98DE\\u5229\\u6D66\",\n  \"\\u98DF\\u54C1\",\n  \"\\u9910\\u5385\",\n  \"\\u9999\\u683C\\u91CC\\u62C9\",\n  \"\\u9999\\u6E2F\",\n  \"\\uB2F7\\uB137\",\n  \"\\uB2F7\\uCEF4\",\n  \"\\uC0BC\\uC131\",\n  \"\\uD55C\\uAD6D\"\n];\n\n// src/rich-text/detection.ts\nfunction detectFacets(text) {\n  let match;\n  const facets = [];\n  {\n    const re = /(^|\\s|\\()(@)([a-zA-Z0-9.-]+)(\\b)/g;\n    while (match = re.exec(text.utf16)) {\n      if (!isValidDomain(match[3]) && !match[3].endsWith(\".test\")) {\n        continue;\n      }\n      const start = text.utf16.indexOf(match[3], match.index) - 1;\n      facets.push({\n        $type: \"app.bsky.richtext.facet\",\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(start),\n          byteEnd: text.utf16IndexToUtf8Index(start + match[3].length + 1)\n        },\n        features: [\n          {\n            $type: \"app.bsky.richtext.facet#mention\",\n            did: match[3]\n          }\n        ]\n      });\n    }\n  }\n  {\n    const re = /(^|\\s|\\()((https?:\\/\\/[\\S]+)|((?<domain>[a-z][a-z0-9]*(\\.[a-z0-9]+)+)[\\S]*))/gim;\n    while (match = re.exec(text.utf16)) {\n      let uri2 = match[2];\n      if (!uri2.startsWith(\"http\")) {\n        const domain = match.groups?.domain;\n        if (!domain || !isValidDomain(domain)) {\n          continue;\n        }\n        uri2 = `https://${uri2}`;\n      }\n      const start = text.utf16.indexOf(match[2], match.index);\n      const index = { start, end: start + match[2].length };\n      if (/[.,;!?]$/.test(uri2)) {\n        uri2 = uri2.slice(0, -1);\n        index.end--;\n      }\n      if (/[)]$/.test(uri2) && !uri2.includes(\"(\")) {\n        uri2 = uri2.slice(0, -1);\n        index.end--;\n      }\n      facets.push({\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(index.start),\n          byteEnd: text.utf16IndexToUtf8Index(index.end)\n        },\n        features: [\n          {\n            $type: \"app.bsky.richtext.facet#link\",\n            uri: uri2\n          }\n        ]\n      });\n    }\n  }\n  return facets.length > 0 ? facets : void 0;\n}\nfunction isValidDomain(str) {\n  return !!tlds_default.find((tld) => {\n    const i = str.lastIndexOf(tld);\n    if (i === -1) {\n      return false;\n    }\n    return str.charAt(i - 1) === \".\" && i === str.length - tld.length;\n  });\n}\n\n// src/rich-text/rich-text.ts\nvar RichTextSegment = class {\n  constructor(text, facet) {\n    this.text = text;\n    this.facet = facet;\n  }\n  get link() {\n    const link = this.facet?.features.find(facet_exports.isLink);\n    if (facet_exports.isLink(link)) {\n      return link;\n    }\n    return void 0;\n  }\n  isLink() {\n    return !!this.link;\n  }\n  get mention() {\n    const mention = this.facet?.features.find(facet_exports.isMention);\n    if (facet_exports.isMention(mention)) {\n      return mention;\n    }\n    return void 0;\n  }\n  isMention() {\n    return !!this.mention;\n  }\n};\nvar RichText = class {\n  constructor(props, opts) {\n    this.unicodeText = new UnicodeString(props.text);\n    this.facets = props.facets;\n    if (!this.facets?.length && props.entities?.length) {\n      this.facets = entitiesToFacets(this.unicodeText, props.entities);\n    }\n    if (this.facets) {\n      this.facets.sort(facetSort);\n    }\n    if (opts?.cleanNewlines) {\n      sanitizeRichText(this, { cleanNewlines: true }).copyInto(this);\n    }\n  }\n  get text() {\n    return this.unicodeText.toString();\n  }\n  get length() {\n    return this.unicodeText.length;\n  }\n  get graphemeLength() {\n    return this.unicodeText.graphemeLength;\n  }\n  clone() {\n    return new RichText({\n      text: this.unicodeText.utf16,\n      facets: cloneDeep(this.facets)\n    });\n  }\n  copyInto(target) {\n    target.unicodeText = this.unicodeText;\n    target.facets = cloneDeep(this.facets);\n  }\n  *segments() {\n    const facets = this.facets || [];\n    if (!facets.length) {\n      yield new RichTextSegment(this.unicodeText.utf16);\n      return;\n    }\n    let textCursor = 0;\n    let facetCursor = 0;\n    do {\n      const currFacet = facets[facetCursor];\n      if (textCursor < currFacet.index.byteStart) {\n        yield new RichTextSegment(\n          this.unicodeText.slice(textCursor, currFacet.index.byteStart)\n        );\n      } else if (textCursor > currFacet.index.byteStart) {\n        facetCursor++;\n        continue;\n      }\n      if (currFacet.index.byteStart < currFacet.index.byteEnd) {\n        const subtext = this.unicodeText.slice(\n          currFacet.index.byteStart,\n          currFacet.index.byteEnd\n        );\n        if (!subtext.trim()) {\n          yield new RichTextSegment(subtext);\n        } else {\n          yield new RichTextSegment(subtext, currFacet);\n        }\n      }\n      textCursor = currFacet.index.byteEnd;\n      facetCursor++;\n    } while (facetCursor < facets.length);\n    if (textCursor < this.unicodeText.length) {\n      yield new RichTextSegment(\n        this.unicodeText.slice(textCursor, this.unicodeText.length)\n      );\n    }\n  }\n  insert(insertIndex, insertText) {\n    this.unicodeText = new UnicodeString(\n      this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex)\n    );\n    if (!this.facets?.length) {\n      return this;\n    }\n    const numCharsAdded = insertText.length;\n    for (const ent of this.facets) {\n      if (insertIndex <= ent.index.byteStart) {\n        ent.index.byteStart += numCharsAdded;\n        ent.index.byteEnd += numCharsAdded;\n      } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {\n        ent.index.byteEnd += numCharsAdded;\n      }\n    }\n    return this;\n  }\n  delete(removeStartIndex, removeEndIndex) {\n    this.unicodeText = new UnicodeString(\n      this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex)\n    );\n    if (!this.facets?.length) {\n      return this;\n    }\n    const numCharsRemoved = removeEndIndex - removeStartIndex;\n    for (const ent of this.facets) {\n      if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {\n        ent.index.byteStart = 0;\n        ent.index.byteEnd = 0;\n      } else if (removeStartIndex > ent.index.byteEnd) {\n      } else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {\n        ent.index.byteEnd = removeStartIndex;\n      } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {\n        ent.index.byteEnd -= numCharsRemoved;\n      } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {\n        ent.index.byteStart = removeStartIndex;\n        ent.index.byteEnd -= numCharsRemoved;\n      } else if (removeEndIndex < ent.index.byteStart) {\n        ent.index.byteStart -= numCharsRemoved;\n        ent.index.byteEnd -= numCharsRemoved;\n      }\n    }\n    this.facets = this.facets.filter(\n      (ent) => ent.index.byteStart < ent.index.byteEnd\n    );\n    return this;\n  }\n  async detectFacets(agent) {\n    this.facets = detectFacets(this.unicodeText);\n    if (this.facets) {\n      for (const facet of this.facets) {\n        for (const feature of facet.features) {\n          if (facet_exports.isMention(feature)) {\n            const did2 = await agent.resolveHandle({ handle: feature.did }).catch((_) => void 0).then((res) => res?.data.did);\n            feature.did = did2 || \"\";\n          }\n        }\n      }\n      this.facets.sort(facetSort);\n    }\n  }\n  detectFacetsWithoutResolution() {\n    this.facets = detectFacets(this.unicodeText);\n    if (this.facets) {\n      this.facets.sort(facetSort);\n    }\n  }\n};\nvar facetSort = (a, b) => a.index.byteStart - b.index.byteStart;\nfunction entitiesToFacets(text, entities) {\n  const facets = [];\n  for (const ent of entities) {\n    if (ent.type === \"link\") {\n      facets.push({\n        $type: \"app.bsky.richtext.facet\",\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(ent.index.start),\n          byteEnd: text.utf16IndexToUtf8Index(ent.index.end)\n        },\n        features: [{ $type: \"app.bsky.richtext.facet#link\", uri: ent.value }]\n      });\n    } else if (ent.type === \"mention\") {\n      facets.push({\n        $type: \"app.bsky.richtext.facet\",\n        index: {\n          byteStart: text.utf16IndexToUtf8Index(ent.index.start),\n          byteEnd: text.utf16IndexToUtf8Index(ent.index.end)\n        },\n        features: [\n          { $type: \"app.bsky.richtext.facet#mention\", did: ent.value }\n        ]\n      });\n    }\n  }\n  return facets;\n}\nfunction cloneDeep(v) {\n  if (typeof v === \"undefined\") {\n    return v;\n  }\n  return JSON.parse(JSON.stringify(v));\n}\n\n// src/bsky-agent.ts\nvar BskyAgent = class extends AtpAgent {\n  constructor() {\n    super(...arguments);\n    this.getTimeline = (params2, opts) => this.api.app.bsky.feed.getTimeline(params2, opts);\n    this.getAuthorFeed = (params2, opts) => this.api.app.bsky.feed.getAuthorFeed(params2, opts);\n    this.getPostThread = (params2, opts) => this.api.app.bsky.feed.getPostThread(params2, opts);\n    this.getPost = (params2) => this.api.app.bsky.feed.post.get(params2);\n    this.getLikes = (params2, opts) => this.api.app.bsky.feed.getLikes(params2, opts);\n    this.getRepostedBy = (params2, opts) => this.api.app.bsky.feed.getRepostedBy(params2, opts);\n    this.getFollows = (params2, opts) => this.api.app.bsky.graph.getFollows(params2, opts);\n    this.getFollowers = (params2, opts) => this.api.app.bsky.graph.getFollowers(params2, opts);\n    this.getProfile = (params2, opts) => this.api.app.bsky.actor.getProfile(params2, opts);\n    this.getProfiles = (params2, opts) => this.api.app.bsky.actor.getProfiles(params2, opts);\n    this.searchActors = (params2, opts) => this.api.app.bsky.actor.searchActors(params2, opts);\n    this.searchActorsTypeahead = (params2, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params2, opts);\n    this.listNotifications = (params2, opts) => this.api.app.bsky.notification.listNotifications(params2, opts);\n    this.countUnreadNotifications = (params2, opts) => this.api.app.bsky.notification.getUnreadCount(params2, opts);\n  }\n  get app() {\n    return this.api.app;\n  }\n  async post(record) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    record.createdAt = record.createdAt || new Date().toISOString();\n    return this.api.app.bsky.feed.post.create(\n      { repo: this.session.did },\n      record\n    );\n  }\n  async deletePost(postUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const postUrip = new AtUri(postUri);\n    return await this.api.app.bsky.feed.post.delete({\n      repo: postUrip.hostname,\n      rkey: postUrip.rkey\n    });\n  }\n  async like(uri2, cid2) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    return await this.api.app.bsky.feed.like.create(\n      { repo: this.session.did },\n      {\n        subject: { uri: uri2, cid: cid2 },\n        createdAt: new Date().toISOString()\n      }\n    );\n  }\n  async deleteLike(likeUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const likeUrip = new AtUri(likeUri);\n    return await this.api.app.bsky.feed.like.delete({\n      repo: likeUrip.hostname,\n      rkey: likeUrip.rkey\n    });\n  }\n  async repost(uri2, cid2) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    return await this.api.app.bsky.feed.repost.create(\n      { repo: this.session.did },\n      {\n        subject: { uri: uri2, cid: cid2 },\n        createdAt: new Date().toISOString()\n      }\n    );\n  }\n  async deleteRepost(repostUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const repostUrip = new AtUri(repostUri);\n    return await this.api.app.bsky.feed.repost.delete({\n      repo: repostUrip.hostname,\n      rkey: repostUrip.rkey\n    });\n  }\n  async follow(subjectDid) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    return await this.api.app.bsky.graph.follow.create(\n      { repo: this.session.did },\n      {\n        subject: subjectDid,\n        createdAt: new Date().toISOString()\n      }\n    );\n  }\n  async deleteFollow(followUri) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    const followUrip = new AtUri(followUri);\n    return await this.api.app.bsky.graph.follow.delete({\n      repo: followUrip.hostname,\n      rkey: followUrip.rkey\n    });\n  }\n  async upsertProfile(updateFn) {\n    if (!this.session) {\n      throw new Error(\"Not logged in\");\n    }\n    let retriesRemaining = 5;\n    while (retriesRemaining >= 0) {\n      const existing = await this.com.atproto.repo.getRecord({\n        repo: this.session.did,\n        collection: \"app.bsky.actor.profile\",\n        rkey: \"self\"\n      }).catch((_) => void 0);\n      const updated = await updateFn(existing?.data.value);\n      if (updated) {\n        updated.$type = \"app.bsky.actor.profile\";\n      }\n      const validation = profile_exports.validateRecord(updated);\n      if (!validation.success) {\n        throw validation.error;\n      }\n      try {\n        await this.com.atproto.repo.putRecord({\n          repo: this.session.did,\n          collection: \"app.bsky.actor.profile\",\n          rkey: \"self\",\n          record: updated,\n          swapRecord: existing?.data.cid || null\n        });\n      } catch (e) {\n        if (retriesRemaining > 0 && e instanceof putRecord_exports.InvalidSwapError) {\n          retriesRemaining--;\n          continue;\n        } else {\n          throw e;\n        }\n      }\n      break;\n    }\n  }\n  async mute(actor) {\n    return this.api.app.bsky.graph.muteActor({ actor });\n  }\n  async unmute(actor) {\n    return this.api.app.bsky.graph.unmuteActor({ actor });\n  }\n  async updateSeenNotifications(seenAt) {\n    seenAt = seenAt || new Date().toISOString();\n    return this.api.app.bsky.notification.updateSeen({\n      seenAt\n    });\n  }\n};\n//# sourceMappingURL=index.js.map\n","/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;","/**\n * web-streams-polyfill v3.2.1\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.WebStreamsPolyfill = {}));\n}(this, (function (exports) { 'use strict';\n\n    /// <reference lib=\"es2015.symbol\" />\n    const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n        Symbol :\n        description => `Symbol(${description})`;\n\n    /// <reference lib=\"dom\" />\n    function noop() {\n        return undefined;\n    }\n    function getGlobals() {\n        if (typeof self !== 'undefined') {\n            return self;\n        }\n        else if (typeof window !== 'undefined') {\n            return window;\n        }\n        else if (typeof global !== 'undefined') {\n            return global;\n        }\n        return undefined;\n    }\n    const globals = getGlobals();\n\n    function typeIsObject(x) {\n        return (typeof x === 'object' && x !== null) || typeof x === 'function';\n    }\n    const rethrowAssertionErrorRejection = noop;\n\n    const originalPromise = Promise;\n    const originalPromiseThen = Promise.prototype.then;\n    const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\n    function newPromise(executor) {\n        return new originalPromise(executor);\n    }\n    function promiseResolvedWith(value) {\n        return originalPromiseResolve(value);\n    }\n    function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n    }\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n        // approximation.\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n    }\n    function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n    }\n    function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n    }\n    function uponRejection(promise, onRejected) {\n        uponPromise(promise, undefined, onRejected);\n    }\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n    }\n    function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n    }\n    const queueMicrotask = (() => {\n        const globalQueueMicrotask = globals && globals.queueMicrotask;\n        if (typeof globalQueueMicrotask === 'function') {\n            return globalQueueMicrotask;\n        }\n        const resolvedPromise = promiseResolvedWith(undefined);\n        return (fn) => PerformPromiseThen(resolvedPromise, fn);\n    })();\n    function reflectCall(F, V, args) {\n        if (typeof F !== 'function') {\n            throw new TypeError('Argument is not a function');\n        }\n        return Function.prototype.apply.call(F, V, args);\n    }\n    function promiseCall(F, V, args) {\n        try {\n            return promiseResolvedWith(reflectCall(F, V, args));\n        }\n        catch (value) {\n            return promiseRejectedWith(value);\n        }\n    }\n\n    // Original from Chromium\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\n    /**\n     * Simple queue structure.\n     *\n     * Avoids scalability issues with using a packed array directly by using\n     * multiple arrays in a linked list and keeping the array size bounded.\n     */\n    class SimpleQueue {\n        constructor() {\n            this._cursor = 0;\n            this._size = 0;\n            // _front and _back are always defined.\n            this._front = {\n                _elements: [],\n                _next: undefined\n            };\n            this._back = this._front;\n            // The cursor is used to avoid calling Array.shift().\n            // It contains the index of the front element of the array inside the\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n            this._cursor = 0;\n            // When there is only one node, size === elements.length - cursor.\n            this._size = 0;\n        }\n        get length() {\n            return this._size;\n        }\n        // For exception safety, this method is structured in order:\n        // 1. Read state\n        // 2. Calculate required state mutations\n        // 3. Perform state mutations\n        push(element) {\n            const oldBack = this._back;\n            let newBack = oldBack;\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                    _elements: [],\n                    _next: undefined\n                };\n            }\n            // push() is the mutation most likely to throw an exception, so it\n            // goes first.\n            oldBack._elements.push(element);\n            if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n            }\n            ++this._size;\n        }\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\n        // exception safety.\n        shift() { // must not be called on an empty queue\n            const oldFront = this._front;\n            let newFront = oldFront;\n            const oldCursor = this._cursor;\n            let newCursor = oldCursor + 1;\n            const elements = oldFront._elements;\n            const element = elements[oldCursor];\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n            }\n            // No mutations before this point.\n            --this._size;\n            this._cursor = newCursor;\n            if (oldFront !== newFront) {\n                this._front = newFront;\n            }\n            // Permit shifted element to be garbage collected.\n            elements[oldCursor] = undefined;\n            return element;\n        }\n        // The tricky thing about forEach() is that it can be called\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\n        // see that push() within the callback has no negative effects since the end\n        // of the queue is checked for on every iteration. If shift() is called\n        // repeatedly within the callback then the next iteration may return an\n        // element that has been removed. In this case the callback will be called\n        // with undefined values until we either \"catch up\" with elements that still\n        // exist or reach the back of the queue.\n        forEach(callback) {\n            let i = this._cursor;\n            let node = this._front;\n            let elements = node._elements;\n            while (i !== elements.length || node._next !== undefined) {\n                if (i === elements.length) {\n                    node = node._next;\n                    elements = node._elements;\n                    i = 0;\n                    if (elements.length === 0) {\n                        break;\n                    }\n                }\n                callback(elements[i]);\n                ++i;\n            }\n        }\n        // Return the element that would be returned if shift() was called now,\n        // without modifying the queue.\n        peek() { // must not be called on an empty queue\n            const front = this._front;\n            const cursor = this._cursor;\n            return front._elements[cursor];\n        }\n    }\n\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === 'readable') {\n            defaultReaderClosedPromiseInitialize(reader);\n        }\n        else if (stream._state === 'closed') {\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\n        }\n        else {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n    }\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n    // check.\n    function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n    }\n    function ReadableStreamReaderGenericRelease(reader) {\n        if (reader._ownerReadableStream._state === 'readable') {\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        else {\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        reader._ownerReadableStream._reader = undefined;\n        reader._ownerReadableStream = undefined;\n    }\n    // Helper functions for the readers.\n    function readerLockException(name) {\n        return new TypeError('Cannot ' + name + ' a stream using a released reader');\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject) => {\n            reader._closedPromise_resolve = resolve;\n            reader._closedPromise_reject = reject;\n        });\n    }\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n    }\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n    }\n    function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n    }\n    function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === undefined) {\n            return;\n        }\n        reader._closedPromise_resolve(undefined);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n\n    const AbortSteps = SymbolPolyfill('[[AbortSteps]]');\n    const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n    const CancelSteps = SymbolPolyfill('[[CancelSteps]]');\n    const PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n    const NumberIsFinite = Number.isFinite || function (x) {\n        return typeof x === 'number' && isFinite(x);\n    };\n\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n    const MathTrunc = Math.trunc || function (v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n    };\n\n    // https://heycam.github.io/webidl/#idl-dictionaries\n    function isDictionary(x) {\n        return typeof x === 'object' || typeof x === 'function';\n    }\n    function assertDictionary(obj, context) {\n        if (obj !== undefined && !isDictionary(obj)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-callback-functions\n    function assertFunction(x, context) {\n        if (typeof x !== 'function') {\n            throw new TypeError(`${context} is not a function.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-object\n    function isObject(x) {\n        return (typeof x === 'object' && x !== null) || typeof x === 'function';\n    }\n    function assertObject(x, context) {\n        if (!isObject(x)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    function assertRequiredArgument(x, position, context) {\n        if (x === undefined) {\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n    }\n    function assertRequiredField(x, field, context) {\n        if (x === undefined) {\n            throw new TypeError(`${field} is required in '${context}'.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\n    function convertUnrestrictedDouble(value) {\n        return Number(value);\n    }\n    function censorNegativeZero(x) {\n        return x === 0 ? 0 : x;\n    }\n    function integerPart(x) {\n        return censorNegativeZero(MathTrunc(x));\n    }\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x = Number(value);\n        x = censorNegativeZero(x);\n        if (!NumberIsFinite(x)) {\n            throw new TypeError(`${context} is not a finite number`);\n        }\n        x = integerPart(x);\n        if (x < lowerBound || x > upperBound) {\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x) || x === 0) {\n            return 0;\n        }\n        // TODO Use BigInt if supported?\n        // let xBigInt = BigInt(integerPart(x));\n        // xBigInt = BigInt.asUintN(64, xBigInt);\n        // return Number(xBigInt);\n        return x;\n    }\n\n    function assertReadableStream(x, context) {\n        if (!IsReadableStream(x)) {\n            throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n    }\n\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n    }\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n            readRequest._closeSteps();\n        }\n        else {\n            readRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n    }\n    function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A default reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */\n    class ReadableStreamDefaultReader {\n        constructor(stream) {\n            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n            assertReadableStream(stream, 'First parameter');\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed,\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n         */\n        get closed() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */\n        cancel(reason = undefined) {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('cancel'));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */\n        read() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('read from'));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n                _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n                _errorSteps: e => rejectPromise(e)\n            };\n            ReadableStreamDefaultReaderRead(this, readRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */\n        releaseLock() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException('releaseLock');\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readRequests.length > 0) {\n                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: { enumerable: true },\n        read: { enumerable: true },\n        releaseLock: { enumerable: true },\n        closed: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamDefaultReader',\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamDefaultReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultReader;\n    }\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === 'closed') {\n            readRequest._closeSteps();\n        }\n        else if (stream._state === 'errored') {\n            readRequest._errorSteps(stream._storedError);\n        }\n        else {\n            stream._readableStreamController[PullSteps](readRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n    }\n\n    /// <reference lib=\"es2018.asynciterable\" />\n    /* eslint-disable @typescript-eslint/no-empty-function */\n    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);\n\n    /// <reference lib=\"es2018.asynciterable\" />\n    class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel) {\n            this._ongoingPromise = undefined;\n            this._isFinished = false;\n            this._reader = reader;\n            this._preventCancel = preventCancel;\n        }\n        next() {\n            const nextSteps = () => this._nextSteps();\n            this._ongoingPromise = this._ongoingPromise ?\n                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n                nextSteps();\n            return this._ongoingPromise;\n        }\n        return(value) {\n            const returnSteps = () => this._returnSteps(value);\n            return this._ongoingPromise ?\n                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n                returnSteps();\n        }\n        _nextSteps() {\n            if (this._isFinished) {\n                return Promise.resolve({ value: undefined, done: true });\n            }\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('iterate'));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: chunk => {\n                    this._ongoingPromise = undefined;\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                    // FIXME Is this a bug in the specification, or in the test?\n                    queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n                },\n                _closeSteps: () => {\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    resolvePromise({ value: undefined, done: true });\n                },\n                _errorSteps: reason => {\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    rejectPromise(reason);\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promise;\n        }\n        _returnSteps(value) {\n            if (this._isFinished) {\n                return Promise.resolve({ value, done: true });\n            }\n            this._isFinished = true;\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('finish iterating'));\n            }\n            if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, () => ({ value, done: true }));\n            }\n            ReadableStreamReaderGenericRelease(reader);\n            return promiseResolvedWith({ value, done: true });\n        }\n    }\n    const ReadableStreamAsyncIteratorPrototype = {\n        next() {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n            }\n            return this._asyncIteratorImpl.next();\n        },\n        return(value) {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n            }\n            return this._asyncIteratorImpl.return(value);\n        }\n    };\n    if (AsyncIteratorPrototype !== undefined) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n    }\n    function IsReadableStreamAsyncIterator(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n            return false;\n        }\n        try {\n            // noinspection SuspiciousTypeOfGuard\n            return x._asyncIteratorImpl instanceof\n                ReadableStreamAsyncIteratorImpl;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n    }\n\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n    const NumberIsNaN = Number.isNaN || function (x) {\n        // eslint-disable-next-line no-self-compare\n        return x !== x;\n    };\n\n    function CreateArrayFromList(elements) {\n        // We use arrays to represent lists, so this is basically a no-op.\n        // Do a slice though just in case we happen to depend on the unique-ness.\n        return elements.slice();\n    }\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n    }\n    // Not implemented correctly\n    function TransferArrayBuffer(O) {\n        return O;\n    }\n    // Not implemented correctly\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function IsDetachedBuffer(O) {\n        return false;\n    }\n    function ArrayBufferSlice(buffer, begin, end) {\n        // ArrayBuffer.prototype.slice is not available on IE10\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n        if (buffer.slice) {\n            return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n    }\n\n    function IsNonNegativeNumber(v) {\n        if (typeof v !== 'number') {\n            return false;\n        }\n        if (NumberIsNaN(v)) {\n            return false;\n        }\n        if (v < 0) {\n            return false;\n        }\n        return true;\n    }\n    function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n    }\n\n    function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n            container._queueTotalSize = 0;\n        }\n        return pair.value;\n    }\n    function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n        }\n        container._queue.push({ value, size });\n        container._queueTotalSize += size;\n    }\n    function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n    }\n    function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n    }\n\n    /**\n     * A pull-into request in a {@link ReadableByteStreamController}.\n     *\n     * @public\n     */\n    class ReadableStreamBYOBRequest {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n         */\n        get view() {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException('view');\n            }\n            return this._view;\n        }\n        respond(bytesWritten) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException('respond');\n            }\n            assertRequiredArgument(bytesWritten, 1, 'respond');\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError('This BYOB request has been invalidated');\n            }\n            if (IsDetachedBuffer(this._view.buffer)) ;\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException('respondWithNewView');\n            }\n            assertRequiredArgument(view, 1, 'respondWithNewView');\n            if (!ArrayBuffer.isView(view)) {\n                throw new TypeError('You can only respond with array buffer views');\n            }\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError('This BYOB request has been invalidated');\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: { enumerable: true },\n        respondWithNewView: { enumerable: true },\n        view: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamBYOBRequest',\n            configurable: true\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n     *\n     * @public\n     */\n    class ReadableByteStreamController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the current BYOB pull request, or `null` if there isn't one.\n         */\n        get byobRequest() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('byobRequest');\n            }\n            return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n         */\n        get desiredSize() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('desiredSize');\n            }\n            return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */\n        close() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('close');\n            }\n            if (this._closeRequested) {\n                throw new TypeError('The stream has already been closed; do not close it again!');\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== 'readable') {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n            }\n            ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('enqueue');\n            }\n            assertRequiredArgument(chunk, 1, 'enqueue');\n            if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError('chunk must be an array buffer view');\n            }\n            if (chunk.byteLength === 0) {\n                throw new TypeError('chunk must have non-zero byteLength');\n            }\n            if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n            }\n            if (this._closeRequested) {\n                throw new TypeError('stream is closed or draining');\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== 'readable') {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n            }\n            ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */\n        error(e = undefined) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('error');\n            }\n            ReadableByteStreamControllerError(this, e);\n        }\n        /** @internal */\n        [CancelSteps](reason) {\n            ReadableByteStreamControllerClearPendingPullIntos(this);\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableByteStreamControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */\n        [PullSteps](readRequest) {\n            const stream = this._controlledReadableByteStream;\n            if (this._queueTotalSize > 0) {\n                const entry = this._queue.shift();\n                this._queueTotalSize -= entry.byteLength;\n                ReadableByteStreamControllerHandleQueueDrain(this);\n                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                readRequest._chunkSteps(view);\n                return;\n            }\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\n            if (autoAllocateChunkSize !== undefined) {\n                let buffer;\n                try {\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\n                }\n                catch (bufferE) {\n                    readRequest._errorSteps(bufferE);\n                    return;\n                }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: autoAllocateChunkSize,\n                    byteOffset: 0,\n                    byteLength: autoAllocateChunkSize,\n                    bytesFilled: 0,\n                    elementSize: 1,\n                    viewConstructor: Uint8Array,\n                    readerType: 'default'\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n            }\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n    }\n    Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: { enumerable: true },\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        byobRequest: { enumerable: true },\n        desiredSize: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableByteStreamController',\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableByteStreamController.\n    function IsReadableByteStreamController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n            return false;\n        }\n        return x instanceof ReadableByteStreamController;\n    }\n    function IsReadableStreamBYOBRequest(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBRequest;\n    }\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        // TODO: Test controller argument\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, () => {\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n        }, e => {\n            ReadableByteStreamControllerError(controller, e);\n        });\n    }\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n    }\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === 'closed') {\n            done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === 'default') {\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\n        }\n        else {\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n    }\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n    }\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({ buffer, byteOffset, byteLength });\n        controller._queueTotalSize += byteLength;\n    }\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const elementSize = pullIntoDescriptor.elementSize;\n        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        if (maxAlignedBytes > currentAlignedBytes) {\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n            ready = true;\n        }\n        const queue = controller._queue;\n        while (totalBytesToCopyRemaining > 0) {\n            const headOfQueue = queue.peek();\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n            if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n            }\n            else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n            }\n            controller._queueTotalSize -= bytesToCopy;\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n            totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n    }\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n    }\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(controller._controlledReadableByteStream);\n        }\n        else {\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n            return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n    }\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while (controller._pendingPullIntos.length > 0) {\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        let elementSize = 1;\n        if (view.constructor !== DataView) {\n            elementSize = view.constructor.BYTES_PER_ELEMENT;\n        }\n        const ctor = view.constructor;\n        // try {\n        const buffer = TransferArrayBuffer(view.buffer);\n        // } catch (e) {\n        //   readIntoRequest._errorSteps(e);\n        //   return;\n        // }\n        const pullIntoDescriptor = {\n            buffer,\n            bufferByteLength: buffer.byteLength,\n            byteOffset: view.byteOffset,\n            byteLength: view.byteLength,\n            bytesFilled: 0,\n            elementSize,\n            viewConstructor: ctor,\n            readerType: 'byob'\n        };\n        if (controller._pendingPullIntos.length > 0) {\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n            // - No change happens on desiredSize\n            // - The source has already been notified of that there's at least 1 pending read(view)\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            return;\n        }\n        if (stream._state === 'closed') {\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n            readIntoRequest._closeSteps(emptyView);\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n            }\n            if (controller._closeRequested) {\n                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n                ReadableByteStreamControllerError(controller, e);\n                readIntoRequest._errorSteps(e);\n                return;\n            }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n            return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'closed') {\n            ReadableByteStreamControllerRespondInClosedState(controller);\n        }\n        else {\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n    }\n    function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== 'readable') {\n            return false;\n        }\n        if (controller._closeRequested) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n    function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== 'readable') {\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            controller._closeRequested = true;\n            return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (firstPendingPullInto.bytesFilled > 0) {\n                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n                ReadableByteStreamControllerError(controller, e);\n                throw e;\n            }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== 'readable') {\n            return;\n        }\n        const buffer = chunk.buffer;\n        const byteOffset = chunk.byteOffset;\n        const byteLength = chunk.byteLength;\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n        }\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        if (ReadableStreamHasDefaultReader(stream)) {\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            }\n            else {\n                if (controller._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n            }\n        }\n        else if (ReadableStreamHasBYOBReader(stream)) {\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        }\n        else {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerError(controller, e) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== 'readable') {\n            return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n            controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n    }\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'errored') {\n            return null;\n        }\n        if (state === 'closed') {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'closed') {\n            if (bytesWritten !== 0) {\n                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n            }\n        }\n        else {\n            if (bytesWritten === 0) {\n                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n            }\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError('bytesWritten out of range');\n            }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n    }\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'closed') {\n            if (view.byteLength !== 0) {\n                throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n            }\n        }\n        else {\n            if (view.byteLength === 0) {\n                throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n            }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n            throw new RangeError('The region specified by view does not match byobRequest');\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n            throw new RangeError('The buffer of view has different capacity than byobRequest');\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n            throw new RangeError('The region specified by view is larger than byobRequest');\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n    }\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), () => {\n            controller._started = true;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }, r => {\n            ReadableByteStreamControllerError(controller, r);\n        });\n    }\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm = () => undefined;\n        let pullAlgorithm = () => promiseResolvedWith(undefined);\n        let cancelAlgorithm = () => promiseResolvedWith(undefined);\n        if (underlyingByteSource.start !== undefined) {\n            startAlgorithm = () => underlyingByteSource.start(controller);\n        }\n        if (underlyingByteSource.pull !== undefined) {\n            pullAlgorithm = () => underlyingByteSource.pull(controller);\n        }\n        if (underlyingByteSource.cancel !== undefined) {\n            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n            throw new TypeError('autoAllocateChunkSize must be greater than 0');\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n    }\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n    }\n    // Helper functions for the ReadableStreamBYOBRequest.\n    function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n    }\n    // Helper functions for the ReadableByteStreamController.\n    function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n    }\n\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    }\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n            readIntoRequest._closeSteps(chunk);\n        }\n        else {\n            readIntoRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n    }\n    function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A BYOB reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */\n    class ReadableStreamBYOBReader {\n        constructor(stream) {\n            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n            assertReadableStream(stream, 'First parameter');\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n            }\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                    'source');\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readIntoRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the reader's lock is released before the stream finishes closing.\n         */\n        get closed() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */\n        cancel(reason = undefined) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('cancel'));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */\n        read(view) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException('read'));\n            }\n            if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n            }\n            if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n            }\n            if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('read from'));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readIntoRequest = {\n                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n                _errorSteps: e => rejectPromise(e)\n            };\n            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */\n        releaseLock() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException('releaseLock');\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readIntoRequests.length > 0) {\n                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: { enumerable: true },\n        read: { enumerable: true },\n        releaseLock: { enumerable: true },\n        closed: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamBYOBReader',\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamBYOBReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBReader;\n    }\n    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === 'errored') {\n            readIntoRequest._errorSteps(stream._storedError);\n        }\n        else {\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamBYOBReader.\n    function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n    }\n\n    function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === undefined) {\n            return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n            throw new RangeError('Invalid highWaterMark');\n        }\n        return highWaterMark;\n    }\n    function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n            return () => 1;\n        }\n        return size;\n    }\n\n    function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n    }\n    function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return chunk => convertUnrestrictedDouble(fn(chunk));\n    }\n\n    function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n            abort: abort === undefined ?\n                undefined :\n                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n            close: close === undefined ?\n                undefined :\n                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n            start: start === undefined ?\n                undefined :\n                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n            write: write === undefined ?\n                undefined :\n                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n            type\n        };\n    }\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason) => promiseCall(fn, original, [reason]);\n    }\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return () => promiseCall(fn, original, []);\n    }\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n    }\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n    }\n\n    function assertWritableStream(x, context) {\n        if (!IsWritableStream(x)) {\n            throw new TypeError(`${context} is not a WritableStream.`);\n        }\n    }\n\n    function isAbortSignal(value) {\n        if (typeof value !== 'object' || value === null) {\n            return false;\n        }\n        try {\n            return typeof value.aborted === 'boolean';\n        }\n        catch (_a) {\n            // AbortSignal.prototype.aborted throws if its brand check fails\n            return false;\n        }\n    }\n    const supportsAbortController = typeof AbortController === 'function';\n    /**\n     * Construct a new AbortController, if supported by the platform.\n     *\n     * @internal\n     */\n    function createAbortController() {\n        if (supportsAbortController) {\n            return new AbortController();\n        }\n        return undefined;\n    }\n\n    /**\n     * A writable stream represents a destination for data, into which you can write.\n     *\n     * @public\n     */\n    class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n            if (rawUnderlyingSink === undefined) {\n                rawUnderlyingSink = null;\n            }\n            else {\n                assertObject(rawUnderlyingSink, 'First parameter');\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n            InitializeWritableStream(this);\n            const type = underlyingSink.type;\n            if (type !== undefined) {\n                throw new RangeError('Invalid type is specified');\n            }\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        /**\n         * Returns whether or not the writable stream is locked to a writer.\n         */\n        get locked() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2('locked');\n            }\n            return IsWritableStreamLocked(this);\n        }\n        /**\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n         * mechanism of the underlying sink.\n         *\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n         * the stream) if the stream is currently locked.\n         */\n        abort(reason = undefined) {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2('abort'));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n            }\n            return WritableStreamAbort(this, reason);\n        }\n        /**\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n         *\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n         */\n        close() {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2('close'));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n            }\n            return WritableStreamClose(this);\n        }\n        /**\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n         * is locked, no other writer can be acquired until this one is released.\n         *\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n         */\n        getWriter() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2('getWriter');\n            }\n            return AcquireWritableStreamDefaultWriter(this);\n        }\n    }\n    Object.defineProperties(WritableStream.prototype, {\n        abort: { enumerable: true },\n        close: { enumerable: true },\n        getWriter: { enumerable: true },\n        locked: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: 'WritableStream',\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStream.\n    function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    function InitializeWritableStream(stream) {\n        stream._state = 'writable';\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n        // 'erroring' or 'errored'. May be set to an undefined value.\n        stream._storedError = undefined;\n        stream._writer = undefined;\n        // Initialize to undefined first because the constructor of the controller checks this\n        // variable to validate the caller.\n        stream._writableStreamController = undefined;\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n        // producer without waiting for the queued writes to finish.\n        stream._writeRequests = new SimpleQueue();\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n        stream._inFlightWriteRequest = undefined;\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n        // has been detached.\n        stream._closeRequest = undefined;\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n        stream._inFlightCloseRequest = undefined;\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n        stream._pendingAbortRequest = undefined;\n        // The backpressure signal set by the controller.\n        stream._backpressure = false;\n    }\n    function IsWritableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n            return false;\n        }\n        return x instanceof WritableStream;\n    }\n    function IsWritableStreamLocked(stream) {\n        if (stream._writer === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === 'closed' || stream._state === 'errored') {\n            return promiseResolvedWith(undefined);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\n        // Widen the type again by casting to WritableStreamState.\n        const state = stream._state;\n        if (state === 'closed' || state === 'errored') {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._pendingAbortRequest !== undefined) {\n            return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === 'erroring') {\n            wasAlreadyErroring = true;\n            // reason will not be used, so don't keep a reference to it.\n            reason = undefined;\n        }\n        const promise = newPromise((resolve, reject) => {\n            stream._pendingAbortRequest = {\n                _promise: undefined,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n            };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n            WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n    }\n    function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === 'closed' || state === 'errored') {\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject) => {\n            const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== undefined && stream._backpressure && state === 'writable') {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n    }\n    // WritableStream API exposed for controllers.\n    function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject) => {\n            const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n    }\n    function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === 'writable') {\n            WritableStreamStartErroring(stream, error);\n            return;\n        }\n        WritableStreamFinishErroring(stream);\n    }\n    function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = 'erroring';\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n            WritableStreamFinishErroring(stream);\n        }\n    }\n    function WritableStreamFinishErroring(stream) {\n        stream._state = 'errored';\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach(writeRequest => {\n            writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === undefined) {\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = undefined;\n        if (abortRequest._wasAlreadyErroring) {\n            abortRequest._reject(storedError);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, () => {\n            abortRequest._resolve();\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        }, (reason) => {\n            abortRequest._reject(reason);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        });\n    }\n    function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(undefined);\n        stream._inFlightWriteRequest = undefined;\n    }\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = undefined;\n        WritableStreamDealWithRejection(stream, error);\n    }\n    function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(undefined);\n        stream._inFlightCloseRequest = undefined;\n        const state = stream._state;\n        if (state === 'erroring') {\n            // The error was too late to do anything, so it is ignored.\n            stream._storedError = undefined;\n            if (stream._pendingAbortRequest !== undefined) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = undefined;\n            }\n        }\n        stream._state = 'closed';\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseResolve(writer);\n        }\n    }\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = undefined;\n        // Never execute sink abort() after sink close().\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._reject(error);\n            stream._pendingAbortRequest = undefined;\n        }\n        WritableStreamDealWithRejection(stream, error);\n    }\n    // TODO(ricea): Fix alphabetical order.\n    function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = undefined;\n    }\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n    }\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== undefined) {\n            stream._closeRequest._reject(stream._storedError);\n            stream._closeRequest = undefined;\n        }\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n    }\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== undefined && backpressure !== stream._backpressure) {\n            if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n            }\n            else {\n                defaultWriterReadyPromiseResolve(writer);\n            }\n        }\n        stream._backpressure = backpressure;\n    }\n    /**\n     * A default writer vended by a {@link WritableStream}.\n     *\n     * @public\n     */\n    class WritableStreamDefaultWriter {\n        constructor(stream) {\n            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n            assertWritableStream(stream, 'First parameter');\n            if (IsWritableStreamLocked(stream)) {\n                throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n            }\n            this._ownerWritableStream = stream;\n            stream._writer = this;\n            const state = stream._state;\n            if (state === 'writable') {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                    defaultWriterReadyPromiseInitialize(this);\n                }\n                else {\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n            }\n            else if (state === 'erroring') {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n            }\n            else if (state === 'closed') {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n            }\n            else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n            }\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the writer’s lock is released before the stream finishes closing.\n         */\n        get closed() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n         * A producer can use this information to determine the right amount of data to write.\n         *\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n         * the writer’s lock is released.\n         */\n        get desiredSize() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException('desiredSize');\n            }\n            if (this._ownerWritableStream === undefined) {\n                throw defaultWriterLockException('desiredSize');\n            }\n            return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        /**\n         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n         *\n         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n         * rejected.\n         */\n        get ready() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n            }\n            return this._readyPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n         */\n        abort(reason = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException('abort'));\n            }\n            return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n         */\n        close() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException('close'));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n            }\n            return WritableStreamDefaultWriterClose(this);\n        }\n        /**\n         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n         * now on; otherwise, the writer will appear closed.\n         *\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n         * other producers from writing in an interleaved manner.\n         */\n        releaseLock() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException('releaseLock');\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return;\n            }\n            WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException('write to'));\n            }\n            return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: { enumerable: true },\n        close: { enumerable: true },\n        releaseLock: { enumerable: true },\n        write: { enumerable: true },\n        closed: { enumerable: true },\n        desiredSize: { enumerable: true },\n        ready: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n            value: 'WritableStreamDefaultWriter',\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStreamDefaultWriter.\n    function IsWritableStreamDefaultWriter(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultWriter;\n    }\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n    function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n    }\n    function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n    }\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n            return promiseResolvedWith(undefined);\n        }\n        if (state === 'errored') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n    }\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === 'pending') {\n            defaultWriterClosedPromiseReject(writer, error);\n        }\n        else {\n            defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === 'pending') {\n            defaultWriterReadyPromiseReject(writer, error);\n        }\n        else {\n            defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === 'errored' || state === 'erroring') {\n            return null;\n        }\n        if (state === 'closed') {\n            return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n    }\n    function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n        // rejected until afterwards. This means that simply testing state will not work.\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = undefined;\n        writer._ownerWritableStream = undefined;\n    }\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        const state = stream._state;\n        if (state === 'errored') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n        }\n        if (state === 'erroring') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n    }\n    const closeSentinel = {};\n    /**\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n     *\n     * @public\n     */\n    class WritableStreamDefaultController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n         *\n         * @deprecated\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n         */\n        get abortReason() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2('abortReason');\n            }\n            return this._abortReason;\n        }\n        /**\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n         */\n        get signal() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2('signal');\n            }\n            if (this._abortController === undefined) {\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n            }\n            return this._abortController.signal;\n        }\n        /**\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n         *\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n         * normal lifecycle of interactions with the underlying sink.\n         */\n        error(e = undefined) {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2('error');\n            }\n            const state = this._controlledWritableStream._state;\n            if (state !== 'writable') {\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                // just treat it as a no-op.\n                return;\n            }\n            WritableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */\n        [AbortSteps](reason) {\n            const result = this._abortAlgorithm(reason);\n            WritableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */\n        [ErrorSteps]() {\n            ResetQueue(this);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: { enumerable: true },\n        signal: { enumerable: true },\n        error: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'WritableStreamDefaultController',\n            configurable: true\n        });\n    }\n    // Abstract operations implementing interface required by the WritableStream.\n    function IsWritableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultController;\n    }\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._abortReason = undefined;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, () => {\n            controller._started = true;\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, r => {\n            controller._started = true;\n            WritableStreamDealWithRejection(stream, r);\n        });\n    }\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm = () => undefined;\n        let writeAlgorithm = () => promiseResolvedWith(undefined);\n        let closeAlgorithm = () => promiseResolvedWith(undefined);\n        let abortAlgorithm = () => promiseResolvedWith(undefined);\n        if (underlyingSink.start !== undefined) {\n            startAlgorithm = () => underlyingSink.start(controller);\n        }\n        if (underlyingSink.write !== undefined) {\n            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n        }\n        if (underlyingSink.close !== undefined) {\n            closeAlgorithm = () => underlyingSink.close();\n        }\n        if (underlyingSink.abort !== undefined) {\n            abortAlgorithm = reason => underlyingSink.abort(reason);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = undefined;\n        controller._closeAlgorithm = undefined;\n        controller._abortAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n            return controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n            return 1;\n        }\n    }\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n            return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    // Abstract operations for the WritableStreamDefaultController.\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n            return;\n        }\n        if (stream._inFlightWriteRequest !== undefined) {\n            return;\n        }\n        const state = stream._state;\n        if (state === 'erroring') {\n            WritableStreamFinishErroring(stream);\n            return;\n        }\n        if (controller._queue.length === 0) {\n            return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n            WritableStreamDefaultControllerProcessClose(controller);\n        }\n        else {\n            WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n    }\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === 'writable') {\n            WritableStreamDefaultControllerError(controller, error);\n        }\n    }\n    function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, () => {\n            WritableStreamFinishInFlightClose(stream);\n        }, reason => {\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, () => {\n            WritableStreamFinishInFlightWrite(stream);\n            const state = stream._state;\n            DequeueValue(controller);\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, reason => {\n            if (stream._state === 'writable') {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n            }\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n    }\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n    function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n    }\n    // Helper functions for the WritableStream.\n    function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n    }\n    // Helper functions for the WritableStreamDefaultController.\n    function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n    }\n    // Helper functions for the WritableStreamDefaultWriter.\n    function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n    }\n    function defaultWriterLockException(name) {\n        return new TypeError('Cannot ' + name + ' a stream using a released writer');\n    }\n    function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject) => {\n            writer._closedPromise_resolve = resolve;\n            writer._closedPromise_reject = reject;\n            writer._closedPromiseState = 'pending';\n        });\n    }\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n    }\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n    }\n    function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = 'rejected';\n    }\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === undefined) {\n            return;\n        }\n        writer._closedPromise_resolve(undefined);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = 'resolved';\n    }\n    function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject) => {\n            writer._readyPromise_resolve = resolve;\n            writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = 'pending';\n    }\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n    }\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = 'rejected';\n    }\n    function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n    }\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === undefined) {\n            return;\n        }\n        writer._readyPromise_resolve(undefined);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = 'fulfilled';\n    }\n\n    /// <reference lib=\"dom\" />\n    const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n    /// <reference types=\"node\" />\n    function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n            return false;\n        }\n        try {\n            new ctor();\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    function createDOMExceptionPolyfill() {\n        // eslint-disable-next-line no-shadow\n        const ctor = function DOMException(message, name) {\n            this.message = message || '';\n            this.name = name || 'Error';\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n            }\n        };\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n        return ctor;\n    }\n    // eslint-disable-next-line no-redeclare\n    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n        let currentWrite = promiseResolvedWith(undefined);\n        return newPromise((resolve, reject) => {\n            let abortAlgorithm;\n            if (signal !== undefined) {\n                abortAlgorithm = () => {\n                    const error = new DOMException$1('Aborted', 'AbortError');\n                    const actions = [];\n                    if (!preventAbort) {\n                        actions.push(() => {\n                            if (dest._state === 'writable') {\n                                return WritableStreamAbort(dest, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    if (!preventCancel) {\n                        actions.push(() => {\n                            if (source._state === 'readable') {\n                                return ReadableStreamCancel(source, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n                };\n                if (signal.aborted) {\n                    abortAlgorithm();\n                    return;\n                }\n                signal.addEventListener('abort', abortAlgorithm);\n            }\n            // Using reader and writer, read all chunks from this and write them to dest\n            // - Backpressure must be enforced\n            // - Shutdown must stop all activity\n            function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop) => {\n                    function next(done) {\n                        if (done) {\n                            resolveLoop();\n                        }\n                        else {\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\n                        }\n                    }\n                    next(false);\n                });\n            }\n            function pipeStep() {\n                if (shuttingDown) {\n                    return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, () => {\n                    return newPromise((resolveRead, rejectRead) => {\n                        ReadableStreamDefaultReaderRead(reader, {\n                            _chunkSteps: chunk => {\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                resolveRead(false);\n                            },\n                            _closeSteps: () => resolveRead(true),\n                            _errorSteps: rejectRead\n                        });\n                    });\n                });\n            }\n            // Errors must be propagated forward\n            isOrBecomesErrored(source, reader._closedPromise, storedError => {\n                if (!preventAbort) {\n                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n                }\n                else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Errors must be propagated backward\n            isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n                if (!preventCancel) {\n                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n                }\n                else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Closing must be propagated forward\n            isOrBecomesClosed(source, reader._closedPromise, () => {\n                if (!preventClose) {\n                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                }\n                else {\n                    shutdown();\n                }\n            });\n            // Closing must be propagated backward\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n                if (!preventCancel) {\n                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n                }\n                else {\n                    shutdown(true, destClosed);\n                }\n            }\n            setPromiseIsHandledToTrue(pipeLoop());\n            function waitForWritesToFinish() {\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                // for that too.\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n            }\n            function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === 'errored') {\n                    action(stream._storedError);\n                }\n                else {\n                    uponRejection(promise, action);\n                }\n            }\n            function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === 'closed') {\n                    action();\n                }\n                else {\n                    uponFulfillment(promise, action);\n                }\n            }\n            function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\n                }\n                else {\n                    doTheRest();\n                }\n                function doTheRest() {\n                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n                }\n            }\n            function shutdown(isError, error) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n                }\n                else {\n                    finalize(isError, error);\n                }\n            }\n            function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== undefined) {\n                    signal.removeEventListener('abort', abortAlgorithm);\n                }\n                if (isError) {\n                    reject(error);\n                }\n                else {\n                    resolve(undefined);\n                }\n            }\n        });\n    }\n\n    /**\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n     *\n     * @public\n     */\n    class ReadableStreamDefaultController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n         */\n        get desiredSize() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('desiredSize');\n            }\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */\n        close() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('close');\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError('The stream is not in a state that permits close');\n            }\n            ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('enqueue');\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError('The stream is not in a state that permits enqueue');\n            }\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */\n        error(e = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('error');\n            }\n            ReadableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */\n        [CancelSteps](reason) {\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */\n        [PullSteps](readRequest) {\n            const stream = this._controlledReadableStream;\n            if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    ReadableStreamClose(stream);\n                }\n                else {\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n            }\n            else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: { enumerable: true },\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        desiredSize: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamDefaultController',\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStreamDefaultController.\n    function IsReadableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultController;\n    }\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, () => {\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n        }, e => {\n            ReadableStreamDefaultControllerError(controller, e);\n        });\n    }\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n    function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n        }\n    }\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\n        }\n        else {\n            let chunkSize;\n            try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n            }\n            catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n            }\n            try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n            }\n            catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n            }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    function ReadableStreamDefaultControllerError(controller, e) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== 'readable') {\n            return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === 'errored') {\n            return null;\n        }\n        if (state === 'closed') {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    // This is used in the implementation of TransformStream.\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n            return false;\n        }\n        return true;\n    }\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === 'readable') {\n            return true;\n        }\n        return false;\n    }\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), () => {\n            controller._started = true;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }, r => {\n            ReadableStreamDefaultControllerError(controller, r);\n        });\n    }\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm = () => undefined;\n        let pullAlgorithm = () => promiseResolvedWith(undefined);\n        let cancelAlgorithm = () => promiseResolvedWith(undefined);\n        if (underlyingSource.start !== undefined) {\n            startAlgorithm = () => underlyingSource.start(controller);\n        }\n        if (underlyingSource.pull !== undefined) {\n            pullAlgorithm = () => underlyingSource.pull(controller);\n        }\n        if (underlyingSource.cancel !== undefined) {\n            cancelAlgorithm = reason => underlyingSource.cancel(reason);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // Helper functions for the ReadableStreamDefaultController.\n    function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n    }\n\n    function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n            return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n    }\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise(resolve => {\n            resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n            if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const readRequest = {\n                _chunkSteps: chunk => {\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(() => {\n                        readAgain = false;\n                        const chunk1 = chunk;\n                        const chunk2 = chunk;\n                        // There is no way to access the cloning code right now in the reference implementation.\n                        // If we add one then we'll need an implementation for serializable objects.\n                        // if (!canceled2 && cloneForBranch2) {\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                        // }\n                        if (!canceled1) {\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgain) {\n                            pullAlgorithm();\n                        }\n                    });\n                },\n                _closeSteps: () => {\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: () => {\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            // do nothing\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r) => {\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n        });\n        return [branch1, branch2];\n    }\n    function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise(resolve => {\n            resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n            uponRejection(thisReader._closedPromise, r => {\n                if (thisReader !== reader) {\n                    return;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            });\n        }\n        function pullWithDefaultReader() {\n            if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n            }\n            const readRequest = {\n                _chunkSteps: chunk => {\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(() => {\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const chunk1 = chunk;\n                        let chunk2 = chunk;\n                        if (!canceled1 && !canceled2) {\n                            try {\n                                chunk2 = CloneAsUint8Array(chunk);\n                            }\n                            catch (cloneE) {\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                        }\n                        if (!canceled1) {\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        }\n                        else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: () => {\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\n                    }\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                    }\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: () => {\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n            if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n            }\n            const byobBranch = forBranch2 ? branch2 : branch1;\n            const otherBranch = forBranch2 ? branch1 : branch2;\n            const readIntoRequest = {\n                _chunkSteps: chunk => {\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(() => {\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                        if (!otherCanceled) {\n                            let clonedChunk;\n                            try {\n                                clonedChunk = CloneAsUint8Array(chunk);\n                            }\n                            catch (cloneE) {\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                            }\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                        }\n                        else if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        }\n                        else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: chunk => {\n                    reading = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                    }\n                    if (!otherCanceled) {\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                    }\n                    if (chunk !== undefined) {\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                        }\n                    }\n                    if (!byobCanceled || !otherCanceled) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: () => {\n                    reading = false;\n                }\n            };\n            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n        }\n        function pull1Algorithm() {\n            if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            }\n            else {\n                pullWithBYOBReader(byobRequest._view, false);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function pull2Algorithm() {\n            if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            }\n            else {\n                pullWithBYOBReader(byobRequest._view, true);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [branch1, branch2];\n    }\n\n    function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n                undefined :\n                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n            cancel: cancel === undefined ?\n                undefined :\n                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            pull: pull === undefined ?\n                undefined :\n                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n            start: start === undefined ?\n                undefined :\n                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n    }\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason) => promiseCall(fn, original, [reason]);\n    }\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => promiseCall(fn, original, [controller]);\n    }\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n    }\n    function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== 'bytes') {\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n    }\n\n    function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n    }\n    function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== 'byob') {\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n    }\n\n    function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return { preventCancel: Boolean(preventCancel) };\n    }\n\n    function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== undefined) {\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n            preventAbort: Boolean(preventAbort),\n            preventCancel: Boolean(preventCancel),\n            preventClose: Boolean(preventClose),\n            signal\n        };\n    }\n    function assertAbortSignal(signal, context) {\n        if (!isAbortSignal(signal)) {\n            throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n    }\n\n    function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return { readable, writable };\n    }\n\n    /**\n     * A readable stream represents a source of data, from which you can read.\n     *\n     * @public\n     */\n    class ReadableStream {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n            if (rawUnderlyingSource === undefined) {\n                rawUnderlyingSource = null;\n            }\n            else {\n                assertObject(rawUnderlyingSource, 'First parameter');\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n            InitializeReadableStream(this);\n            if (underlyingSource.type === 'bytes') {\n                if (strategy.size !== undefined) {\n                    throw new RangeError('The strategy for a byte stream cannot have a size function');\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n            }\n            else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n            }\n        }\n        /**\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n         */\n        get locked() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('locked');\n            }\n            return IsReadableStreamLocked(this);\n        }\n        /**\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n         *\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n         * method, which might or might not use it.\n         */\n        cancel(reason = undefined) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n            }\n            return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('getReader');\n            }\n            const options = convertReaderOptions(rawOptions, 'First parameter');\n            if (options.mode === undefined) {\n                return AcquireReadableStreamDefaultReader(this);\n            }\n            return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('pipeThrough');\n            }\n            assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n            const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n            const options = convertPipeOptions(rawOptions, 'Second parameter');\n            if (IsReadableStreamLocked(this)) {\n                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n            }\n            if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n            }\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            setPromiseIsHandledToTrue(promise);\n            return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n            }\n            if (destination === undefined) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n            }\n            if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n            }\n            let options;\n            try {\n                options = convertPipeOptions(rawOptions, 'Second parameter');\n            }\n            catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n            }\n            if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n            }\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        /**\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n         * new {@link ReadableStream} instances.\n         *\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n         * propagated to the stream's underlying source.\n         *\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n         * this could allow interference between the two branches.\n         */\n        tee() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('tee');\n            }\n            const branches = ReadableStreamTee(this);\n            return CreateArrayFromList(branches);\n        }\n        values(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('values');\n            }\n            const options = convertIteratorOptions(rawOptions, 'First parameter');\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n    }\n    Object.defineProperties(ReadableStream.prototype, {\n        cancel: { enumerable: true },\n        getReader: { enumerable: true },\n        pipeThrough: { enumerable: true },\n        pipeTo: { enumerable: true },\n        tee: { enumerable: true },\n        values: { enumerable: true },\n        locked: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStream',\n            configurable: true\n        });\n    }\n    if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n            value: ReadableStream.prototype.values,\n            writable: true,\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStream.\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n        return stream;\n    }\n    function InitializeReadableStream(stream) {\n        stream._state = 'readable';\n        stream._reader = undefined;\n        stream._storedError = undefined;\n        stream._disturbed = false;\n    }\n    function IsReadableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n            return false;\n        }\n        return x instanceof ReadableStream;\n    }\n    function IsReadableStreamLocked(stream) {\n        if (stream._reader === undefined) {\n            return false;\n        }\n        return true;\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === 'closed') {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._state === 'errored') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n            reader._readIntoRequests.forEach(readIntoRequest => {\n                readIntoRequest._closeSteps(undefined);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop);\n    }\n    function ReadableStreamClose(stream) {\n        stream._state = 'closed';\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach(readRequest => {\n                readRequest._closeSteps();\n            });\n            reader._readRequests = new SimpleQueue();\n        }\n    }\n    function ReadableStreamError(stream, e) {\n        stream._state = 'errored';\n        stream._storedError = e;\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseReject(reader, e);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach(readRequest => {\n                readRequest._errorSteps(e);\n            });\n            reader._readRequests = new SimpleQueue();\n        }\n        else {\n            reader._readIntoRequests.forEach(readIntoRequest => {\n                readIntoRequest._errorSteps(e);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n    }\n\n    function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n        return {\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n    }\n\n    // The size function must not have a prototype property nor be a constructor\n    const byteLengthSizeFunction = (chunk) => {\n        return chunk.byteLength;\n    };\n    try {\n        Object.defineProperty(byteLengthSizeFunction, 'name', {\n            value: 'size',\n            configurable: true\n        });\n    }\n    catch (_a) {\n        // This property is non-configurable in older browsers, so ignore if this throws.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of bytes in each chunk.\n     *\n     * @public\n     */\n    class ByteLengthQueuingStrategy {\n        constructor(options) {\n            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n            options = convertQueuingStrategyInit(options, 'First parameter');\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */\n        get highWaterMark() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException('highWaterMark');\n            }\n            return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n         */\n        get size() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException('size');\n            }\n            return byteLengthSizeFunction;\n        }\n    }\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: { enumerable: true },\n        size: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ByteLengthQueuingStrategy',\n            configurable: true\n        });\n    }\n    // Helper functions for the ByteLengthQueuingStrategy.\n    function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n    }\n    function IsByteLengthQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n            return false;\n        }\n        return x instanceof ByteLengthQueuingStrategy;\n    }\n\n    // The size function must not have a prototype property nor be a constructor\n    const countSizeFunction = () => {\n        return 1;\n    };\n    try {\n        Object.defineProperty(countSizeFunction, 'name', {\n            value: 'size',\n            configurable: true\n        });\n    }\n    catch (_a) {\n        // This property is non-configurable in older browsers, so ignore if this throws.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of chunks.\n     *\n     * @public\n     */\n    class CountQueuingStrategy {\n        constructor(options) {\n            assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n            options = convertQueuingStrategyInit(options, 'First parameter');\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */\n        get highWaterMark() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException('highWaterMark');\n            }\n            return this._countQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by always returning 1.\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\n         */\n        get size() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException('size');\n            }\n            return countSizeFunction;\n        }\n    }\n    Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: { enumerable: true },\n        size: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: 'CountQueuingStrategy',\n            configurable: true\n        });\n    }\n    // Helper functions for the CountQueuingStrategy.\n    function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n    }\n    function IsCountQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n            return false;\n        }\n        return x instanceof CountQueuingStrategy;\n    }\n\n    function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n            flush: flush === undefined ?\n                undefined :\n                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n            readableType,\n            start: start === undefined ?\n                undefined :\n                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n            transform: transform === undefined ?\n                undefined :\n                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n            writableType\n        };\n    }\n    function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => promiseCall(fn, original, [controller]);\n    }\n    function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n    }\n    function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n    }\n\n    // Class TransformStream\n    /**\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n     * made available for reading from the readable side.\n     *\n     * @public\n     */\n    class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n            if (rawTransformer === undefined) {\n                rawTransformer = null;\n            }\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n            const transformer = convertTransformer(rawTransformer, 'First parameter');\n            if (transformer.readableType !== undefined) {\n                throw new RangeError('Invalid readableType specified');\n            }\n            if (transformer.writableType !== undefined) {\n                throw new RangeError('Invalid writableType specified');\n            }\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n            let startPromise_resolve;\n            const startPromise = newPromise(resolve => {\n                startPromise_resolve = resolve;\n            });\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n            if (transformer.start !== undefined) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n            }\n            else {\n                startPromise_resolve(undefined);\n            }\n        }\n        /**\n         * The readable side of the transform stream.\n         */\n        get readable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException('readable');\n            }\n            return this._readable;\n        }\n        /**\n         * The writable side of the transform stream.\n         */\n        get writable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException('writable');\n            }\n            return this._writable;\n        }\n    }\n    Object.defineProperties(TransformStream.prototype, {\n        readable: { enumerable: true },\n        writable: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n            value: 'TransformStream',\n            configurable: true\n        });\n    }\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n            return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n            TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n            return promiseResolvedWith(undefined);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n        stream._backpressure = undefined;\n        stream._backpressureChangePromise = undefined;\n        stream._backpressureChangePromise_resolve = undefined;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = undefined;\n    }\n    function IsTransformStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n            return false;\n        }\n        return x instanceof TransformStream;\n    }\n    // This is a no-op if both sides are already errored.\n    function TransformStreamError(stream, e) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    }\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n        if (stream._backpressure) {\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n            // _backpressure is set.\n            TransformStreamSetBackpressure(stream, false);\n        }\n    }\n    function TransformStreamSetBackpressure(stream, backpressure) {\n        // Passes also when called during construction.\n        if (stream._backpressureChangePromise !== undefined) {\n            stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise(resolve => {\n            stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n    }\n    // Class TransformStreamDefaultController\n    /**\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n     *\n     * @public\n     */\n    class TransformStreamDefaultController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n         */\n        get desiredSize() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('desiredSize');\n            }\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('enqueue');\n            }\n            TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n         */\n        error(reason = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('error');\n            }\n            TransformStreamDefaultControllerError(this, reason);\n        }\n        /**\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n         * transformer only needs to consume a portion of the chunks written to the writable side.\n         */\n        terminate() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('terminate');\n            }\n            TransformStreamDefaultControllerTerminate(this);\n        }\n    }\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        terminate: { enumerable: true },\n        desiredSize: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'TransformStreamDefaultController',\n            configurable: true\n        });\n    }\n    // Transform Stream Default Controller Abstract Operations\n    function IsTransformStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n            return false;\n        }\n        return x instanceof TransformStreamDefaultController;\n    }\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n    }\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm = (chunk) => {\n            try {\n                TransformStreamDefaultControllerEnqueue(controller, chunk);\n                return promiseResolvedWith(undefined);\n            }\n            catch (transformResultE) {\n                return promiseRejectedWith(transformResultE);\n            }\n        };\n        let flushAlgorithm = () => promiseResolvedWith(undefined);\n        if (transformer.transform !== undefined) {\n            transformAlgorithm = chunk => transformer.transform(chunk, controller);\n        }\n        if (transformer.flush !== undefined) {\n            flushAlgorithm = () => transformer.flush(controller);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n    }\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = undefined;\n        controller._flushAlgorithm = undefined;\n    }\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n            throw new TypeError('Readable side is not in a state that permits enqueue');\n        }\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n        // accept TransformStreamDefaultControllerEnqueue() calls.\n        try {\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        }\n        catch (e) {\n            // This happens when readableStrategy.size() throws.\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n            TransformStreamSetBackpressure(stream, true);\n        }\n    }\n    function TransformStreamDefaultControllerError(controller, e) {\n        TransformStreamError(controller._controlledTransformStream, e);\n    }\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, undefined, r => {\n            TransformStreamError(controller._controlledTransformStream, r);\n            throw r;\n        });\n    }\n    function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError('TransformStream terminated');\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n    }\n    // TransformStreamDefaultSink Algorithms\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n            const backpressureChangePromise = stream._backpressureChangePromise;\n            return transformPromiseWith(backpressureChangePromise, () => {\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === 'erroring') {\n                    throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    }\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n        // errored.\n        TransformStreamError(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        const controller = stream._transformStreamController;\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        // Return a promise that is fulfilled with undefined on success.\n        return transformPromiseWith(flushPromise, () => {\n            if (readable._state === 'errored') {\n                throw readable._storedError;\n            }\n            ReadableStreamDefaultControllerClose(readable._readableStreamController);\n        }, r => {\n            TransformStreamError(stream, r);\n            throw readable._storedError;\n        });\n    }\n    // TransformStreamDefaultSource Algorithms\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        // Invariant. Enforced by the promises returned by start() and pull().\n        TransformStreamSetBackpressure(stream, false);\n        // Prevent the next pull() call until there is backpressure.\n        return stream._backpressureChangePromise;\n    }\n    // Helper functions for the TransformStreamDefaultController.\n    function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n    }\n    // Helper functions for the TransformStream.\n    function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n    }\n\n    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n    exports.CountQueuingStrategy = CountQueuingStrategy;\n    exports.ReadableByteStreamController = ReadableByteStreamController;\n    exports.ReadableStream = ReadableStream;\n    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;\n    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n    exports.TransformStream = TransformStream;\n    exports.TransformStreamDefaultController = TransformStreamDefaultController;\n    exports.WritableStream = WritableStream;\n    exports.WritableStreamDefaultController = WritableStreamDefaultController;\n    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ponyfill.es2018.js.map\n","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"assert\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"buffer\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"crypto\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"events\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"fs\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"http\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"https\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"net\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:process\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:stream/web\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"os\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"path\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"tls\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"util\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"worker_threads\");","/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n","import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:path\");","import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n","/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n","/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:http\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:https\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:zlib\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:stream\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:buffer\");","/**\n * Returns a `Buffer` instance from the given data URI `uri`.\n *\n * @param {String} uri Data URI to turn into a Buffer instance\n * @returns {Buffer} Buffer instance from Data URI\n * @api public\n */\nexport function dataUriToBuffer(uri) {\n    if (!/^data:/i.test(uri)) {\n        throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n    }\n    // strip newlines\n    uri = uri.replace(/\\r?\\n/g, '');\n    // split the URI up into the \"metadata\" and the \"data\" portions\n    const firstComma = uri.indexOf(',');\n    if (firstComma === -1 || firstComma <= 4) {\n        throw new TypeError('malformed data: URI');\n    }\n    // remove the \"data:\" scheme and parse the metadata\n    const meta = uri.substring(5, firstComma).split(';');\n    let charset = '';\n    let base64 = false;\n    const type = meta[0] || 'text/plain';\n    let typeFull = type;\n    for (let i = 1; i < meta.length; i++) {\n        if (meta[i] === 'base64') {\n            base64 = true;\n        }\n        else if (meta[i]) {\n            typeFull += `;${meta[i]}`;\n            if (meta[i].indexOf('charset=') === 0) {\n                charset = meta[i].substring(8);\n            }\n        }\n    }\n    // defaults to US-ASCII only if type is not provided\n    if (!meta[0] && !charset.length) {\n        typeFull += ';charset=US-ASCII';\n        charset = 'US-ASCII';\n    }\n    // get the encoded data portion and decode URI-encoded chars\n    const encoding = base64 ? 'base64' : 'ascii';\n    const data = unescape(uri.substring(firstComma + 1));\n    const buffer = Buffer.from(data, encoding);\n    // set `.type` and `.typeFull` properties to MIME type\n    buffer.type = type;\n    buffer.typeFull = typeFull;\n    // set the `.charset` property\n    buffer.charset = charset;\n    return buffer;\n}\nexport default dataUriToBuffer;\n//# sourceMappingURL=index.js.map","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:util\");","export class FetchBaseError extends Error {\n\tconstructor(message, type) {\n\t\tsuper(message);\n\t\t// Hide custom error implementation details from end-users\n\t\tError.captureStackTrace(this, this.constructor);\n\n\t\tthis.type = type;\n\t}\n\n\tget name() {\n\t\treturn this.constructor.name;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n}\n","\nimport {FetchBaseError} from './base.js';\n\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/\n\n/**\n * FetchError interface for operational errors\n */\nexport class FetchError extends FetchBaseError {\n\t/**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */\n\tconstructor(message, type, systemError) {\n\t\tsuper(message, type);\n\t\t// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n\t\tif (systemError) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tthis.code = this.errno = systemError.code;\n\t\t\tthis.erroredSysCall = systemError.syscall;\n\t\t}\n\t}\n}\n","/**\n * Is.js\n *\n * Object type checks.\n */\n\nconst NAME = Symbol.toStringTag;\n\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isURLSearchParameters = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.append === 'function' &&\n\t\ttypeof object.delete === 'function' &&\n\t\ttypeof object.get === 'function' &&\n\t\ttypeof object.getAll === 'function' &&\n\t\ttypeof object.has === 'function' &&\n\t\ttypeof object.set === 'function' &&\n\t\ttypeof object.sort === 'function' &&\n\t\tobject[NAME] === 'URLSearchParams'\n\t);\n};\n\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isBlob = object => {\n\treturn (\n\t\tobject &&\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.arrayBuffer === 'function' &&\n\t\ttypeof object.type === 'string' &&\n\t\ttypeof object.stream === 'function' &&\n\t\ttypeof object.constructor === 'function' &&\n\t\t/^(Blob|File)$/.test(object[NAME])\n\t);\n};\n\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isAbortSignal = object => {\n\treturn (\n\t\ttypeof object === 'object' && (\n\t\t\tobject[NAME] === 'AbortSignal' ||\n\t\t\tobject[NAME] === 'EventTarget'\n\t\t)\n\t);\n};\n\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isDomainOrSubdomain = (destination, original) => {\n\tconst orig = new URL(original).hostname;\n\tconst dest = new URL(destination).hostname;\n\n\treturn orig === dest || orig.endsWith(`.${dest}`);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isSameProtocol = (destination, original) => {\n\tconst orig = new URL(original).protocol;\n\tconst dest = new URL(destination).protocol;\n\n\treturn orig === dest;\n};\n","\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n","/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'node:util';\nimport http from 'node:http';\n\n/* c8 ignore next 9 */\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/* c8 ignore next 9 */\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* c8 ignore next */\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n","const redirectStatus = new Set([301, 302, 303, 307, 308]);\n\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */\nexport const isRedirect = code => {\n\treturn redirectStatus.has(code);\n};\n","/**\n * Response.js\n *\n * Response class provides content decoding\n */\n\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType} from './body.js';\nimport {isRedirect} from './utils/is-redirect.js';\n\nconst INTERNALS = Symbol('Response internals');\n\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Response extends Body {\n\tconstructor(body = null, options = {}) {\n\t\tsuper(body, options);\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n\t\tconst status = options.status != null ? options.status : 200;\n\n\t\tconst headers = new Headers(options.headers);\n\n\t\tif (body !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\ttype: 'default',\n\t\t\turl: options.url,\n\t\t\tstatus,\n\t\t\tstatusText: options.statusText || '',\n\t\t\theaders,\n\t\t\tcounter: options.counter,\n\t\t\thighWaterMark: options.highWaterMark\n\t\t};\n\t}\n\n\tget type() {\n\t\treturn this[INTERNALS].type;\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS].status;\n\t}\n\n\t/**\n\t * Convenience property representing if the request ended normally\n\t */\n\tget ok() {\n\t\treturn this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget highWaterMark() {\n\t\treturn this[INTERNALS].highWaterMark;\n\t}\n\n\t/**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */\n\tclone() {\n\t\treturn new Response(clone(this, this.highWaterMark), {\n\t\t\ttype: this.type,\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected,\n\t\t\tsize: this.size,\n\t\t\thighWaterMark: this.highWaterMark\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */\n\tstatic redirect(url, status = 302) {\n\t\tif (!isRedirect(status)) {\n\t\t\tthrow new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n\t\t}\n\n\t\treturn new Response(null, {\n\t\t\theaders: {\n\t\t\t\tlocation: new URL(url).toString()\n\t\t\t},\n\t\t\tstatus\n\t\t});\n\t}\n\n\tstatic error() {\n\t\tconst response = new Response(null, {status: 0, statusText: ''});\n\t\tresponse[INTERNALS].type = 'error';\n\t\treturn response;\n\t}\n\n\tstatic json(data = undefined, init = {}) {\n\t\tconst body = JSON.stringify(data);\n\n\t\tif (body === undefined) {\n\t\t\tthrow new TypeError('data is not JSON serializable');\n\t\t}\n\n\t\tconst headers = new Headers(init && init.headers);\n\n\t\tif (!headers.has('content-type')) {\n\t\t\theaders.set('content-type', 'application/json');\n\t\t}\n\n\t\treturn new Response(body, {\n\t\t\t...init,\n\t\t\theaders\n\t\t});\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Response';\n\t}\n}\n\nObject.defineProperties(Response.prototype, {\n\ttype: {enumerable: true},\n\turl: {enumerable: true},\n\tstatus: {enumerable: true},\n\tok: {enumerable: true},\n\tredirected: {enumerable: true},\n\tstatusText: {enumerable: true},\n\theaders: {enumerable: true},\n\tclone: {enumerable: true}\n});\n","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:url\");","export const getSearch = parsedURL => {\n\tif (parsedURL.search) {\n\t\treturn parsedURL.search;\n\t}\n\n\tconst lastOffset = parsedURL.href.length - 1;\n\tconst hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');\n\treturn parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';\n};\n","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:net\");","import {isIP} from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url, originOnly = false) {\n\t// 1. If url is null, return no referrer.\n\tif (url == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\treturn 'no-referrer';\n\t}\n\n\turl = new URL(url);\n\n\t// 2. If url's scheme is a local scheme, then return no referrer.\n\tif (/^(about|blob|data):$/.test(url.protocol)) {\n\t\treturn 'no-referrer';\n\t}\n\n\t// 3. Set url's username to the empty string.\n\turl.username = '';\n\n\t// 4. Set url's password to null.\n\t// Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\turl.password = '';\n\n\t// 5. Set url's fragment to null.\n\t// Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\turl.hash = '';\n\n\t// 6. If the origin-only flag is true, then:\n\tif (originOnly) {\n\t\t// 6.1. Set url's path to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n\t\turl.pathname = '';\n\n\t\t// 6.2. Set url's query to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\t\turl.search = '';\n\t}\n\n\t// 7. Return url.\n\treturn url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set([\n\t'',\n\t'no-referrer',\n\t'no-referrer-when-downgrade',\n\t'same-origin',\n\t'origin',\n\t'strict-origin',\n\t'origin-when-cross-origin',\n\t'strict-origin-when-cross-origin',\n\t'unsafe-url'\n]);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n\tif (!ReferrerPolicy.has(referrerPolicy)) {\n\t\tthrow new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n\t}\n\n\treturn referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n\t// 1. If origin is an opaque origin, return \"Not Trustworthy\".\n\t// Not applicable\n\n\t// 2. Assert: origin is a tuple origin.\n\t// Not for implementations\n\n\t// 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n\tif (/^(http|ws)s:$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\tconst hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n\tconst hostIPVersion = isIP(hostIp);\n\n\tif (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\tif (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\t// 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n\t// We are returning FALSE here because we cannot ensure conformance to\n\t// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\tif (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n\t\treturn false;\n\t}\n\n\t// 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\tif (url.protocol === 'file:') {\n\t\treturn true;\n\t}\n\n\t// 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 9. Return \"Not Trustworthy\".\n\treturn false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n\t// 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n\tif (/^about:(blank|srcdoc)$/.test(url)) {\n\t\treturn true;\n\t}\n\n\t// 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\tif (url.protocol === 'data:') {\n\t\treturn true;\n\t}\n\n\t// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n\t// created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n\t// trustworthy.\n\tif (/^(blob|filesystem):$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n\treturn isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {\n\t// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n\t// these cases:\n\t// > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n\t// > Note: If request's referrer policy is the empty string, Fetch will not call into this\n\t// > algorithm.\n\tif (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n\t\treturn null;\n\t}\n\n\t// 1. Let policy be request's associated referrer policy.\n\tconst policy = request.referrerPolicy;\n\n\t// 2. Let environment be request's client.\n\t// not applicable to node.js\n\n\t// 3. Switch on request's referrer:\n\tif (request.referrer === 'about:client') {\n\t\treturn 'no-referrer';\n\t}\n\n\t// \"a URL\": Let referrerSource be request's referrer.\n\tconst referrerSource = request.referrer;\n\n\t// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\tlet referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n\t// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n\t//    origin-only flag set to true.\n\tlet referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n\t// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n\t//    referrerURL to referrerOrigin.\n\tif (referrerURL.toString().length > 4096) {\n\t\treferrerURL = referrerOrigin;\n\t}\n\n\t// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n\t//    policy considerations in the interests of minimizing data leakage. For example, the user\n\t//    agent could strip the URL down to an origin, modify its host, replace it with an empty\n\t//    string, etc.\n\tif (referrerURLCallback) {\n\t\treferrerURL = referrerURLCallback(referrerURL);\n\t}\n\n\tif (referrerOriginCallback) {\n\t\treferrerOrigin = referrerOriginCallback(referrerOrigin);\n\t}\n\n\t// 8.Execute the statements corresponding to the value of policy:\n\tconst currentURL = new URL(request.url);\n\n\tswitch (policy) {\n\t\tcase 'no-referrer':\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin':\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'unsafe-url':\n\t\t\treturn referrerURL;\n\n\t\tcase 'strict-origin':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerOrigin.\n\t\t\treturn referrerOrigin.toString();\n\n\t\tcase 'strict-origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 3. Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'same-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. Return no referrer.\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'no-referrer-when-downgrade':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerURL.\n\t\t\treturn referrerURL;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Invalid referrerPolicy: ${policy}`);\n\t}\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n\t// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n\t//    and response’s header list.\n\tconst policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n\t// 2. Let policy be the empty string.\n\tlet policy = '';\n\n\t// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n\t//    string, then set policy to token.\n\t// Note: This algorithm loops over multiple policy values to allow deployment of new policy\n\t// values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n\tfor (const token of policyTokens) {\n\t\tif (token && ReferrerPolicy.has(token)) {\n\t\t\tpolicy = token;\n\t\t}\n\t}\n\n\t// 4. Return policy.\n\treturn policy;\n}\n","/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport {format as formatUrl} from 'node:url';\nimport {deprecate} from 'node:util';\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType, getTotalBytes} from './body.js';\nimport {isAbortSignal} from './utils/is.js';\nimport {getSearch} from './utils/get-search.js';\nimport {\n\tvalidateReferrerPolicy, determineRequestsReferrer, DEFAULT_REFERRER_POLICY\n} from './utils/referrer.js';\n\nconst INTERNALS = Symbol('Request internals');\n\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */\nconst isRequest = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object[INTERNALS] === 'object'\n\t);\n};\n\nconst doBadDataWarn = deprecate(() => {},\n\t'.data is not a valid RequestInit property, use .body instead',\n\t'https://github.com/node-fetch/node-fetch/issues/1000 (request)');\n\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nexport default class Request extends Body {\n\tconstructor(input, init = {}) {\n\t\tlet parsedURL;\n\n\t\t// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\t\tif (isRequest(input)) {\n\t\t\tparsedURL = new URL(input.url);\n\t\t} else {\n\t\t\tparsedURL = new URL(input);\n\t\t\tinput = {};\n\t\t}\n\n\t\tif (parsedURL.username !== '' || parsedURL.password !== '') {\n\t\t\tthrow new TypeError(`${parsedURL} is an url with embedded credentials.`);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tif (/^(delete|get|head|options|post|put)$/i.test(method)) {\n\t\t\tmethod = method.toUpperCase();\n\t\t}\n\n\t\tif (!isRequest(init) && 'data' in init) {\n\t\t\tdoBadDataWarn();\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif ((init.body != null || (isRequest(input) && input.body !== null)) &&\n\t\t\t(method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tconst inputBody = init.body ?\n\t\t\tinit.body :\n\t\t\t(isRequest(input) && input.body !== null ?\n\t\t\t\tclone(input) :\n\t\t\t\tnull);\n\n\t\tsuper(inputBody, {\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.set('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ?\n\t\t\tinput.signal :\n\t\t\tnull;\n\t\tif ('signal' in init) {\n\t\t\tsignal = init.signal;\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n\t\t}\n\n\t\t// §5.4, Request constructor steps, step 15.1\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tlet referrer = init.referrer == null ? input.referrer : init.referrer;\n\t\tif (referrer === '') {\n\t\t\t// §5.4, Request constructor steps, step 15.2\n\t\t\treferrer = 'no-referrer';\n\t\t} else if (referrer) {\n\t\t\t// §5.4, Request constructor steps, step 15.3.1, 15.3.2\n\t\t\tconst parsedReferrer = new URL(referrer);\n\t\t\t// §5.4, Request constructor steps, step 15.3.3, 15.3.4\n\t\t\treferrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;\n\t\t} else {\n\t\t\treferrer = undefined;\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal,\n\t\t\treferrer\n\t\t};\n\n\t\t// Node-fetch-only options\n\t\tthis.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;\n\t\tthis.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t\tthis.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n\t\tthis.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n\n\t\t// §5.4, Request constructor steps, step 16.\n\t\t// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n\t\tthis.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';\n\t}\n\n\t/** @returns {string} */\n\tget method() {\n\t\treturn this[INTERNALS].method;\n\t}\n\n\t/** @returns {string} */\n\tget url() {\n\t\treturn formatUrl(this[INTERNALS].parsedURL);\n\t}\n\n\t/** @returns {Headers} */\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS].redirect;\n\t}\n\n\t/** @returns {AbortSignal} */\n\tget signal() {\n\t\treturn this[INTERNALS].signal;\n\t}\n\n\t// https://fetch.spec.whatwg.org/#dom-request-referrer\n\tget referrer() {\n\t\tif (this[INTERNALS].referrer === 'no-referrer') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer === 'client') {\n\t\t\treturn 'about:client';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer) {\n\t\t\treturn this[INTERNALS].referrer.toString();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget referrerPolicy() {\n\t\treturn this[INTERNALS].referrerPolicy;\n\t}\n\n\tset referrerPolicy(referrerPolicy) {\n\t\tthis[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n\t}\n\n\t/**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Request';\n\t}\n}\n\nObject.defineProperties(Request.prototype, {\n\tmethod: {enumerable: true},\n\turl: {enumerable: true},\n\theaders: {enumerable: true},\n\tredirect: {enumerable: true},\n\tclone: {enumerable: true},\n\tsignal: {enumerable: true},\n\treferrer: {enumerable: true},\n\treferrerPolicy: {enumerable: true}\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */\nexport const getNodeRequestOptions = request => {\n\tconst {parsedURL} = request[INTERNALS];\n\tconst headers = new Headers(request[INTERNALS].headers);\n\n\t// Fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body === null && /^(post|put)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\n\tif (request.body !== null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\t// Set Content-Length if totalBytes is a number (that is not NaN)\n\t\tif (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// 4.1. Main fetch, step 2.6\n\t// > If request's referrer policy is the empty string, then set request's referrer policy to the\n\t// > default referrer policy.\n\tif (request.referrerPolicy === '') {\n\t\trequest.referrerPolicy = DEFAULT_REFERRER_POLICY;\n\t}\n\n\t// 4.1. Main fetch, step 2.7\n\t// > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n\t// > determine request's referrer.\n\tif (request.referrer && request.referrer !== 'no-referrer') {\n\t\trequest[INTERNALS].referrer = determineRequestsReferrer(request);\n\t} else {\n\t\trequest[INTERNALS].referrer = 'no-referrer';\n\t}\n\n\t// 4.5. HTTP-network-or-cache fetch, step 6.9\n\t// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n\t// >  and isomorphic encoded, to httpRequest's header list.\n\tif (request[INTERNALS].referrer instanceof URL) {\n\t\theaders.set('Referer', request.referrer);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip, deflate, br');\n\t}\n\n\tlet {agent} = request;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\tconst search = getSearch(parsedURL);\n\n\t// Pass the full URL directly to request(), but overwrite the following\n\t// options:\n\tconst options = {\n\t\t// Overwrite search to retain trailing ? (issue #776)\n\t\tpath: parsedURL.pathname + search,\n\t\t// The following options are not expressed in the URL\n\t\tmethod: request.method,\n\t\theaders: headers[Symbol.for('nodejs.util.inspect.custom')](),\n\t\tinsecureHTTPParser: request.insecureHTTPParser,\n\t\tagent\n\t};\n\n\treturn {\n\t\t/** @type {URL} */\n\t\tparsedURL,\n\t\toptions\n\t};\n};\n","import {FetchBaseError} from './base.js';\n\n/**\n * AbortError interface for cancelled requests\n */\nexport class AbortError extends FetchBaseError {\n\tconstructor(message, type = 'aborted') {\n\t\tsuper(message, type);\n\t}\n}\n","/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport http from 'node:http';\nimport https from 'node:https';\nimport zlib from 'node:zlib';\nimport Stream, {PassThrough, pipeline as pump} from 'node:stream';\nimport {Buffer} from 'node:buffer';\n\nimport dataUriToBuffer from 'data-uri-to-buffer';\n\nimport {writeToStream, clone} from './body.js';\nimport Response from './response.js';\nimport Headers, {fromRawHeaders} from './headers.js';\nimport Request, {getNodeRequestOptions} from './request.js';\nimport {FetchError} from './errors/fetch-error.js';\nimport {AbortError} from './errors/abort-error.js';\nimport {isRedirect} from './utils/is-redirect.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\nimport {isDomainOrSubdomain, isSameProtocol} from './utils/is.js';\nimport {parseReferrerPolicyFromHeader} from './utils/referrer.js';\nimport {\n\tBlob,\n\tFile,\n\tfileFromSync,\n\tfileFrom,\n\tblobFromSync,\n\tblobFrom\n} from 'fetch-blob/from.js';\n\nexport {FormData, Headers, Request, Response, FetchError, AbortError, isRedirect};\nexport {Blob, File, fileFromSync, fileFrom, blobFromSync, blobFrom};\n\nconst supportedSchemas = new Set(['data:', 'http:', 'https:']);\n\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */\nexport default async function fetch(url, options_) {\n\treturn new Promise((resolve, reject) => {\n\t\t// Build request object\n\t\tconst request = new Request(url, options_);\n\t\tconst {parsedURL, options} = getNodeRequestOptions(request);\n\t\tif (!supportedSchemas.has(parsedURL.protocol)) {\n\t\t\tthrow new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, '')}\" is not supported.`);\n\t\t}\n\n\t\tif (parsedURL.protocol === 'data:') {\n\t\t\tconst data = dataUriToBuffer(request.url);\n\t\t\tconst response = new Response(data, {headers: {'Content-Type': data.typeFull}});\n\t\t\tresolve(response);\n\t\t\treturn;\n\t\t}\n\n\t\t// Wrap http.request into fetch\n\t\tconst send = (parsedURL.protocol === 'https:' ? https : http).request;\n\t\tconst {signal} = request;\n\t\tlet response = null;\n\n\t\tconst abort = () => {\n\t\t\tconst error = new AbortError('The operation was aborted.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\n\t\t\tif (!response || !response.body) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = () => {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// Send request\n\t\tconst request_ = send(parsedURL.toString(), options);\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tconst finalize = () => {\n\t\t\trequest_.abort();\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t}\n\t\t};\n\n\t\trequest_.on('error', error => {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(request_, error => {\n\t\t\tif (response && response.body) {\n\t\t\t\tresponse.body.destroy(error);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (process.version < 'v14') {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\trequest_.on('socket', s => {\n\t\t\t\tlet endedWithEventsCount;\n\t\t\t\ts.prependListener('end', () => {\n\t\t\t\t\tendedWithEventsCount = s._eventsCount;\n\t\t\t\t});\n\t\t\t\ts.prependListener('close', hadError => {\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && endedWithEventsCount < s._eventsCount && !hadError) {\n\t\t\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\trequest_.on('response', response_ => {\n\t\t\trequest_.setTimeout(0);\n\t\t\tconst headers = fromRawHeaders(response_.rawHeaders);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (isRedirect(response_.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL(location, request.url);\n\t\t\t\t} catch {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// Nothing to do\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow': {\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOptions = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: clone(request),\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\tsize: request.size,\n\t\t\t\t\t\t\treferrer: request.referrer,\n\t\t\t\t\t\t\treferrerPolicy: request.referrerPolicy\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// when forwarding sensitive headers like \"Authorization\",\n\t\t\t\t\t\t// \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n\t\t\t\t\t\t// headers will be ignored when following a redirect to a domain\n\t\t\t\t\t\t// that is not a subdomain match or exact match of the initial domain.\n\t\t\t\t\t\t// For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n\t\t\t\t\t\t// will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\t\t\t\t\t\t// headers will also be ignored when following a redirect to a domain using\n\t\t\t\t\t\t// a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n\t\t\t\t\t\t// will not forward the sensitive headers\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOptions.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {\n\t\t\t\t\t\t\trequestOptions.method = 'GET';\n\t\t\t\t\t\t\trequestOptions.body = undefined;\n\t\t\t\t\t\t\trequestOptions.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 14\n\t\t\t\t\t\tconst responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n\t\t\t\t\t\tif (responseReferrerPolicy) {\n\t\t\t\t\t\t\trequestOptions.referrerPolicy = responseReferrerPolicy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOptions)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prepare response\n\t\t\tif (signal) {\n\t\t\t\tresponse_.once('end', () => {\n\t\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet body = pump(response_, new PassThrough(), error => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// see https://github.com/nodejs/node/pull/29376\n\t\t\t/* c8 ignore next 3 */\n\t\t\tif (process.version < 'v12.10') {\n\t\t\t\tresponse_.on('aborted', abortAndFinalize);\n\t\t\t}\n\n\t\t\tconst responseOptions = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: response_.statusCode,\n\t\t\t\tstatusText: response_.statusMessage,\n\t\t\t\theaders,\n\t\t\t\tsize: request.size,\n\t\t\t\tcounter: request.counter,\n\t\t\t\thighWaterMark: request.highWaterMark\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// For gzip\n\t\t\tif (codings === 'gzip' || codings === 'x-gzip') {\n\t\t\t\tbody = pump(body, zlib.createGunzip(zlibOptions), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For deflate\n\t\t\tif (codings === 'deflate' || codings === 'x-deflate') {\n\t\t\t\t// Handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = pump(response_, new PassThrough(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\traw.once('data', chunk => {\n\t\t\t\t\t// See http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflate(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflateRaw(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.once('end', () => {\n\t\t\t\t\t// Some old IIS servers return zero-length OK deflate responses, so\n\t\t\t\t\t// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For br\n\t\t\tif (codings === 'br') {\n\t\t\t\tbody = pump(body, zlib.createBrotliDecompress(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, use response as-is\n\t\t\tresponse = new Response(body, responseOptions);\n\t\t\tresolve(response);\n\t\t});\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\twriteToStream(request_, request).catch(reject);\n\t});\n}\n\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tconst LAST_CHUNK = Buffer.from('0\\r\\n\\r\\n');\n\n\tlet isChunkedTransfer = false;\n\tlet properLastChunkReceived = false;\n\tlet previousChunk;\n\n\trequest.on('response', response => {\n\t\tconst {headers} = response;\n\t\tisChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];\n\t});\n\n\trequest.on('socket', socket => {\n\t\tconst onSocketClose = () => {\n\t\t\tif (isChunkedTransfer && !properLastChunkReceived) {\n\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\terrorCallback(error);\n\t\t\t}\n\t\t};\n\n\t\tconst onData = buf => {\n\t\t\tproperLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n\n\t\t\t// Sometimes final 0-length chunk and end of message code are in separate packets\n\t\t\tif (!properLastChunkReceived && previousChunk) {\n\t\t\t\tproperLastChunkReceived = (\n\t\t\t\t\tBuffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&\n\t\t\t\t\tBuffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpreviousChunk = buf;\n\t\t};\n\n\t\tsocket.prependListener('close', onSocketClose);\n\t\tsocket.on('data', onData);\n\n\t\trequest.on('close', () => {\n\t\t\tsocket.removeListener('close', onSocketClose);\n\t\t\tsocket.removeListener('data', onData);\n\t\t});\n\t});\n}\n","import nodeFetch from 'node-fetch'\nimport pkg from '@atproto/api'\nconst { BskyAgent } = pkg\n\nexport default async function bsky(service) {\n  BskyAgent.configure({\n    // fetch polyfill\n    async fetch(httpUri, httpMethod, httpHeaders, httpReqBody) {\n      const res = await nodeFetch(httpUri, {\n        method: httpMethod,\n        headers: httpHeaders,\n        body: JSON.stringify(httpReqBody)\n      })\n      const response = {\n        status: res.status,\n        body: await res.json()\n      }\n      return response\n    }\n  })\n\n  const agent = new BskyAgent({\n    service: service\n  })\n\n  await agent.login({\n    identifier: process.env.BSKY_IDENTIFIER,\n    password: process.env.BSKY_PASSWORD\n  })\n\n  return agent\n}\n","import * as core from '@actions/core'\nimport agent from './agent.js'\nimport post from './post.js'\nimport validate from './validate.js'\n\nconst content = core.getInput('post', { required: true })\nconst service = core.getInput('service')\n\nconst bskyAgent = await agent(service)\nconst bskyPost = await post(content, bskyAgent)\nconst validation = await validate(bskyPost)\n\nif (validation.success) {\n  try {\n    await bskyAgent.post(bskyPost)\n    core.info('Post successful')\n  } catch (error) {\n    core.error(error)\n    core.setFailed(error)\n  }\n} else {\n  core.error(validation)\n  core.setFailed(validation)\n}\n","import pkg from '@atproto/api'\nconst { RichText } = pkg\n\nexport default async function post(content, agent) {\n  const rt = new RichText({\n    text: content\n  })\n\n  // Automatically detect facets.\n  await rt.detectFacets(agent)\n\n  // https://github.com/bluesky-social/atproto/issues/834#issuecomment-1514046354\n  // Filter out any facets with features\n  // that have no value set value.\n  let facets = null\n\n  if (rt.facets) {\n    facets = rt.facets.filter((facet) => {\n      const features = facet.features.filter(\n        (feature) =>\n          (feature?.uri && feature?.uri !== '') ||\n          (feature?.did && feature?.did !== '')\n      )\n\n      return features.length > 0\n    })\n  }\n\n  const postRecord = {\n    $type: 'app.bsky.feed.post',\n    text: rt.text,\n    ...(facets && { facets }),\n    createdAt: new Date().toISOString()\n  }\n\n  return postRecord\n}\n","import pkg from '@atproto/api'\nconst { AppBskyFeedPost } = pkg\n\nexport default async function validate(bskyPost) {\n  if (AppBskyFeedPost.isRecord(bskyPost)) {\n    const res = AppBskyFeedPost.validateRecord(bskyPost)\n    if (res.error) {\n      return res.error\n    }\n    return res\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\nvar installChunk = (data) => {\n\tvar {ids, modules, runtime} = data;\n\t// add \"modules\" to the modules object,\n\t// then flag all \"ids\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tfor(moduleId in modules) {\n\t\tif(__webpack_require__.o(modules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = modules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tfor(;i < ids.length; i++) {\n\t\tchunkId = ids[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[ids[i]] = 0;\n\t}\n\n}\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// import() chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[1]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = import(\"./\" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {\n\t\t\t\t\t\tif(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t\tvar promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])\n\t\t\t\t\tpromises.push(installedChunkData[1] = promise);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no external install chunk\n\n// no on chunks loaded","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(614);\n",""],"names":[],"sourceRoot":""}